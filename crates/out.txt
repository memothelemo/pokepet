#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod internal {
    pub mod macros {
        pub(crate) use enum_event_type;
        pub(crate) use bitflags;
        pub(crate) use enum_repr;
        pub(crate) use enum_string;
        pub(crate) use log_warn;
    }
}
pub mod gateway {
    mod event {
        mod kind {
            use crate::internal::macros::enum_event_type;
            #[non_exhaustive]
            pub enum GatewayEventType {
                PresenceUpdate,
                Unknown(String),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for GatewayEventType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        GatewayEventType::PresenceUpdate => {
                            ::core::fmt::Formatter::write_str(f, "PresenceUpdate")
                        }
                        GatewayEventType::Unknown(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Unknown",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for GatewayEventType {
                #[inline]
                fn clone(&self) -> GatewayEventType {
                    match self {
                        GatewayEventType::PresenceUpdate => {
                            GatewayEventType::PresenceUpdate
                        }
                        GatewayEventType::Unknown(__self_0) => {
                            GatewayEventType::Unknown(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for GatewayEventType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for GatewayEventType {
                #[inline]
                fn eq(&self, other: &GatewayEventType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                GatewayEventType::Unknown(__self_0),
                                GatewayEventType::Unknown(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => true,
                        }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for GatewayEventType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for GatewayEventType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for GatewayEventType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        GatewayEventType::Unknown(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        _ => {}
                    }
                }
            }
            impl GatewayEventType {
                #[doc(hidden)]
                fn __internal_enum_string(value: &str) -> Option<Self> {
                    match value {
                        "PRESENCE_UPDATE" => Some(Self::PresenceUpdate),
                        _ => Some(Self::Unknown(value.to_string())),
                    }
                }
            }
            impl std::fmt::Display for GatewayEventType {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        Self::PresenceUpdate => f.write_str("PRESENCE_UPDATE"),
                        Self::Unknown(n) => n.fmt(f),
                    }
                }
            }
            impl<'de> serde::Deserialize<'de> for GatewayEventType {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = GatewayEventType;
                        fn expecting(
                            &self,
                            f: &mut std::fmt::Formatter<'_>,
                        ) -> std::fmt::Result {
                            f.write_str("GatewayEventType enum")
                        }
                        fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            GatewayEventType::__internal_enum_string(value)
                                .ok_or_else(|| {
                                    serde::de::Error::custom({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "unknown GatewayEventType variant: {0:?}", value
                                            ),
                                        );
                                        res
                                    })
                                })
                        }
                    }
                    deserializer.deserialize_str(Visitor)
                }
            }
            impl serde::Serialize for GatewayEventType {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    serializer.collect_str(self)
                }
            }
        }
        pub use kind::*;
    }
    mod id {
        use std::num::NonZeroU64;
        pub struct ShardId {
            index: u64,
            total: NonZeroU64,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ShardId {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "ShardId",
                    "index",
                    &self.index,
                    "total",
                    &&self.total,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ShardId {
            #[inline]
            fn clone(&self) -> ShardId {
                let _: ::core::clone::AssertParamIsClone<u64>;
                let _: ::core::clone::AssertParamIsClone<NonZeroU64>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ShardId {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ShardId {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ShardId {
            #[inline]
            fn eq(&self, other: &ShardId) -> bool {
                self.index == other.index && self.total == other.total
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for ShardId {}
        #[automatically_derived]
        impl ::core::cmp::Eq for ShardId {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<NonZeroU64>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ShardId {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.index, state);
                ::core::hash::Hash::hash(&self.total, state)
            }
        }
        impl std::fmt::Display for ShardId {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.debug_list().entry(&self.index).entry(&self.total).finish()
            }
        }
        impl From<ShardId> for [u64; 2] {
            fn from(value: ShardId) -> Self {
                [value.index(), value.total()]
            }
        }
        impl PartialOrd for ShardId {
            fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
                if self.total != other.total {
                    return None;
                }
                Some(self.total.cmp(&other.total))
            }
        }
        impl ShardId {
            pub const DEFAULT: Self = Self::new(0, 1);
            pub const fn new(index: u64, total: u64) -> Self {
                if !(index < total) {
                    ::core::panicking::panic_fmt(
                        format_args!("number must be less than total"),
                    )
                }
                if let Some(total) = NonZeroU64::new(total) {
                    Self { index, total }
                } else {
                    ::core::panicking::panic_fmt(
                        format_args!("total must be at least 1"),
                    );
                }
            }
            pub const fn new_checked(index: u64, total: u64) -> Option<Self> {
                if index >= total {
                    return None;
                }
                if let Some(total) = NonZeroU64::new(total) {
                    Some(Self { index, total })
                } else {
                    None
                }
            }
        }
        impl ShardId {
            pub const fn index(self) -> u64 {
                self.index
            }
            pub const fn total(self) -> u64 {
                self.total.get()
            }
        }
        impl<'de> serde::de::Deserialize<'de> for ShardId {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ShardId;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("shard id")
                    }
                    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
                    where
                        A: serde::de::SeqAccess<'de>,
                    {
                        let id: u64 = seq
                            .next_element()?
                            .ok_or_else(|| serde::de::Error::custom(
                                "missing first entry (id)",
                            ))?;
                        let total: u64 = seq
                            .next_element()?
                            .ok_or_else(|| serde::de::Error::custom(
                                "missing second entry (total)",
                            ))?;
                        if id >= total {
                            return Err(
                                serde::de::Error::custom("id must be less than total"),
                            );
                        }
                        ShardId::new_checked(id, total)
                            .ok_or_else(|| serde::de::Error::custom(
                                "total must be at least 1",
                            ))
                    }
                }
                deserializer.deserialize_seq(Visitor)
            }
        }
        impl serde::Serialize for ShardId {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                use serde::ser::SerializeSeq;
                let mut seq = serializer.serialize_seq(Some(2))?;
                seq.serialize_element(&self.index)?;
                seq.serialize_element(&self.total.get())?;
                seq.end()
            }
        }
    }
    mod intents {
        use crate::internal::macros::bitflags;
        /// Gateway Intents is used to filter events that the application
        /// should except to recieve and do some action with it.
        ///
        /// This model exists to save some bandwidth and CPU processing
        /// to the client that actually runs the application for the bot.
        pub struct GatewayIntents(
            <GatewayIntents as ::bitflags::__private::PublicFlags>::Internal,
        );
        #[automatically_derived]
        impl ::core::fmt::Debug for GatewayIntents {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GatewayIntents",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GatewayIntents {
            #[inline]
            fn clone(&self) -> GatewayIntents {
                let _: ::core::clone::AssertParamIsClone<
                    <GatewayIntents as ::bitflags::__private::PublicFlags>::Internal,
                >;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for GatewayIntents {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for GatewayIntents {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for GatewayIntents {
            #[inline]
            fn eq(&self, other: &GatewayIntents) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for GatewayIntents {}
        #[automatically_derived]
        impl ::core::cmp::Eq for GatewayIntents {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<
                    <GatewayIntents as ::bitflags::__private::PublicFlags>::Internal,
                >;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for GatewayIntents {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl GatewayIntents {
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILDS: Self = Self::from_bits_retain(1 << 0);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_MEMBERS: Self = Self::from_bits_retain(1 << 1);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_MODERATION: Self = Self::from_bits_retain(1 << 2);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_EMOJIS_AND_STICKERS: Self = Self::from_bits_retain(1 << 3);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_INTEGRATIONS: Self = Self::from_bits_retain(1 << 4);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_WEBHOOKS: Self = Self::from_bits_retain(1 << 5);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_INVITES: Self = Self::from_bits_retain(1 << 6);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_VOICE_STATES: Self = Self::from_bits_retain(1 << 7);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_PRESENCES: Self = Self::from_bits_retain(1 << 8);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_MESSAGES: Self = Self::from_bits_retain(1 << 9);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_MESSAGE_REACTIONS: Self = Self::from_bits_retain(1 << 10);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_MESSAGE_TYPING: Self = Self::from_bits_retain(1 << 11);
            #[allow(deprecated, non_upper_case_globals)]
            pub const DIRECT_MESSAGES: Self = Self::from_bits_retain(1 << 12);
            #[allow(deprecated, non_upper_case_globals)]
            pub const DIRECT_MESSAGE_REACTIONS: Self = Self::from_bits_retain(1 << 13);
            #[allow(deprecated, non_upper_case_globals)]
            pub const DIRECT_MESSAGE_TYPING: Self = Self::from_bits_retain(1 << 14);
            #[allow(deprecated, non_upper_case_globals)]
            pub const MESSAGE_CONTENT: Self = Self::from_bits_retain(1 << 15);
            #[allow(deprecated, non_upper_case_globals)]
            pub const GUILD_SCHEDULED_EVENTS: Self = Self::from_bits_retain(1 << 16);
            #[allow(deprecated, non_upper_case_globals)]
            pub const AUTO_MODERATION_CONFIGURATION: Self = Self::from_bits_retain(
                1 << 20,
            );
            #[allow(deprecated, non_upper_case_globals)]
            pub const AUTO_MODERATION_EXECUTION: Self = Self::from_bits_retain(1 << 21);
        }
        impl ::bitflags::Flags for GatewayIntents {
            const FLAGS: &'static [::bitflags::Flag<GatewayIntents>] = &[
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("GUILDS", GatewayIntents::GUILDS)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("GUILD_MEMBERS", GatewayIntents::GUILD_MEMBERS)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "GUILD_MODERATION",
                        GatewayIntents::GUILD_MODERATION,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "GUILD_EMOJIS_AND_STICKERS",
                        GatewayIntents::GUILD_EMOJIS_AND_STICKERS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "GUILD_INTEGRATIONS",
                        GatewayIntents::GUILD_INTEGRATIONS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "GUILD_WEBHOOKS",
                        GatewayIntents::GUILD_WEBHOOKS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("GUILD_INVITES", GatewayIntents::GUILD_INVITES)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "GUILD_VOICE_STATES",
                        GatewayIntents::GUILD_VOICE_STATES,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "GUILD_PRESENCES",
                        GatewayIntents::GUILD_PRESENCES,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "GUILD_MESSAGES",
                        GatewayIntents::GUILD_MESSAGES,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "GUILD_MESSAGE_REACTIONS",
                        GatewayIntents::GUILD_MESSAGE_REACTIONS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "GUILD_MESSAGE_TYPING",
                        GatewayIntents::GUILD_MESSAGE_TYPING,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "DIRECT_MESSAGES",
                        GatewayIntents::DIRECT_MESSAGES,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "DIRECT_MESSAGE_REACTIONS",
                        GatewayIntents::DIRECT_MESSAGE_REACTIONS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "DIRECT_MESSAGE_TYPING",
                        GatewayIntents::DIRECT_MESSAGE_TYPING,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "MESSAGE_CONTENT",
                        GatewayIntents::MESSAGE_CONTENT,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "GUILD_SCHEDULED_EVENTS",
                        GatewayIntents::GUILD_SCHEDULED_EVENTS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "AUTO_MODERATION_CONFIGURATION",
                        GatewayIntents::AUTO_MODERATION_CONFIGURATION,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "AUTO_MODERATION_EXECUTION",
                        GatewayIntents::AUTO_MODERATION_EXECUTION,
                    )
                },
            ];
            type Bits = u64;
            fn bits(&self) -> u64 {
                GatewayIntents::bits(self)
            }
            fn from_bits_retain(bits: u64) -> GatewayIntents {
                GatewayIntents::from_bits_retain(bits)
            }
        }
        #[allow(
            dead_code,
            deprecated,
            unused_doc_comments,
            unused_attributes,
            unused_mut,
            unused_imports,
            non_upper_case_globals,
            clippy::assign_op_pattern
        )]
        const _: () = {
            #[repr(transparent)]
            pub struct InternalBitFlags(u64);
            #[automatically_derived]
            impl ::core::clone::Clone for InternalBitFlags {
                #[inline]
                fn clone(&self) -> InternalBitFlags {
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for InternalBitFlags {
                #[inline]
                fn eq(&self, other: &InternalBitFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for InternalBitFlags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u64>;
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for InternalBitFlags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &InternalBitFlags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for InternalBitFlags {
                #[inline]
                fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for InternalBitFlags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            impl ::bitflags::__private::PublicFlags for GatewayIntents {
                type Primitive = u64;
                type Internal = InternalBitFlags;
            }
            impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                #[inline]
                fn default() -> Self {
                    InternalBitFlags::empty()
                }
            }
            impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    if self.is_empty() {
                        f.write_fmt(
                            format_args!("{0:#x}", < u64 as ::bitflags::Bits >::EMPTY),
                        )
                    } else {
                        ::bitflags::__private::core::fmt::Display::fmt(self, f)
                    }
                }
            }
            impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::parser::to_writer(&GatewayIntents(*self), f)
                }
            }
            impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                type Err = ::bitflags::parser::ParseError;
                fn from_str(
                    s: &str,
                ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                    ::bitflags::parser::from_str::<GatewayIntents>(s)
                        .map(|flags| flags.0)
                }
            }
            impl ::bitflags::__private::core::convert::AsRef<u64> for InternalBitFlags {
                fn as_ref(&self) -> &u64 {
                    &self.0
                }
            }
            impl ::bitflags::__private::core::convert::From<u64> for InternalBitFlags {
                fn from(bits: u64) -> Self {
                    Self::from_bits_retain(bits)
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl InternalBitFlags {
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(<u64 as ::bitflags::Bits>::EMPTY) }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    { Self::from_bits_truncate(<u64 as ::bitflags::Bits>::ALL) }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u64 {
                    let f = self;
                    { f.0 }
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u64,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        let truncated = Self::from_bits_truncate(bits).0;
                        if truncated == bits {
                            ::bitflags::__private::core::option::Option::Some(Self(bits))
                        } else {
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u64) -> Self {
                    let bits = bits;
                    {
                        if bits == <u64 as ::bitflags::Bits>::EMPTY {
                            return Self(bits);
                        }
                        let mut truncated = <u64 as ::bitflags::Bits>::EMPTY;
                        {
                            if bits & GatewayIntents::GUILDS.bits()
                                == GatewayIntents::GUILDS.bits()
                            {
                                truncated = truncated | GatewayIntents::GUILDS.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_MEMBERS.bits()
                                == GatewayIntents::GUILD_MEMBERS.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_MEMBERS.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_MODERATION.bits()
                                == GatewayIntents::GUILD_MODERATION.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_MODERATION.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_EMOJIS_AND_STICKERS.bits()
                                == GatewayIntents::GUILD_EMOJIS_AND_STICKERS.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_EMOJIS_AND_STICKERS.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_INTEGRATIONS.bits()
                                == GatewayIntents::GUILD_INTEGRATIONS.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_INTEGRATIONS.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_WEBHOOKS.bits()
                                == GatewayIntents::GUILD_WEBHOOKS.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_WEBHOOKS.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_INVITES.bits()
                                == GatewayIntents::GUILD_INVITES.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_INVITES.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_VOICE_STATES.bits()
                                == GatewayIntents::GUILD_VOICE_STATES.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_VOICE_STATES.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_PRESENCES.bits()
                                == GatewayIntents::GUILD_PRESENCES.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_PRESENCES.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_MESSAGES.bits()
                                == GatewayIntents::GUILD_MESSAGES.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_MESSAGES.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_MESSAGE_REACTIONS.bits()
                                == GatewayIntents::GUILD_MESSAGE_REACTIONS.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_MESSAGE_REACTIONS.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_MESSAGE_TYPING.bits()
                                == GatewayIntents::GUILD_MESSAGE_TYPING.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_MESSAGE_TYPING.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::DIRECT_MESSAGES.bits()
                                == GatewayIntents::DIRECT_MESSAGES.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::DIRECT_MESSAGES.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::DIRECT_MESSAGE_REACTIONS.bits()
                                == GatewayIntents::DIRECT_MESSAGE_REACTIONS.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::DIRECT_MESSAGE_REACTIONS.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::DIRECT_MESSAGE_TYPING.bits()
                                == GatewayIntents::DIRECT_MESSAGE_TYPING.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::DIRECT_MESSAGE_TYPING.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::MESSAGE_CONTENT.bits()
                                == GatewayIntents::MESSAGE_CONTENT.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::MESSAGE_CONTENT.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::GUILD_SCHEDULED_EVENTS.bits()
                                == GatewayIntents::GUILD_SCHEDULED_EVENTS.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::GUILD_SCHEDULED_EVENTS.bits();
                            }
                        };
                        {
                            if bits
                                & GatewayIntents::AUTO_MODERATION_CONFIGURATION.bits()
                                == GatewayIntents::AUTO_MODERATION_CONFIGURATION.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::AUTO_MODERATION_CONFIGURATION.bits();
                            }
                        };
                        {
                            if bits & GatewayIntents::AUTO_MODERATION_EXECUTION.bits()
                                == GatewayIntents::AUTO_MODERATION_EXECUTION.bits()
                            {
                                truncated = truncated
                                    | GatewayIntents::AUTO_MODERATION_EXECUTION.bits();
                            }
                        };
                        Self(truncated)
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                #[inline]
                pub const fn from_bits_retain(bits: u64) -> Self {
                    let bits = bits;
                    { Self(bits) }
                }
                /// Get the value for a flag from its stringified name.
                ///
                /// Names are _case-sensitive_, so must correspond exactly to
                /// the identifier given to the flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        {
                            if name == "GUILDS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILDS.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_MEMBERS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_MEMBERS.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_MODERATION" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_MODERATION.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_EMOJIS_AND_STICKERS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_EMOJIS_AND_STICKERS.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_INTEGRATIONS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_INTEGRATIONS.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_WEBHOOKS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_WEBHOOKS.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_INVITES" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_INVITES.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_VOICE_STATES" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_VOICE_STATES.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_PRESENCES" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_PRESENCES.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_MESSAGES" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_MESSAGES.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_MESSAGE_REACTIONS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_MESSAGE_REACTIONS.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_MESSAGE_TYPING" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_MESSAGE_TYPING.bits()),
                                );
                            }
                        };
                        {
                            if name == "DIRECT_MESSAGES" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::DIRECT_MESSAGES.bits()),
                                );
                            }
                        };
                        {
                            if name == "DIRECT_MESSAGE_REACTIONS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::DIRECT_MESSAGE_REACTIONS.bits()),
                                );
                            }
                        };
                        {
                            if name == "DIRECT_MESSAGE_TYPING" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::DIRECT_MESSAGE_TYPING.bits()),
                                );
                            }
                        };
                        {
                            if name == "MESSAGE_CONTENT" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::MESSAGE_CONTENT.bits()),
                                );
                            }
                        };
                        {
                            if name == "GUILD_SCHEDULED_EVENTS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::GUILD_SCHEDULED_EVENTS.bits()),
                                );
                            }
                        };
                        {
                            if name == "AUTO_MODERATION_CONFIGURATION" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::AUTO_MODERATION_CONFIGURATION.bits()),
                                );
                            }
                        };
                        {
                            if name == "AUTO_MODERATION_EXECUTION" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(GatewayIntents::AUTO_MODERATION_EXECUTION.bits()),
                                );
                            }
                        };
                        let _ = name;
                        ::bitflags::__private::core::option::Option::None
                    }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.0 == Self::empty().0 }
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { Self::all().0 | f.0 == f.0 }
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { !(Self(f.0 & other.0)).is_empty() }
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { (f.0 & other.0) == other.0 }
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        f.0 = f.0 | other.0;
                    }
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        f.0 = f.0 & !other.0;
                    }
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        f.0 = f.0 ^ other.0;
                    }
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    {
                        if value {
                            f.insert(other);
                        } else {
                            f.remove(other);
                        }
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 & other.0) }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 | other.0) }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 & !other.0) }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 ^ other.0) }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self::from_bits_truncate(!f.0) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Binary::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Octal::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: InternalBitFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.0 = self.0 | other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for InternalBitFlags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.0 = self.0 ^ other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for InternalBitFlags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.0 = self.0 & other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.0 = self.0 & !other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
            for InternalBitFlags {
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
            for InternalBitFlags {
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl InternalBitFlags {
                /// Iterate over enabled flag values.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<GatewayIntents> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <GatewayIntents as ::bitflags::Flags>::FLAGS,
                        GatewayIntents::from_bits_retain(self.bits()),
                        GatewayIntents::from_bits_retain(self.bits()),
                    )
                }
                /// Iterate over enabled flag values with their stringified names.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<GatewayIntents> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <GatewayIntents as ::bitflags::Flags>::FLAGS,
                        GatewayIntents::from_bits_retain(self.bits()),
                        GatewayIntents::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for InternalBitFlags {
                type Item = GatewayIntents;
                type IntoIter = ::bitflags::iter::Iter<GatewayIntents>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
            impl InternalBitFlags {
                /// Returns a mutable reference to the raw value of the flags currently stored.
                #[inline]
                pub fn bits_mut(&mut self) -> &mut u64 {
                    &mut self.0
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl GatewayIntents {
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(InternalBitFlags::empty()) }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    { Self(InternalBitFlags::all()) }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u64 {
                    let f = self;
                    { f.0.bits() }
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u64,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        match InternalBitFlags::from_bits(bits) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u64) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_truncate(bits)) }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                #[inline]
                pub const fn from_bits_retain(bits: u64) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_retain(bits)) }
                }
                /// Get the value for a flag from its stringified name.
                ///
                /// Names are _case-sensitive_, so must correspond exactly to
                /// the identifier given to the flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        match InternalBitFlags::from_name(name) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.0.is_empty() }
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { f.0.is_all() }
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.intersects(other.0) }
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.contains(other.0) }
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.insert(other.0) }
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.remove(other.0) }
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.toggle(other.0) }
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    { f.0.set(other.0, value) }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.intersection(other.0)) }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.union(other.0)) }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.difference(other.0)) }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.symmetric_difference(other.0)) }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self(f.0.complement()) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for GatewayIntents {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Binary::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for GatewayIntents {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Octal::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for GatewayIntents {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for GatewayIntents {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for GatewayIntents {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: GatewayIntents) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for GatewayIntents {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.0 = self.0 | other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for GatewayIntents {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for GatewayIntents {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.0 = self.0 ^ other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for GatewayIntents {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for GatewayIntents {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.0 = self.0 & other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Sub for GatewayIntents {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for GatewayIntents {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.0 = self.0 & !other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Not for GatewayIntents {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<GatewayIntents>
            for GatewayIntents {
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<GatewayIntents>
            for GatewayIntents {
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl GatewayIntents {
                /// Iterate over enabled flag values.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<GatewayIntents> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <GatewayIntents as ::bitflags::Flags>::FLAGS,
                        GatewayIntents::from_bits_retain(self.bits()),
                        GatewayIntents::from_bits_retain(self.bits()),
                    )
                }
                /// Iterate over enabled flag values with their stringified names.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<GatewayIntents> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <GatewayIntents as ::bitflags::Flags>::FLAGS,
                        GatewayIntents::from_bits_retain(self.bits()),
                        GatewayIntents::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for GatewayIntents {
                type Item = GatewayIntents;
                type IntoIter = ::bitflags::iter::Iter<GatewayIntents>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
        };
        impl<'de> ::serde::Deserialize<'de> for GatewayIntents {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                <u64>::deserialize(deserializer).map(Self::from_bits_truncate)
            }
        }
        impl ::serde::Serialize for GatewayIntents {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                self.bits().serialize(serializer)
            }
        }
        impl GatewayIntents {
            pub const PRIVILEGED: Self = Self::from_bits_truncate(
                Self::GUILD_PRESENCES.bits() | Self::GUILD_MEMBERS.bits()
                    | Self::MESSAGE_CONTENT.bits(),
            );
            pub const fn is_privileged(&self) -> bool {
                self.intersects(Self::PRIVILEGED)
            }
        }
    }
    mod opcode {
        use crate::internal::macros::enum_repr;
        #[non_exhaustive]
        pub enum GatewayOpcode {
            Dispatch = 0,
            Heartbeat = 1,
            Identify = 2,
            PresenceUpdate = 3,
            VoiceStateUpdate = 4,
            Resume = 6,
            Reconnect = 7,
            RequestGuildMembers = 8,
            InvalidSession = 9,
            Hello = 10,
            HeartbeatAck = 11,
            Unknown = !0,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for GatewayOpcode {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        GatewayOpcode::Dispatch => "Dispatch",
                        GatewayOpcode::Heartbeat => "Heartbeat",
                        GatewayOpcode::Identify => "Identify",
                        GatewayOpcode::PresenceUpdate => "PresenceUpdate",
                        GatewayOpcode::VoiceStateUpdate => "VoiceStateUpdate",
                        GatewayOpcode::Resume => "Resume",
                        GatewayOpcode::Reconnect => "Reconnect",
                        GatewayOpcode::RequestGuildMembers => "RequestGuildMembers",
                        GatewayOpcode::InvalidSession => "InvalidSession",
                        GatewayOpcode::Hello => "Hello",
                        GatewayOpcode::HeartbeatAck => "HeartbeatAck",
                        GatewayOpcode::Unknown => "Unknown",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GatewayOpcode {
            #[inline]
            fn clone(&self) -> GatewayOpcode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for GatewayOpcode {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for GatewayOpcode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for GatewayOpcode {
            #[inline]
            fn eq(&self, other: &GatewayOpcode) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for GatewayOpcode {}
        #[automatically_derived]
        impl ::core::cmp::Eq for GatewayOpcode {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for GatewayOpcode {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl GatewayOpcode {
            #[doc(hidden)]
            fn __internal_enum_repr(value: u64) -> Option<Self> {
                match value {
                    _ if value == GatewayOpcode::Dispatch.value() => Some(Self::Dispatch),
                    _ if value == GatewayOpcode::Heartbeat.value() => {
                        Some(Self::Heartbeat)
                    }
                    _ if value == GatewayOpcode::Identify.value() => Some(Self::Identify),
                    _ if value == GatewayOpcode::PresenceUpdate.value() => {
                        Some(Self::PresenceUpdate)
                    }
                    _ if value == GatewayOpcode::VoiceStateUpdate.value() => {
                        Some(Self::VoiceStateUpdate)
                    }
                    _ if value == GatewayOpcode::Resume.value() => Some(Self::Resume),
                    _ if value == GatewayOpcode::Reconnect.value() => {
                        Some(Self::Reconnect)
                    }
                    _ if value == GatewayOpcode::RequestGuildMembers.value() => {
                        Some(Self::RequestGuildMembers)
                    }
                    _ if value == GatewayOpcode::InvalidSession.value() => {
                        Some(Self::InvalidSession)
                    }
                    _ if value == GatewayOpcode::Hello.value() => Some(Self::Hello),
                    _ if value == GatewayOpcode::HeartbeatAck.value() => {
                        Some(Self::HeartbeatAck)
                    }
                    _ => Some(Self::Unknown),
                }
            }
        }
        impl GatewayOpcode {
            pub const fn value(&self) -> u64 {
                *self as u64
            }
        }
        impl<'de> serde::Deserialize<'de> for GatewayOpcode {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = GatewayOpcode;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("GatewayOpcode type (integer)")
                    }
                    fn visit_u64<E>(self, value: u64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        GatewayOpcode::__internal_enum_repr(value)
                            .ok_or_else(|| {
                                serde::de::Error::custom({
                                    let res = ::alloc::fmt::format(
                                        format_args!("unknown GatewayOpcode variant: {0}", value),
                                    );
                                    res
                                })
                            })
                    }
                }
                deserializer.deserialize_u64(Visitor)
            }
        }
        impl serde::Serialize for GatewayOpcode {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                serializer.serialize_u64(self.value())
            }
        }
    }
    pub use event::*;
    pub use id::*;
    pub use intents::*;
    pub use opcode::*;
}
pub mod guild {
    mod member {
        use crate::{
            id::RoleId, misc::{ImageHash, Permissions, Timestamp},
            user::User,
        };
        use serde::{Deserialize, Serialize};
        pub struct GuildMember {
            #[serde(skip_serializing_if = "Option::is_none")]
            pub user: Option<User>,
            #[serde(rename = "nickname")]
            pub nick: Option<String>,
            pub avatar: Option<ImageHash>,
            pub roles: Vec<RoleId>,
            pub joined_at: Timestamp,
            #[serde(skip_serializing_if = "Option::is_none")]
            #[serde(rename = "premium_since")]
            pub boosted_at: Option<Timestamp>,
            #[serde(rename = "deaf")]
            pub deafen: bool,
            #[serde(rename = "mute")]
            pub muted: bool,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub pending: Option<bool>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub permissions: Option<Permissions>,
            pub timed_out_until: Option<Timestamp>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for GuildMember {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "user",
                    "nick",
                    "avatar",
                    "roles",
                    "joined_at",
                    "boosted_at",
                    "deafen",
                    "muted",
                    "pending",
                    "permissions",
                    "timed_out_until",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.user,
                    &self.nick,
                    &self.avatar,
                    &self.roles,
                    &self.joined_at,
                    &self.boosted_at,
                    &self.deafen,
                    &self.muted,
                    &self.pending,
                    &self.permissions,
                    &&self.timed_out_until,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "GuildMember",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GuildMember {
            #[inline]
            fn clone(&self) -> GuildMember {
                GuildMember {
                    user: ::core::clone::Clone::clone(&self.user),
                    nick: ::core::clone::Clone::clone(&self.nick),
                    avatar: ::core::clone::Clone::clone(&self.avatar),
                    roles: ::core::clone::Clone::clone(&self.roles),
                    joined_at: ::core::clone::Clone::clone(&self.joined_at),
                    boosted_at: ::core::clone::Clone::clone(&self.boosted_at),
                    deafen: ::core::clone::Clone::clone(&self.deafen),
                    muted: ::core::clone::Clone::clone(&self.muted),
                    pending: ::core::clone::Clone::clone(&self.pending),
                    permissions: ::core::clone::Clone::clone(&self.permissions),
                    timed_out_until: ::core::clone::Clone::clone(&self.timed_out_until),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for GuildMember {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for GuildMember {
            #[inline]
            fn eq(&self, other: &GuildMember) -> bool {
                self.user == other.user && self.nick == other.nick
                    && self.avatar == other.avatar && self.roles == other.roles
                    && self.joined_at == other.joined_at
                    && self.boosted_at == other.boosted_at && self.deafen == other.deafen
                    && self.muted == other.muted && self.pending == other.pending
                    && self.permissions == other.permissions
                    && self.timed_out_until == other.timed_out_until
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for GuildMember {}
        #[automatically_derived]
        impl ::core::cmp::Eq for GuildMember {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Option<User>>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Option<ImageHash>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<RoleId>>;
                let _: ::core::cmp::AssertParamIsEq<Timestamp>;
                let _: ::core::cmp::AssertParamIsEq<Option<Timestamp>>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
                let _: ::core::cmp::AssertParamIsEq<Option<Permissions>>;
                let _: ::core::cmp::AssertParamIsEq<Option<Timestamp>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for GuildMember {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.user, state);
                ::core::hash::Hash::hash(&self.nick, state);
                ::core::hash::Hash::hash(&self.avatar, state);
                ::core::hash::Hash::hash(&self.roles, state);
                ::core::hash::Hash::hash(&self.joined_at, state);
                ::core::hash::Hash::hash(&self.boosted_at, state);
                ::core::hash::Hash::hash(&self.deafen, state);
                ::core::hash::Hash::hash(&self.muted, state);
                ::core::hash::Hash::hash(&self.pending, state);
                ::core::hash::Hash::hash(&self.permissions, state);
                ::core::hash::Hash::hash(&self.timed_out_until, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GuildMember {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "user" => _serde::__private::Ok(__Field::__field0),
                                "nickname" => _serde::__private::Ok(__Field::__field1),
                                "avatar" => _serde::__private::Ok(__Field::__field2),
                                "roles" => _serde::__private::Ok(__Field::__field3),
                                "joined_at" => _serde::__private::Ok(__Field::__field4),
                                "premium_since" => _serde::__private::Ok(__Field::__field5),
                                "deaf" => _serde::__private::Ok(__Field::__field6),
                                "mute" => _serde::__private::Ok(__Field::__field7),
                                "pending" => _serde::__private::Ok(__Field::__field8),
                                "permissions" => _serde::__private::Ok(__Field::__field9),
                                "timed_out_until" => {
                                    _serde::__private::Ok(__Field::__field10)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"user" => _serde::__private::Ok(__Field::__field0),
                                b"nickname" => _serde::__private::Ok(__Field::__field1),
                                b"avatar" => _serde::__private::Ok(__Field::__field2),
                                b"roles" => _serde::__private::Ok(__Field::__field3),
                                b"joined_at" => _serde::__private::Ok(__Field::__field4),
                                b"premium_since" => _serde::__private::Ok(__Field::__field5),
                                b"deaf" => _serde::__private::Ok(__Field::__field6),
                                b"mute" => _serde::__private::Ok(__Field::__field7),
                                b"pending" => _serde::__private::Ok(__Field::__field8),
                                b"permissions" => _serde::__private::Ok(__Field::__field9),
                                b"timed_out_until" => {
                                    _serde::__private::Ok(__Field::__field10)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GuildMember>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GuildMember;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GuildMember",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<User>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GuildMember with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct GuildMember with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<ImageHash>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct GuildMember with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Vec<RoleId>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct GuildMember with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Timestamp,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct GuildMember with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                Option<Timestamp>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct GuildMember with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct GuildMember with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct GuildMember with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match match _serde::de::SeqAccess::next_element::<
                                Option<bool>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct GuildMember with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field9 = match match _serde::de::SeqAccess::next_element::<
                                Option<Permissions>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct GuildMember with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field10 = match match _serde::de::SeqAccess::next_element::<
                                Option<Timestamp>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct GuildMember with 11 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GuildMember {
                                user: __field0,
                                nick: __field1,
                                avatar: __field2,
                                roles: __field3,
                                joined_at: __field4,
                                boosted_at: __field5,
                                deafen: __field6,
                                muted: __field7,
                                pending: __field8,
                                permissions: __field9,
                                timed_out_until: __field10,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Option<User>> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<ImageHash>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Vec<RoleId>> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Timestamp> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<
                                Option<Timestamp>,
                            > = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                            let mut __field9: _serde::__private::Option<
                                Option<Permissions>,
                            > = _serde::__private::None;
                            let mut __field10: _serde::__private::Option<
                                Option<Timestamp>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = match _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("user"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<User>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "nickname",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("avatar"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ImageHash>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("roles"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Vec<RoleId>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "joined_at",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Timestamp,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "premium_since",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<Timestamp>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("deaf"),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                bool,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("mute"),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                bool,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "pending",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<bool>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::__private::Option::is_some(&__field9) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "permissions",
                                                ),
                                            );
                                        }
                                        __field9 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<Permissions>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field10 => {
                                        if _serde::__private::Option::is_some(&__field10) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "timed_out_until",
                                                ),
                                            );
                                        }
                                        __field10 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<Timestamp>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("user") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("nickname") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("avatar") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("roles") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("joined_at") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "premium_since",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("deaf") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("mute") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("pending") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::__private::Some(__field9) => __field9,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("permissions") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field10 = match __field10 {
                                _serde::__private::Some(__field10) => __field10,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "timed_out_until",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(GuildMember {
                                user: __field0,
                                nick: __field1,
                                avatar: __field2,
                                roles: __field3,
                                joined_at: __field4,
                                boosted_at: __field5,
                                deafen: __field6,
                                muted: __field7,
                                pending: __field8,
                                permissions: __field9,
                                timed_out_until: __field10,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "user",
                        "nickname",
                        "avatar",
                        "roles",
                        "joined_at",
                        "premium_since",
                        "deaf",
                        "mute",
                        "pending",
                        "permissions",
                        "timed_out_until",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GuildMember",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GuildMember>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GuildMember {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "GuildMember",
                        false as usize + if Option::is_none(&self.user) { 0 } else { 1 }
                            + 1 + 1 + 1 + 1
                            + if Option::is_none(&self.boosted_at) { 0 } else { 1 } + 1
                            + 1 + if Option::is_none(&self.pending) { 0 } else { 1 }
                            + if Option::is_none(&self.permissions) { 0 } else { 1 } + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.user) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "user",
                            &self.user,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "user",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "nickname",
                        &self.nick,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "avatar",
                        &self.avatar,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "roles",
                        &self.roles,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "joined_at",
                        &self.joined_at,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.boosted_at) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "premium_since",
                            &self.boosted_at,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "premium_since",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "deaf",
                        &self.deafen,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "mute",
                        &self.muted,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.pending) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "pending",
                            &self.pending,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "pending",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.permissions) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "permissions",
                            &self.permissions,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "permissions",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "timed_out_until",
                        &self.timed_out_until,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    }
    pub use member::*;
}
pub mod id {
    use crate::misc::Timestamp;
    use serde::{Deserialize, Serialize};
    #[serde(transparent)]
    pub struct AttachmentId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for AttachmentId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "AttachmentId",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AttachmentId {
        #[inline]
        fn clone(&self) -> AttachmentId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for AttachmentId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AttachmentId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AttachmentId {
        #[inline]
        fn eq(&self, other: &AttachmentId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for AttachmentId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for AttachmentId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for AttachmentId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttachmentId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for AttachmentId {
        #[inline]
        fn cmp(&self, other: &AttachmentId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for AttachmentId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AttachmentId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| AttachmentId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AttachmentId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl AttachmentId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a AttachmentId> for AttachmentId {
        fn from(value: &'a AttachmentId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for AttachmentId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for AttachmentId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<AttachmentId> for u64 {
        fn from(value: AttachmentId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct ChannelId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for ChannelId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "ChannelId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ChannelId {
        #[inline]
        fn clone(&self) -> ChannelId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ChannelId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ChannelId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ChannelId {
        #[inline]
        fn eq(&self, other: &ChannelId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ChannelId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ChannelId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ChannelId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ChannelId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ChannelId {
        #[inline]
        fn cmp(&self, other: &ChannelId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ChannelId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ChannelId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| ChannelId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ChannelId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl ChannelId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a ChannelId> for ChannelId {
        fn from(value: &'a ChannelId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for ChannelId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for ChannelId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<ChannelId> for u64 {
        fn from(value: ChannelId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct ForumTagId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for ForumTagId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "ForumTagId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ForumTagId {
        #[inline]
        fn clone(&self) -> ForumTagId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ForumTagId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ForumTagId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ForumTagId {
        #[inline]
        fn eq(&self, other: &ForumTagId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ForumTagId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ForumTagId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ForumTagId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ForumTagId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ForumTagId {
        #[inline]
        fn cmp(&self, other: &ForumTagId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ForumTagId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ForumTagId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| ForumTagId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ForumTagId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl ForumTagId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a ForumTagId> for ForumTagId {
        fn from(value: &'a ForumTagId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for ForumTagId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for ForumTagId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<ForumTagId> for u64 {
        fn from(value: ForumTagId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct MessageId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for MessageId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "MessageId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MessageId {
        #[inline]
        fn clone(&self) -> MessageId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for MessageId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MessageId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MessageId {
        #[inline]
        fn eq(&self, other: &MessageId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for MessageId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for MessageId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for MessageId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MessageId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for MessageId {
        #[inline]
        fn cmp(&self, other: &MessageId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for MessageId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MessageId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| MessageId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MessageId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl MessageId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a MessageId> for MessageId {
        fn from(value: &'a MessageId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for MessageId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for MessageId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<MessageId> for u64 {
        fn from(value: MessageId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct EmojiId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for EmojiId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "EmojiId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EmojiId {
        #[inline]
        fn clone(&self) -> EmojiId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for EmojiId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EmojiId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EmojiId {
        #[inline]
        fn eq(&self, other: &EmojiId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for EmojiId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for EmojiId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for EmojiId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &EmojiId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for EmojiId {
        #[inline]
        fn cmp(&self, other: &EmojiId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for EmojiId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EmojiId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| EmojiId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EmojiId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl EmojiId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a EmojiId> for EmojiId {
        fn from(value: &'a EmojiId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for EmojiId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for EmojiId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<EmojiId> for u64 {
        fn from(value: EmojiId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct CoverStickerId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for CoverStickerId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "CoverStickerId",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CoverStickerId {
        #[inline]
        fn clone(&self) -> CoverStickerId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for CoverStickerId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CoverStickerId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CoverStickerId {
        #[inline]
        fn eq(&self, other: &CoverStickerId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for CoverStickerId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for CoverStickerId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for CoverStickerId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &CoverStickerId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for CoverStickerId {
        #[inline]
        fn cmp(&self, other: &CoverStickerId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for CoverStickerId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for CoverStickerId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| CoverStickerId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for CoverStickerId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl CoverStickerId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a CoverStickerId> for CoverStickerId {
        fn from(value: &'a CoverStickerId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for CoverStickerId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for CoverStickerId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<CoverStickerId> for u64 {
        fn from(value: CoverStickerId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct StickerId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for StickerId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "StickerId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StickerId {
        #[inline]
        fn clone(&self) -> StickerId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for StickerId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StickerId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StickerId {
        #[inline]
        fn eq(&self, other: &StickerId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for StickerId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for StickerId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for StickerId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StickerId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for StickerId {
        #[inline]
        fn cmp(&self, other: &StickerId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for StickerId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StickerId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| StickerId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StickerId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl StickerId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a StickerId> for StickerId {
        fn from(value: &'a StickerId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for StickerId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for StickerId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<StickerId> for u64 {
        fn from(value: StickerId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct StickerPackId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for StickerPackId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "StickerPackId",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StickerPackId {
        #[inline]
        fn clone(&self) -> StickerPackId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for StickerPackId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StickerPackId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StickerPackId {
        #[inline]
        fn eq(&self, other: &StickerPackId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for StickerPackId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for StickerPackId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for StickerPackId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StickerPackId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for StickerPackId {
        #[inline]
        fn cmp(&self, other: &StickerPackId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for StickerPackId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StickerPackId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| StickerPackId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StickerPackId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl StickerPackId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a StickerPackId> for StickerPackId {
        fn from(value: &'a StickerPackId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for StickerPackId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for StickerPackId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<StickerPackId> for u64 {
        fn from(value: StickerPackId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct StickerPackSkuId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for StickerPackSkuId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "StickerPackSkuId",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StickerPackSkuId {
        #[inline]
        fn clone(&self) -> StickerPackSkuId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for StickerPackSkuId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StickerPackSkuId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StickerPackSkuId {
        #[inline]
        fn eq(&self, other: &StickerPackSkuId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for StickerPackSkuId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for StickerPackSkuId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for StickerPackSkuId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StickerPackSkuId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for StickerPackSkuId {
        #[inline]
        fn cmp(&self, other: &StickerPackSkuId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for StickerPackSkuId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StickerPackSkuId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| StickerPackSkuId {
                        0: __transparent,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StickerPackSkuId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl StickerPackSkuId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a StickerPackSkuId> for StickerPackSkuId {
        fn from(value: &'a StickerPackSkuId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for StickerPackSkuId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for StickerPackSkuId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<StickerPackSkuId> for u64 {
        fn from(value: StickerPackSkuId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct StickerPackBannerAssetId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for StickerPackBannerAssetId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "StickerPackBannerAssetId",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StickerPackBannerAssetId {
        #[inline]
        fn clone(&self) -> StickerPackBannerAssetId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for StickerPackBannerAssetId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StickerPackBannerAssetId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StickerPackBannerAssetId {
        #[inline]
        fn eq(&self, other: &StickerPackBannerAssetId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for StickerPackBannerAssetId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for StickerPackBannerAssetId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for StickerPackBannerAssetId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StickerPackBannerAssetId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for StickerPackBannerAssetId {
        #[inline]
        fn cmp(&self, other: &StickerPackBannerAssetId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for StickerPackBannerAssetId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StickerPackBannerAssetId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| StickerPackBannerAssetId {
                        0: __transparent,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StickerPackBannerAssetId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl StickerPackBannerAssetId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a StickerPackBannerAssetId> for StickerPackBannerAssetId {
        fn from(value: &'a StickerPackBannerAssetId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for StickerPackBannerAssetId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for StickerPackBannerAssetId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<StickerPackBannerAssetId> for u64 {
        fn from(value: StickerPackBannerAssetId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct GuildId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for GuildId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "GuildId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for GuildId {
        #[inline]
        fn clone(&self) -> GuildId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for GuildId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for GuildId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for GuildId {
        #[inline]
        fn eq(&self, other: &GuildId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for GuildId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for GuildId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for GuildId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &GuildId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for GuildId {
        #[inline]
        fn cmp(&self, other: &GuildId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for GuildId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for GuildId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| GuildId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for GuildId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl GuildId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a GuildId> for GuildId {
        fn from(value: &'a GuildId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for GuildId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for GuildId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<GuildId> for u64 {
        fn from(value: GuildId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct RoleId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for RoleId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "RoleId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RoleId {
        #[inline]
        fn clone(&self) -> RoleId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for RoleId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RoleId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RoleId {
        #[inline]
        fn eq(&self, other: &RoleId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for RoleId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for RoleId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for RoleId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &RoleId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for RoleId {
        #[inline]
        fn cmp(&self, other: &RoleId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for RoleId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RoleId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| RoleId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RoleId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl RoleId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a RoleId> for RoleId {
        fn from(value: &'a RoleId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for RoleId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for RoleId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<RoleId> for u64 {
        fn from(value: RoleId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct IntegrationId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for IntegrationId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "IntegrationId",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for IntegrationId {
        #[inline]
        fn clone(&self) -> IntegrationId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for IntegrationId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for IntegrationId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for IntegrationId {
        #[inline]
        fn eq(&self, other: &IntegrationId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for IntegrationId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for IntegrationId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for IntegrationId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &IntegrationId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for IntegrationId {
        #[inline]
        fn cmp(&self, other: &IntegrationId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for IntegrationId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for IntegrationId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| IntegrationId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for IntegrationId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl IntegrationId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a IntegrationId> for IntegrationId {
        fn from(value: &'a IntegrationId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for IntegrationId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for IntegrationId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<IntegrationId> for u64 {
        fn from(value: IntegrationId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct RoleSubscriptionSkuId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for RoleSubscriptionSkuId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "RoleSubscriptionSkuId",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RoleSubscriptionSkuId {
        #[inline]
        fn clone(&self) -> RoleSubscriptionSkuId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for RoleSubscriptionSkuId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RoleSubscriptionSkuId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RoleSubscriptionSkuId {
        #[inline]
        fn eq(&self, other: &RoleSubscriptionSkuId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for RoleSubscriptionSkuId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for RoleSubscriptionSkuId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for RoleSubscriptionSkuId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &RoleSubscriptionSkuId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for RoleSubscriptionSkuId {
        #[inline]
        fn cmp(&self, other: &RoleSubscriptionSkuId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for RoleSubscriptionSkuId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RoleSubscriptionSkuId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| RoleSubscriptionSkuId {
                        0: __transparent,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RoleSubscriptionSkuId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl RoleSubscriptionSkuId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a RoleSubscriptionSkuId> for RoleSubscriptionSkuId {
        fn from(value: &'a RoleSubscriptionSkuId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for RoleSubscriptionSkuId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for RoleSubscriptionSkuId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<RoleSubscriptionSkuId> for u64 {
        fn from(value: RoleSubscriptionSkuId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct WebhookId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for WebhookId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "WebhookId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for WebhookId {
        #[inline]
        fn clone(&self) -> WebhookId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for WebhookId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for WebhookId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for WebhookId {
        #[inline]
        fn eq(&self, other: &WebhookId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for WebhookId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for WebhookId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for WebhookId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &WebhookId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for WebhookId {
        #[inline]
        fn cmp(&self, other: &WebhookId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for WebhookId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for WebhookId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| WebhookId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for WebhookId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl WebhookId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a WebhookId> for WebhookId {
        fn from(value: &'a WebhookId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for WebhookId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for WebhookId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<WebhookId> for u64 {
        fn from(value: WebhookId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct ApplicationId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for ApplicationId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "ApplicationId",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ApplicationId {
        #[inline]
        fn clone(&self) -> ApplicationId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ApplicationId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ApplicationId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ApplicationId {
        #[inline]
        fn eq(&self, other: &ApplicationId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ApplicationId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ApplicationId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ApplicationId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ApplicationId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ApplicationId {
        #[inline]
        fn cmp(&self, other: &ApplicationId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ApplicationId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ApplicationId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| ApplicationId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ApplicationId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl ApplicationId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a ApplicationId> for ApplicationId {
        fn from(value: &'a ApplicationId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for ApplicationId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for ApplicationId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<ApplicationId> for u64 {
        fn from(value: ApplicationId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct GameSkuId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for GameSkuId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "GameSkuId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for GameSkuId {
        #[inline]
        fn clone(&self) -> GameSkuId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for GameSkuId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for GameSkuId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for GameSkuId {
        #[inline]
        fn eq(&self, other: &GameSkuId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for GameSkuId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for GameSkuId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for GameSkuId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &GameSkuId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for GameSkuId {
        #[inline]
        fn cmp(&self, other: &GameSkuId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for GameSkuId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for GameSkuId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| GameSkuId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for GameSkuId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl GameSkuId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a GameSkuId> for GameSkuId {
        fn from(value: &'a GameSkuId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for GameSkuId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for GameSkuId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<GameSkuId> for u64 {
        fn from(value: GameSkuId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct TeamId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for TeamId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "TeamId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TeamId {
        #[inline]
        fn clone(&self) -> TeamId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TeamId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TeamId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TeamId {
        #[inline]
        fn eq(&self, other: &TeamId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TeamId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TeamId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for TeamId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TeamId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for TeamId {
        #[inline]
        fn cmp(&self, other: &TeamId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TeamId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TeamId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| TeamId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TeamId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl TeamId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a TeamId> for TeamId {
        fn from(value: &'a TeamId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for TeamId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for TeamId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<TeamId> for u64 {
        fn from(value: TeamId) -> Self {
            value.0
        }
    }
    #[serde(transparent)]
    pub struct UserId(#[serde(with = "snowflake")] pub u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for UserId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "UserId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserId {
        #[inline]
        fn clone(&self) -> UserId {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for UserId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserId {
        #[inline]
        fn eq(&self, other: &UserId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for UserId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for UserId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for UserId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UserId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for UserId {
        #[inline]
        fn cmp(&self, other: &UserId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for UserId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserId {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::map(
                    snowflake::deserialize(__deserializer),
                    |__transparent| UserId { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserId {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                snowflake::serialize(&self.0, __serializer)
            }
        }
    };
    impl UserId {
        #[inline]
        #[must_use]
        pub fn timestamp(&self) -> Timestamp {
            Timestamp::from_snowflake(self.0)
        }
        #[inline]
        #[must_use]
        #[allow(unused)]
        pub const fn get(&self) -> u64 {
            self.0
        }
    }
    impl<'a> From<&'a UserId> for UserId {
        fn from(value: &'a UserId) -> Self {
            Self(value.0)
        }
    }
    impl From<u64> for UserId {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl std::fmt::Display for UserId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl From<UserId> for u64 {
        fn from(value: UserId) -> Self {
            value.0
        }
    }
    mod snowflake {
        use serde::de::Error;
        use serde::de::Visitor as SerdeVisitor;
        use serde::Deserializer;
        use serde::Serializer;
        struct Visitor;
        impl<'de> SerdeVisitor<'de> for Visitor {
            type Value = u64;
            fn expecting(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(format_args!("discord snowflake (integer or string)"))
            }
            fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                Ok(v)
            }
            fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                if v.is_negative() {
                    Err(Error::custom("negative ids are not allowed"))
                } else {
                    self.visit_u64(v as u64)
                }
            }
            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
            where
                E: Error,
            {
                v.parse().map_err(Error::custom)
            }
        }
        pub fn deserialize<'de, D: Deserializer<'de>>(
            deserializer: D,
        ) -> Result<u64, D::Error> {
            deserializer.deserialize_any(Visitor)
        }
        pub fn serialize<S: Serializer>(
            value: &u64,
            serializer: S,
        ) -> Result<S::Ok, S::Error> {
            serializer.collect_str(value)
        }
    }
}
pub mod misc {
    mod color {
        pub struct Color(u32);
        #[automatically_derived]
        impl ::core::clone::Clone for Color {
            #[inline]
            fn clone(&self) -> Color {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Color {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Color {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Color {
            #[inline]
            fn eq(&self, other: &Color) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Color {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Color {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u32>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Color {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        const MAX_RGB_VALUE: f64 = 255.;
        const HUE_MAX_VALUE: f64 = 360.;
        impl Color {
            pub const WHITE: Self = Self(0xFFFFFF);
            pub const BLACK: Self = Self(0x000000);
            pub const LIGHT_CYAN: Self = Self(0x1ABC9C);
            pub const DARK_CYAN: Self = Self(0x11806A);
            pub const LIGHT_GREEN: Self = Self(0x2ECC71);
            pub const DARK_GREEN: Self = Self(0x1F8B4C);
            pub const LIGHT_BLUE: Self = Self(0x3498DB);
            pub const DARK_BLUE: Self = Self(0x206694);
            pub const LIGHT_PURPLE: Self = Self(0x9B59B6);
            pub const DARK_PURPLE: Self = Self(0x71368A);
            pub const LIGHT_RED: Self = Self(0xe91e63);
            pub const DARK_RED: Self = Self(0xad1457);
            pub const LIGHT_YELLOW: Self = Self(0xf1c40f);
            pub const DARK_YELLOW: Self = Self(0xc27c0e);
            pub const LIGHT_GOLD: Self = Self(0xe67e22);
            pub const DARK_GOLD: Self = Self(0xa84300);
            pub const LIGHT_ORANGE: Self = Self(0xe74c3c);
            pub const DARK_ORANGE: Self = Self(0x992d22);
            pub const LIGHT_GRAY: Self = Self(0x95a5a6);
            pub const DARK_GRAY: Self = Self(0x979c9f);
        }
        impl Color {
            #[must_use]
            pub const fn code(&self) -> u32 {
                self.0
            }
            #[must_use]
            pub fn hsl(&self) -> (f64, f64, f64) {
                let (r, g, b) = self.rgb();
                let red = r as f64 / MAX_RGB_VALUE;
                let green = g as f64 / MAX_RGB_VALUE;
                let blue = b as f64 / MAX_RGB_VALUE;
                let max = if red > green && red > blue {
                    red
                } else if green > blue {
                    green
                } else {
                    blue
                };
                let min = if red < green && red < blue {
                    red
                } else if green < blue {
                    green
                } else {
                    blue
                };
                let mut hue = 0.;
                let mut saturation = 0.;
                let lightness = (max + min) / 2.;
                if max != min {
                    let d = max - min;
                    saturation = if lightness > 0.5 {
                        d / (2. - max - min)
                    } else {
                        d / (max + min)
                    };
                    hue = match max {
                        c if c == red => (green - blue) / d + if g < b { 6. } else { 0. },
                        c if c == green => (blue - red) / d + 2.,
                        c if c == blue => (red - green) / d + 4.,
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    } / 6.;
                }
                (hue * HUE_MAX_VALUE, saturation, lightness)
            }
            #[must_use]
            pub const fn rgb(&self) -> (u8, u8, u8) {
                (self.red(), self.green(), self.blue())
            }
        }
        impl Color {
            #[must_use]
            pub const fn red(&self) -> u8 {
                (self.0 >> 16) as u8
            }
            #[must_use]
            pub const fn green(&self) -> u8 {
                (self.0 >> 8) as u8
            }
            #[must_use]
            pub const fn blue(&self) -> u8 {
                self.0 as u8
            }
        }
        impl Color {
            #[must_use]
            pub const fn from_code(code: u32) -> Self {
                Self(code & Self::WHITE.0)
            }
            #[must_use]
            pub const fn from_rgb(r: u8, g: u8, b: u8) -> Self {
                Self(((r as u32) << 16) | ((g as u32) << 8) | b as u32)
            }
        }
        impl std::fmt::Debug for Color {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(
                    format_args!(
                        "Color({0}, {1}, {2})", self.red(), self.green(), self.blue()
                    ),
                )
            }
        }
        impl std::fmt::Display for Color {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(format_args!("0x{0:0>6x}", self.0))
            }
        }
        impl<'de> serde::Deserialize<'de> for Color {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Color;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_fmt(format_args!("integer color code"))
                    }
                    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Ok(Color::from_code(v as u32))
                    }
                }
                deserializer.deserialize_u64(Visitor)
            }
        }
        impl serde::Serialize for Color {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                self.0.serialize(serializer)
            }
        }
        impl PartialEq<u32> for Color {
            fn eq(&self, other: &u32) -> bool {
                self.0.eq(other)
            }
        }
    }
    mod image_hash {
        use serde::{Deserialize, Serialize};
        use thiserror::Error;
        mod nibbles {
            use super::{ImageHash, BITS_IN_HALF_BYTE, HASH_LEN};
            #[must_use]
            pub struct ImageHashNibbles {
                index: usize,
                inner: ImageHash,
            }
            impl ImageHashNibbles {
                pub const fn new(hash: ImageHash) -> Self {
                    Self { index: 0, inner: hash }
                }
            }
            impl From<ImageHash> for ImageHashNibbles {
                fn from(value: ImageHash) -> Self {
                    Self::new(value)
                }
            }
            impl ImageHashNibbles {
                #[inline]
                const fn get_nibble(&self, nth: usize) -> Option<u8> {
                    if nth >= HASH_LEN {
                        return None;
                    }
                    let use_left = nth % 2 == 0;
                    let value = self.inner.bytes[nth / 2];
                    const RIGHT_MASK: u8 = (1 << BITS_IN_HALF_BYTE) - 1;
                    let value = if use_left {
                        value >> BITS_IN_HALF_BYTE
                    } else {
                        value & RIGHT_MASK
                    };
                    if value >= 10 {
                        Some((b'a' - 10) + value)
                    } else {
                        Some(b'0' + value)
                    }
                }
            }
            impl ExactSizeIterator for ImageHashNibbles {
                fn len(&self) -> usize {
                    HASH_LEN
                }
            }
            impl Iterator for ImageHashNibbles {
                type Item = u8;
                fn next(&mut self) -> Option<Self::Item> {
                    let result = self.get_nibble(self.index);
                    if result.is_some() {
                        self.index += 1;
                    }
                    result
                }
                fn nth(&mut self, n: usize) -> Option<Self::Item> {
                    if n >= HASH_LEN {
                        self.index = HASH_LEN;
                        return None;
                    }
                    self.index = n;
                    self.get_nibble(n)
                }
                fn size_hint(&self) -> (usize, Option<usize>) {
                    (HASH_LEN, Some(HASH_LEN))
                }
            }
        }
        pub use nibbles::*;
        const ANIMATED_HEADER: &str = "a_";
        const HASH_LEN: usize = 32;
        const HALF_HASH_LEN: usize = HASH_LEN / 2;
        const BITS_IN_HALF_BYTE: usize = 4;
        pub struct ImageHash {
            animated: bool,
            bytes: [u8; HALF_HASH_LEN],
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ImageHash {
            #[inline]
            fn clone(&self) -> ImageHash {
                let _: ::core::clone::AssertParamIsClone<bool>;
                let _: ::core::clone::AssertParamIsClone<[u8; HALF_HASH_LEN]>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ImageHash {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ImageHash {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ImageHash {
            #[inline]
            fn eq(&self, other: &ImageHash) -> bool {
                self.animated == other.animated && self.bytes == other.bytes
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for ImageHash {}
        #[automatically_derived]
        impl ::core::cmp::Eq for ImageHash {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<[u8; HALF_HASH_LEN]>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ImageHash {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.animated, state);
                ::core::hash::Hash::hash(&self.bytes, state)
            }
        }
        pub enum ImageHashError {
            #[error("invalid hash size, expected {HASH_LEN}")]
            InputSize,
            #[error("invalid hash format")]
            Format,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ImageHashError {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ImageHashError::InputSize => "InputSize",
                        ImageHashError::Format => "Format",
                    },
                )
            }
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for ImageHashError {}
        #[allow(unused_qualifications)]
        impl std::fmt::Display for ImageHashError {
            fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    ImageHashError::InputSize {} => {
                        __formatter
                            .write_fmt(
                                format_args!("invalid hash size, expected {0}", HASH_LEN),
                            )
                    }
                    ImageHashError::Format {} => {
                        __formatter.write_fmt(format_args!("invalid hash format"))
                    }
                }
            }
        }
        impl ImageHash {
            #[must_use]
            pub const fn bytes(&self) -> &[u8] {
                &self.bytes
            }
            #[must_use]
            pub const fn animated(&self) -> bool {
                self.animated
            }
            pub const fn nibbles(&self) -> ImageHashNibbles {
                ImageHashNibbles::new(*self)
            }
        }
        impl ImageHash {
            pub fn parse<T: AsRef<[u8]>>(bytes: T) -> Result<Self, ImageHashError> {
                let bytes = bytes.as_ref();
                let animated = bytes.starts_with(ANIMATED_HEADER.as_bytes());
                let bytes = parse_inner(
                    if animated { &bytes[ANIMATED_HEADER.len()..] } else { bytes },
                )?;
                Ok(Self { animated, bytes })
            }
        }
        impl std::fmt::Display for ImageHash {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                if self.animated {
                    f.write_str(ANIMATED_HEADER)?;
                }
                for nibble in self.nibbles() {
                    f.write_fmt(format_args!("{0}", nibble as char))?;
                }
                Ok(())
            }
        }
        impl std::fmt::Debug for ImageHash {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(
                    format_args!("ImageHash(animated = {0}, bytes = ", self.animated),
                )?;
                for nibble in self.nibbles() {
                    f.write_fmt(format_args!("{0}", nibble as char))?;
                }
                f.write_fmt(format_args!(")"))
            }
        }
        impl std::str::FromStr for ImageHash {
            type Err = ImageHashError;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                Self::parse(s)
            }
        }
        impl TryFrom<&[u8]> for ImageHash {
            type Error = ImageHashError;
            fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                Self::parse(value)
            }
        }
        impl TryFrom<&str> for ImageHash {
            type Error = ImageHashError;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                Self::parse(value)
            }
        }
        impl<'de> Deserialize<'de> for ImageHash {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ImageHash;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("image hash")
                    }
                    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        ImageHash::parse(v).map_err(serde::de::Error::custom)
                    }
                }
                deserializer.deserialize_str(Visitor)
            }
        }
        impl Serialize for ImageHash {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                serializer.collect_str(self)
            }
        }
        const fn parse_hex_byte(byte: u8) -> Option<u8> {
            match byte {
                b'0'..=b'9' => Some(byte - b'0'),
                b'a'..=b'f' => Some(byte - (b'a' - 10)),
                _ => None,
            }
        }
        fn parse_inner(raw: &[u8]) -> Result<[u8; 16], ImageHashError> {
            let mut bytes = [0u8; HALF_HASH_LEN];
            for (i, chunk) in raw.chunks(2).enumerate() {
                if !(chunk.len() == 2) {
                    ::core::panicking::panic("assertion failed: chunk.len() == 2")
                }
                let left = parse_hex_byte(chunk[0]).ok_or(ImageHashError::Format)?;
                let right = parse_hex_byte(chunk[1]).ok_or(ImageHashError::Format)?;
                bytes[i] = (left << BITS_IN_HALF_BYTE) | right;
            }
            Ok(bytes)
        }
    }
    mod locale {
        use crate::internal::macros::enum_string;
        #[non_exhaustive]
        pub enum Locale {
            Indonesian,
            Danish,
            German,
            EnglishGB,
            #[default]
            EnglishUS,
            Spanish,
            French,
            Croatian,
            Italian,
            Lithuanian,
            Hungarian,
            Dutch,
            Norwegian,
            Polish,
            PortugueseBR,
            Romania,
            Finnish,
            Swedish,
            Vietnamese,
            Turkish,
            Czech,
            Greek,
            Bulgarian,
            Russian,
            Ukrainian,
            Hindi,
            Thai,
            ChineseCH,
            Japanese,
            ChineseTW,
            Korean,
            Unknown(String),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Locale {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Locale::Indonesian => {
                        ::core::fmt::Formatter::write_str(f, "Indonesian")
                    }
                    Locale::Danish => ::core::fmt::Formatter::write_str(f, "Danish"),
                    Locale::German => ::core::fmt::Formatter::write_str(f, "German"),
                    Locale::EnglishGB => {
                        ::core::fmt::Formatter::write_str(f, "EnglishGB")
                    }
                    Locale::EnglishUS => {
                        ::core::fmt::Formatter::write_str(f, "EnglishUS")
                    }
                    Locale::Spanish => ::core::fmt::Formatter::write_str(f, "Spanish"),
                    Locale::French => ::core::fmt::Formatter::write_str(f, "French"),
                    Locale::Croatian => ::core::fmt::Formatter::write_str(f, "Croatian"),
                    Locale::Italian => ::core::fmt::Formatter::write_str(f, "Italian"),
                    Locale::Lithuanian => {
                        ::core::fmt::Formatter::write_str(f, "Lithuanian")
                    }
                    Locale::Hungarian => {
                        ::core::fmt::Formatter::write_str(f, "Hungarian")
                    }
                    Locale::Dutch => ::core::fmt::Formatter::write_str(f, "Dutch"),
                    Locale::Norwegian => {
                        ::core::fmt::Formatter::write_str(f, "Norwegian")
                    }
                    Locale::Polish => ::core::fmt::Formatter::write_str(f, "Polish"),
                    Locale::PortugueseBR => {
                        ::core::fmt::Formatter::write_str(f, "PortugueseBR")
                    }
                    Locale::Romania => ::core::fmt::Formatter::write_str(f, "Romania"),
                    Locale::Finnish => ::core::fmt::Formatter::write_str(f, "Finnish"),
                    Locale::Swedish => ::core::fmt::Formatter::write_str(f, "Swedish"),
                    Locale::Vietnamese => {
                        ::core::fmt::Formatter::write_str(f, "Vietnamese")
                    }
                    Locale::Turkish => ::core::fmt::Formatter::write_str(f, "Turkish"),
                    Locale::Czech => ::core::fmt::Formatter::write_str(f, "Czech"),
                    Locale::Greek => ::core::fmt::Formatter::write_str(f, "Greek"),
                    Locale::Bulgarian => {
                        ::core::fmt::Formatter::write_str(f, "Bulgarian")
                    }
                    Locale::Russian => ::core::fmt::Formatter::write_str(f, "Russian"),
                    Locale::Ukrainian => {
                        ::core::fmt::Formatter::write_str(f, "Ukrainian")
                    }
                    Locale::Hindi => ::core::fmt::Formatter::write_str(f, "Hindi"),
                    Locale::Thai => ::core::fmt::Formatter::write_str(f, "Thai"),
                    Locale::ChineseCH => {
                        ::core::fmt::Formatter::write_str(f, "ChineseCH")
                    }
                    Locale::Japanese => ::core::fmt::Formatter::write_str(f, "Japanese"),
                    Locale::ChineseTW => {
                        ::core::fmt::Formatter::write_str(f, "ChineseTW")
                    }
                    Locale::Korean => ::core::fmt::Formatter::write_str(f, "Korean"),
                    Locale::Unknown(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Unknown",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Locale {
            #[inline]
            fn clone(&self) -> Locale {
                match self {
                    Locale::Indonesian => Locale::Indonesian,
                    Locale::Danish => Locale::Danish,
                    Locale::German => Locale::German,
                    Locale::EnglishGB => Locale::EnglishGB,
                    Locale::EnglishUS => Locale::EnglishUS,
                    Locale::Spanish => Locale::Spanish,
                    Locale::French => Locale::French,
                    Locale::Croatian => Locale::Croatian,
                    Locale::Italian => Locale::Italian,
                    Locale::Lithuanian => Locale::Lithuanian,
                    Locale::Hungarian => Locale::Hungarian,
                    Locale::Dutch => Locale::Dutch,
                    Locale::Norwegian => Locale::Norwegian,
                    Locale::Polish => Locale::Polish,
                    Locale::PortugueseBR => Locale::PortugueseBR,
                    Locale::Romania => Locale::Romania,
                    Locale::Finnish => Locale::Finnish,
                    Locale::Swedish => Locale::Swedish,
                    Locale::Vietnamese => Locale::Vietnamese,
                    Locale::Turkish => Locale::Turkish,
                    Locale::Czech => Locale::Czech,
                    Locale::Greek => Locale::Greek,
                    Locale::Bulgarian => Locale::Bulgarian,
                    Locale::Russian => Locale::Russian,
                    Locale::Ukrainian => Locale::Ukrainian,
                    Locale::Hindi => Locale::Hindi,
                    Locale::Thai => Locale::Thai,
                    Locale::ChineseCH => Locale::ChineseCH,
                    Locale::Japanese => Locale::Japanese,
                    Locale::ChineseTW => Locale::ChineseTW,
                    Locale::Korean => Locale::Korean,
                    Locale::Unknown(__self_0) => {
                        Locale::Unknown(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Locale {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Locale {
            #[inline]
            fn eq(&self, other: &Locale) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (Locale::Unknown(__self_0), Locale::Unknown(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        _ => true,
                    }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Locale {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Locale {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Locale {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state);
                match self {
                    Locale::Unknown(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    _ => {}
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Locale {
            #[inline]
            fn default() -> Locale {
                Self::EnglishUS
            }
        }
        impl Locale {
            #[doc(hidden)]
            fn __internal_enum_string(value: &str) -> Option<Self> {
                match value {
                    "id" => Some(Self::Indonesian),
                    "da" => Some(Self::Danish),
                    "de" => Some(Self::German),
                    "en-GB" => Some(Self::EnglishGB),
                    "en-US" => Some(Self::EnglishUS),
                    "es-ES" => Some(Self::Spanish),
                    "fr" => Some(Self::French),
                    "hr" => Some(Self::Croatian),
                    "it" => Some(Self::Italian),
                    "lt" => Some(Self::Lithuanian),
                    "hu" => Some(Self::Hungarian),
                    "nl" => Some(Self::Dutch),
                    "no" => Some(Self::Norwegian),
                    "pl" => Some(Self::Polish),
                    "pt-BR" => Some(Self::PortugueseBR),
                    "ro" => Some(Self::Romania),
                    "fi" => Some(Self::Finnish),
                    "sv-SE" => Some(Self::Swedish),
                    "vi" => Some(Self::Vietnamese),
                    "tr" => Some(Self::Turkish),
                    "cs" => Some(Self::Czech),
                    "el" => Some(Self::Greek),
                    "bg" => Some(Self::Bulgarian),
                    "ru" => Some(Self::Russian),
                    "uk" => Some(Self::Ukrainian),
                    "hi" => Some(Self::Hindi),
                    "th" => Some(Self::Thai),
                    "zh-CN" => Some(Self::ChineseCH),
                    "ja" => Some(Self::Japanese),
                    "zh-TW" => Some(Self::ChineseTW),
                    "ko" => Some(Self::Korean),
                    _ => Some(Self::Unknown(value.to_string())),
                }
            }
        }
        impl std::fmt::Display for Locale {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                match self {
                    Self::Indonesian => f.write_str("id"),
                    Self::Danish => f.write_str("da"),
                    Self::German => f.write_str("de"),
                    Self::EnglishGB => f.write_str("en-GB"),
                    Self::EnglishUS => f.write_str("en-US"),
                    Self::Spanish => f.write_str("es-ES"),
                    Self::French => f.write_str("fr"),
                    Self::Croatian => f.write_str("hr"),
                    Self::Italian => f.write_str("it"),
                    Self::Lithuanian => f.write_str("lt"),
                    Self::Hungarian => f.write_str("hu"),
                    Self::Dutch => f.write_str("nl"),
                    Self::Norwegian => f.write_str("no"),
                    Self::Polish => f.write_str("pl"),
                    Self::PortugueseBR => f.write_str("pt-BR"),
                    Self::Romania => f.write_str("ro"),
                    Self::Finnish => f.write_str("fi"),
                    Self::Swedish => f.write_str("sv-SE"),
                    Self::Vietnamese => f.write_str("vi"),
                    Self::Turkish => f.write_str("tr"),
                    Self::Czech => f.write_str("cs"),
                    Self::Greek => f.write_str("el"),
                    Self::Bulgarian => f.write_str("bg"),
                    Self::Russian => f.write_str("ru"),
                    Self::Ukrainian => f.write_str("uk"),
                    Self::Hindi => f.write_str("hi"),
                    Self::Thai => f.write_str("th"),
                    Self::ChineseCH => f.write_str("zh-CN"),
                    Self::Japanese => f.write_str("ja"),
                    Self::ChineseTW => f.write_str("zh-TW"),
                    Self::Korean => f.write_str("ko"),
                    Self::Unknown(n) => n.fmt(f),
                }
            }
        }
        impl<'de> serde::Deserialize<'de> for Locale {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Locale;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("Locale enum")
                    }
                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Locale::__internal_enum_string(value)
                            .ok_or_else(|| {
                                serde::de::Error::custom({
                                    let res = ::alloc::fmt::format(
                                        format_args!("unknown Locale variant: {0:?}", value),
                                    );
                                    res
                                })
                            })
                    }
                }
                deserializer.deserialize_str(Visitor)
            }
        }
        impl serde::Serialize for Locale {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                serializer.collect_str(self)
            }
        }
    }
    mod permissions {
        use bitflags::bitflags;
        /// It allows to limit and grant certain abilities
        /// to users in Discord.
        ///
        /// Read more about on how their permission system works:
        /// https://discord.com/developers/docs/topics/permissions
        pub struct Permissions(
            <Permissions as ::bitflags::__private::PublicFlags>::Internal,
        );
        #[automatically_derived]
        impl ::core::fmt::Debug for Permissions {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Permissions",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Permissions {
            #[inline]
            fn clone(&self) -> Permissions {
                let _: ::core::clone::AssertParamIsClone<
                    <Permissions as ::bitflags::__private::PublicFlags>::Internal,
                >;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Permissions {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Permissions {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Permissions {
            #[inline]
            fn eq(&self, other: &Permissions) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Permissions {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Permissions {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<
                    <Permissions as ::bitflags::__private::PublicFlags>::Internal,
                >;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Permissions {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl Permissions {
            /// Allows creation of instant invites.
            #[allow(deprecated, non_upper_case_globals)]
            pub const CREATE_INSTANT_INVITE: Self = Self::from_bits_retain(1 << 0);
            /// Allows to kick members in a guild.
            #[allow(deprecated, non_upper_case_globals)]
            pub const KICK_MEMBERS: Self = Self::from_bits_retain(1 << 1);
            /// Allows to ban members in a guild.
            #[allow(deprecated, non_upper_case_globals)]
            pub const BAN_MEMBERS: Self = Self::from_bits_retain(1 << 2);
            /// Allows all permissions and bypasses channel
            /// permission overwrites.
            #[allow(deprecated, non_upper_case_globals)]
            pub const ADMINISTRATOR: Self = Self::from_bits_retain(1 << 3);
            /// Allows management and editing of channels.
            #[allow(deprecated, non_upper_case_globals)]
            pub const MANAGE_CHANNELS: Self = Self::from_bits_retain(1 << 4);
            /// Allows management and editing of the guild.
            #[allow(deprecated, non_upper_case_globals)]
            pub const MANAGE_GUILD: Self = Self::from_bits_retain(1 << 5);
            /// Allows for the addition of reactions
            /// to messages in a guild.
            #[allow(deprecated, non_upper_case_globals)]
            pub const ADD_REACTIONS: Self = Self::from_bits_retain(1 << 6);
            /// Allows for viewing of audit logs.
            #[allow(deprecated, non_upper_case_globals)]
            pub const VIEW_AUDIT_LOG: Self = Self::from_bits_retain(1 << 7);
            /// Allows for using priority speaker in a
            /// voice channel.
            #[allow(deprecated, non_upper_case_globals)]
            pub const PRIORITY_SPEAKER: Self = Self::from_bits_retain(1 << 8);
            /// Allows the user to go live.
            #[allow(deprecated, non_upper_case_globals)]
            pub const STREAM: Self = Self::from_bits_retain(1 << 9);
            /// Allows guild members to view a channel, which
            /// it includes reading messages in text channels
            /// and joining voice channels.
            #[allow(deprecated, non_upper_case_globals)]
            pub const VIEW_CHANNEL: Self = Self::from_bits_retain(1 << 10);
            /// Allows for sending messages in a channel and
            /// creating threads in a forum (does not allow sending
            /// messages in threads).
            #[allow(deprecated, non_upper_case_globals)]
            pub const SEND_MESSAGES: Self = Self::from_bits_retain(1 << 11);
            /// Allows for sending of `/tts` messages.
            #[allow(deprecated, non_upper_case_globals)]
            pub const SEND_TTS_MESSAGES: Self = Self::from_bits_retain(1 << 12);
            /// Allows for deletion of other users' messages.
            #[allow(deprecated, non_upper_case_globals)]
            pub const MANAGE_MESSAGES: Self = Self::from_bits_retain(1 << 14);
            /// Links sent by users with this permission will
            /// be auto-embedded.
            #[allow(deprecated, non_upper_case_globals)]
            pub const EMBED_LINKS: Self = Self::from_bits_retain(1 << 14);
            /// Allows for uploading images and files into
            /// channels and threads.
            #[allow(deprecated, non_upper_case_globals)]
            pub const ATTACH_FILES: Self = Self::from_bits_retain(1 << 15);
            /// Allows for reading of message histories.
            #[allow(deprecated, non_upper_case_globals)]
            pub const READ_MESSAGE_HISTORY: Self = Self::from_bits_retain(1 << 16);
            /// Allows for using `@everyone` tag to notify
            /// all users in a channel, and the `@here` tag to
            /// notify all online (prescened) users in a channel.
            #[allow(deprecated, non_upper_case_globals)]
            pub const MENTION_EVERYONE: Self = Self::from_bits_retain(1 << 17);
            /// Allows users to use custom emojis from other servers
            /// (Users must have Nitro or premium subscription required
            /// in order to use it).
            #[allow(deprecated, non_upper_case_globals)]
            pub const USE_EXTERNAL_EMOJIS: Self = Self::from_bits_retain(1 << 18);
            /// Allows for viewing guild insights.
            #[allow(deprecated, non_upper_case_globals)]
            pub const VIEW_GUILD_INSIGHTS: Self = Self::from_bits_retain(1 << 19);
            /// Allows to join a voice channel.
            #[allow(deprecated, non_upper_case_globals)]
            pub const CONNECT: Self = Self::from_bits_retain(1 << 20);
            /// Allows to speak in a voice channel.
            #[allow(deprecated, non_upper_case_globals)]
            pub const SPEAK: Self = Self::from_bits_retain(1 << 21);
            /// Allows to mute members in a voice channel.
            #[allow(deprecated, non_upper_case_globals)]
            pub const MUTE_MEMBERS: Self = Self::from_bits_retain(1 << 22);
            /// Allows to deafen members in a voice channel.
            #[allow(deprecated, non_upper_case_globals)]
            pub const DEAFEN_MEMBERS: Self = Self::from_bits_retain(1 << 23);
            /// Allows to move members between voice channels.
            #[allow(deprecated, non_upper_case_globals)]
            pub const MOVE_MEMBERS: Self = Self::from_bits_retain(1 << 24);
            /// Allows for using voice-activity-detection
            /// in a voice channel.
            #[allow(deprecated, non_upper_case_globals)]
            pub const USE_VAD: Self = Self::from_bits_retain(1 << 25);
            /// Allows to modify of a guild member's nickname.
            #[allow(deprecated, non_upper_case_globals)]
            pub const CHANGE_NICKNAME: Self = Self::from_bits_retain(1 << 26);
            /// Allows to modify other guild members' nickname
            #[allow(deprecated, non_upper_case_globals)]
            pub const MANAGE_NICKNAME: Self = Self::from_bits_retain(1 << 27);
            /// Allows management and editing of guild roles.
            #[allow(deprecated, non_upper_case_globals)]
            pub const MANAGE_ROLES: Self = Self::from_bits_retain(1 << 28);
            /// Allows management and editing of guild webhooks.
            #[allow(deprecated, non_upper_case_globals)]
            pub const MANAGE_WEBHOOKS: Self = Self::from_bits_retain(1 << 29);
            /// Allows management and editing of guild's emojis and stickers.
            #[allow(deprecated, non_upper_case_globals)]
            pub const MANAGE_EMOJIS_AND_STICKERS: Self = Self::from_bits_retain(1 << 30);
            /// Allows members to use application members
            /// including slash commands, and context menu commands.
            #[allow(deprecated, non_upper_case_globals)]
            pub const USE_APPLICATION_COMMANDS: Self = Self::from_bits_retain(1 << 31);
            /// Allows for requesting to peak in stage channels.
            ///
            /// **NOTE**:
            /// According to Discord, this permission is under active development.
            /// It may be changed or removed in the future, if you have issues
            /// with this permission please let me know in GitHub issues.
            #[allow(deprecated, non_upper_case_globals)]
            pub const REQUEST_TO_SPEAK: Self = Self::from_bits_retain(1 << 32);
            /// Allows for creating, editing and deleting
            /// scheduled events in a guild.
            #[allow(deprecated, non_upper_case_globals)]
            pub const MANAGE_EVENTS: Self = Self::from_bits_retain(1 << 33);
            /// Allows for deleting and archiving threads, and viewing all
            /// private guild threads
            #[allow(deprecated, non_upper_case_globals)]
            pub const MANAGE_THREADS: Self = Self::from_bits_retain(1 << 34);
            /// Allows for creating public and announcement threads
            #[allow(deprecated, non_upper_case_globals)]
            pub const CREATE_PUBLIC_THREADS: Self = Self::from_bits_retain(1 << 35);
            /// Allows for creating private threads
            #[allow(deprecated, non_upper_case_globals)]
            pub const CREATE_PRIVATE_THREADS: Self = Self::from_bits_retain(1 << 36);
            /// Allows the usage of custom stickers from other servers
            #[allow(deprecated, non_upper_case_globals)]
            pub const USE_EXTERNAL_STICKERS: Self = Self::from_bits_retain(1 << 37);
            /// Allows for sending messages in threads
            #[allow(deprecated, non_upper_case_globals)]
            pub const SEND_MESSAGES_IN_THREADS: Self = Self::from_bits_retain(1 << 38);
            /// Allows for using Activities (applications with
            /// the EMBEDDED flag) in a voice channel
            #[allow(deprecated, non_upper_case_globals)]
            pub const USE_EMBEDDED_ACTIVITIES: Self = Self::from_bits_retain(1 << 39);
            /// Allows for timing out users to prevent them from
            /// sending or reacting to messages in chat and threads,
            /// and from speaking in voice and stage channels
            #[allow(deprecated, non_upper_case_globals)]
            pub const MODERATE_MEMBERS: Self = Self::from_bits_retain(1 << 40);
        }
        impl ::bitflags::Flags for Permissions {
            const FLAGS: &'static [::bitflags::Flag<Permissions>] = &[
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "CREATE_INSTANT_INVITE",
                        Permissions::CREATE_INSTANT_INVITE,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("KICK_MEMBERS", Permissions::KICK_MEMBERS)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("BAN_MEMBERS", Permissions::BAN_MEMBERS)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("ADMINISTRATOR", Permissions::ADMINISTRATOR)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "MANAGE_CHANNELS",
                        Permissions::MANAGE_CHANNELS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("MANAGE_GUILD", Permissions::MANAGE_GUILD)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("ADD_REACTIONS", Permissions::ADD_REACTIONS)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("VIEW_AUDIT_LOG", Permissions::VIEW_AUDIT_LOG)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "PRIORITY_SPEAKER",
                        Permissions::PRIORITY_SPEAKER,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("STREAM", Permissions::STREAM)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("VIEW_CHANNEL", Permissions::VIEW_CHANNEL)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("SEND_MESSAGES", Permissions::SEND_MESSAGES)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "SEND_TTS_MESSAGES",
                        Permissions::SEND_TTS_MESSAGES,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "MANAGE_MESSAGES",
                        Permissions::MANAGE_MESSAGES,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("EMBED_LINKS", Permissions::EMBED_LINKS)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("ATTACH_FILES", Permissions::ATTACH_FILES)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "READ_MESSAGE_HISTORY",
                        Permissions::READ_MESSAGE_HISTORY,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "MENTION_EVERYONE",
                        Permissions::MENTION_EVERYONE,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "USE_EXTERNAL_EMOJIS",
                        Permissions::USE_EXTERNAL_EMOJIS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "VIEW_GUILD_INSIGHTS",
                        Permissions::VIEW_GUILD_INSIGHTS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("CONNECT", Permissions::CONNECT)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("SPEAK", Permissions::SPEAK)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("MUTE_MEMBERS", Permissions::MUTE_MEMBERS)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("DEAFEN_MEMBERS", Permissions::DEAFEN_MEMBERS)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("MOVE_MEMBERS", Permissions::MOVE_MEMBERS)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("USE_VAD", Permissions::USE_VAD)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "CHANGE_NICKNAME",
                        Permissions::CHANGE_NICKNAME,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "MANAGE_NICKNAME",
                        Permissions::MANAGE_NICKNAME,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("MANAGE_ROLES", Permissions::MANAGE_ROLES)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "MANAGE_WEBHOOKS",
                        Permissions::MANAGE_WEBHOOKS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "MANAGE_EMOJIS_AND_STICKERS",
                        Permissions::MANAGE_EMOJIS_AND_STICKERS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "USE_APPLICATION_COMMANDS",
                        Permissions::USE_APPLICATION_COMMANDS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "REQUEST_TO_SPEAK",
                        Permissions::REQUEST_TO_SPEAK,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("MANAGE_EVENTS", Permissions::MANAGE_EVENTS)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("MANAGE_THREADS", Permissions::MANAGE_THREADS)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "CREATE_PUBLIC_THREADS",
                        Permissions::CREATE_PUBLIC_THREADS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "CREATE_PRIVATE_THREADS",
                        Permissions::CREATE_PRIVATE_THREADS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "USE_EXTERNAL_STICKERS",
                        Permissions::USE_EXTERNAL_STICKERS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "SEND_MESSAGES_IN_THREADS",
                        Permissions::SEND_MESSAGES_IN_THREADS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "USE_EMBEDDED_ACTIVITIES",
                        Permissions::USE_EMBEDDED_ACTIVITIES,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "MODERATE_MEMBERS",
                        Permissions::MODERATE_MEMBERS,
                    )
                },
            ];
            type Bits = u64;
            fn bits(&self) -> u64 {
                Permissions::bits(self)
            }
            fn from_bits_retain(bits: u64) -> Permissions {
                Permissions::from_bits_retain(bits)
            }
        }
        #[allow(
            dead_code,
            deprecated,
            unused_doc_comments,
            unused_attributes,
            unused_mut,
            unused_imports,
            non_upper_case_globals,
            clippy::assign_op_pattern
        )]
        const _: () = {
            #[repr(transparent)]
            pub struct InternalBitFlags(u64);
            #[automatically_derived]
            impl ::core::clone::Clone for InternalBitFlags {
                #[inline]
                fn clone(&self) -> InternalBitFlags {
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for InternalBitFlags {
                #[inline]
                fn eq(&self, other: &InternalBitFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for InternalBitFlags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u64>;
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for InternalBitFlags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &InternalBitFlags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for InternalBitFlags {
                #[inline]
                fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for InternalBitFlags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            impl ::bitflags::__private::PublicFlags for Permissions {
                type Primitive = u64;
                type Internal = InternalBitFlags;
            }
            impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                #[inline]
                fn default() -> Self {
                    InternalBitFlags::empty()
                }
            }
            impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    if self.is_empty() {
                        f.write_fmt(
                            format_args!("{0:#x}", < u64 as ::bitflags::Bits >::EMPTY),
                        )
                    } else {
                        ::bitflags::__private::core::fmt::Display::fmt(self, f)
                    }
                }
            }
            impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::parser::to_writer(&Permissions(*self), f)
                }
            }
            impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                type Err = ::bitflags::parser::ParseError;
                fn from_str(
                    s: &str,
                ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                    ::bitflags::parser::from_str::<Permissions>(s).map(|flags| flags.0)
                }
            }
            impl ::bitflags::__private::core::convert::AsRef<u64> for InternalBitFlags {
                fn as_ref(&self) -> &u64 {
                    &self.0
                }
            }
            impl ::bitflags::__private::core::convert::From<u64> for InternalBitFlags {
                fn from(bits: u64) -> Self {
                    Self::from_bits_retain(bits)
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl InternalBitFlags {
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(<u64 as ::bitflags::Bits>::EMPTY) }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    { Self::from_bits_truncate(<u64 as ::bitflags::Bits>::ALL) }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u64 {
                    let f = self;
                    { f.0 }
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u64,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        let truncated = Self::from_bits_truncate(bits).0;
                        if truncated == bits {
                            ::bitflags::__private::core::option::Option::Some(Self(bits))
                        } else {
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u64) -> Self {
                    let bits = bits;
                    {
                        if bits == <u64 as ::bitflags::Bits>::EMPTY {
                            return Self(bits);
                        }
                        let mut truncated = <u64 as ::bitflags::Bits>::EMPTY;
                        {
                            if bits & Permissions::CREATE_INSTANT_INVITE.bits()
                                == Permissions::CREATE_INSTANT_INVITE.bits()
                            {
                                truncated = truncated
                                    | Permissions::CREATE_INSTANT_INVITE.bits();
                            }
                        };
                        {
                            if bits & Permissions::KICK_MEMBERS.bits()
                                == Permissions::KICK_MEMBERS.bits()
                            {
                                truncated = truncated | Permissions::KICK_MEMBERS.bits();
                            }
                        };
                        {
                            if bits & Permissions::BAN_MEMBERS.bits()
                                == Permissions::BAN_MEMBERS.bits()
                            {
                                truncated = truncated | Permissions::BAN_MEMBERS.bits();
                            }
                        };
                        {
                            if bits & Permissions::ADMINISTRATOR.bits()
                                == Permissions::ADMINISTRATOR.bits()
                            {
                                truncated = truncated | Permissions::ADMINISTRATOR.bits();
                            }
                        };
                        {
                            if bits & Permissions::MANAGE_CHANNELS.bits()
                                == Permissions::MANAGE_CHANNELS.bits()
                            {
                                truncated = truncated | Permissions::MANAGE_CHANNELS.bits();
                            }
                        };
                        {
                            if bits & Permissions::MANAGE_GUILD.bits()
                                == Permissions::MANAGE_GUILD.bits()
                            {
                                truncated = truncated | Permissions::MANAGE_GUILD.bits();
                            }
                        };
                        {
                            if bits & Permissions::ADD_REACTIONS.bits()
                                == Permissions::ADD_REACTIONS.bits()
                            {
                                truncated = truncated | Permissions::ADD_REACTIONS.bits();
                            }
                        };
                        {
                            if bits & Permissions::VIEW_AUDIT_LOG.bits()
                                == Permissions::VIEW_AUDIT_LOG.bits()
                            {
                                truncated = truncated | Permissions::VIEW_AUDIT_LOG.bits();
                            }
                        };
                        {
                            if bits & Permissions::PRIORITY_SPEAKER.bits()
                                == Permissions::PRIORITY_SPEAKER.bits()
                            {
                                truncated = truncated
                                    | Permissions::PRIORITY_SPEAKER.bits();
                            }
                        };
                        {
                            if bits & Permissions::STREAM.bits()
                                == Permissions::STREAM.bits()
                            {
                                truncated = truncated | Permissions::STREAM.bits();
                            }
                        };
                        {
                            if bits & Permissions::VIEW_CHANNEL.bits()
                                == Permissions::VIEW_CHANNEL.bits()
                            {
                                truncated = truncated | Permissions::VIEW_CHANNEL.bits();
                            }
                        };
                        {
                            if bits & Permissions::SEND_MESSAGES.bits()
                                == Permissions::SEND_MESSAGES.bits()
                            {
                                truncated = truncated | Permissions::SEND_MESSAGES.bits();
                            }
                        };
                        {
                            if bits & Permissions::SEND_TTS_MESSAGES.bits()
                                == Permissions::SEND_TTS_MESSAGES.bits()
                            {
                                truncated = truncated
                                    | Permissions::SEND_TTS_MESSAGES.bits();
                            }
                        };
                        {
                            if bits & Permissions::MANAGE_MESSAGES.bits()
                                == Permissions::MANAGE_MESSAGES.bits()
                            {
                                truncated = truncated | Permissions::MANAGE_MESSAGES.bits();
                            }
                        };
                        {
                            if bits & Permissions::EMBED_LINKS.bits()
                                == Permissions::EMBED_LINKS.bits()
                            {
                                truncated = truncated | Permissions::EMBED_LINKS.bits();
                            }
                        };
                        {
                            if bits & Permissions::ATTACH_FILES.bits()
                                == Permissions::ATTACH_FILES.bits()
                            {
                                truncated = truncated | Permissions::ATTACH_FILES.bits();
                            }
                        };
                        {
                            if bits & Permissions::READ_MESSAGE_HISTORY.bits()
                                == Permissions::READ_MESSAGE_HISTORY.bits()
                            {
                                truncated = truncated
                                    | Permissions::READ_MESSAGE_HISTORY.bits();
                            }
                        };
                        {
                            if bits & Permissions::MENTION_EVERYONE.bits()
                                == Permissions::MENTION_EVERYONE.bits()
                            {
                                truncated = truncated
                                    | Permissions::MENTION_EVERYONE.bits();
                            }
                        };
                        {
                            if bits & Permissions::USE_EXTERNAL_EMOJIS.bits()
                                == Permissions::USE_EXTERNAL_EMOJIS.bits()
                            {
                                truncated = truncated
                                    | Permissions::USE_EXTERNAL_EMOJIS.bits();
                            }
                        };
                        {
                            if bits & Permissions::VIEW_GUILD_INSIGHTS.bits()
                                == Permissions::VIEW_GUILD_INSIGHTS.bits()
                            {
                                truncated = truncated
                                    | Permissions::VIEW_GUILD_INSIGHTS.bits();
                            }
                        };
                        {
                            if bits & Permissions::CONNECT.bits()
                                == Permissions::CONNECT.bits()
                            {
                                truncated = truncated | Permissions::CONNECT.bits();
                            }
                        };
                        {
                            if bits & Permissions::SPEAK.bits()
                                == Permissions::SPEAK.bits()
                            {
                                truncated = truncated | Permissions::SPEAK.bits();
                            }
                        };
                        {
                            if bits & Permissions::MUTE_MEMBERS.bits()
                                == Permissions::MUTE_MEMBERS.bits()
                            {
                                truncated = truncated | Permissions::MUTE_MEMBERS.bits();
                            }
                        };
                        {
                            if bits & Permissions::DEAFEN_MEMBERS.bits()
                                == Permissions::DEAFEN_MEMBERS.bits()
                            {
                                truncated = truncated | Permissions::DEAFEN_MEMBERS.bits();
                            }
                        };
                        {
                            if bits & Permissions::MOVE_MEMBERS.bits()
                                == Permissions::MOVE_MEMBERS.bits()
                            {
                                truncated = truncated | Permissions::MOVE_MEMBERS.bits();
                            }
                        };
                        {
                            if bits & Permissions::USE_VAD.bits()
                                == Permissions::USE_VAD.bits()
                            {
                                truncated = truncated | Permissions::USE_VAD.bits();
                            }
                        };
                        {
                            if bits & Permissions::CHANGE_NICKNAME.bits()
                                == Permissions::CHANGE_NICKNAME.bits()
                            {
                                truncated = truncated | Permissions::CHANGE_NICKNAME.bits();
                            }
                        };
                        {
                            if bits & Permissions::MANAGE_NICKNAME.bits()
                                == Permissions::MANAGE_NICKNAME.bits()
                            {
                                truncated = truncated | Permissions::MANAGE_NICKNAME.bits();
                            }
                        };
                        {
                            if bits & Permissions::MANAGE_ROLES.bits()
                                == Permissions::MANAGE_ROLES.bits()
                            {
                                truncated = truncated | Permissions::MANAGE_ROLES.bits();
                            }
                        };
                        {
                            if bits & Permissions::MANAGE_WEBHOOKS.bits()
                                == Permissions::MANAGE_WEBHOOKS.bits()
                            {
                                truncated = truncated | Permissions::MANAGE_WEBHOOKS.bits();
                            }
                        };
                        {
                            if bits & Permissions::MANAGE_EMOJIS_AND_STICKERS.bits()
                                == Permissions::MANAGE_EMOJIS_AND_STICKERS.bits()
                            {
                                truncated = truncated
                                    | Permissions::MANAGE_EMOJIS_AND_STICKERS.bits();
                            }
                        };
                        {
                            if bits & Permissions::USE_APPLICATION_COMMANDS.bits()
                                == Permissions::USE_APPLICATION_COMMANDS.bits()
                            {
                                truncated = truncated
                                    | Permissions::USE_APPLICATION_COMMANDS.bits();
                            }
                        };
                        {
                            if bits & Permissions::REQUEST_TO_SPEAK.bits()
                                == Permissions::REQUEST_TO_SPEAK.bits()
                            {
                                truncated = truncated
                                    | Permissions::REQUEST_TO_SPEAK.bits();
                            }
                        };
                        {
                            if bits & Permissions::MANAGE_EVENTS.bits()
                                == Permissions::MANAGE_EVENTS.bits()
                            {
                                truncated = truncated | Permissions::MANAGE_EVENTS.bits();
                            }
                        };
                        {
                            if bits & Permissions::MANAGE_THREADS.bits()
                                == Permissions::MANAGE_THREADS.bits()
                            {
                                truncated = truncated | Permissions::MANAGE_THREADS.bits();
                            }
                        };
                        {
                            if bits & Permissions::CREATE_PUBLIC_THREADS.bits()
                                == Permissions::CREATE_PUBLIC_THREADS.bits()
                            {
                                truncated = truncated
                                    | Permissions::CREATE_PUBLIC_THREADS.bits();
                            }
                        };
                        {
                            if bits & Permissions::CREATE_PRIVATE_THREADS.bits()
                                == Permissions::CREATE_PRIVATE_THREADS.bits()
                            {
                                truncated = truncated
                                    | Permissions::CREATE_PRIVATE_THREADS.bits();
                            }
                        };
                        {
                            if bits & Permissions::USE_EXTERNAL_STICKERS.bits()
                                == Permissions::USE_EXTERNAL_STICKERS.bits()
                            {
                                truncated = truncated
                                    | Permissions::USE_EXTERNAL_STICKERS.bits();
                            }
                        };
                        {
                            if bits & Permissions::SEND_MESSAGES_IN_THREADS.bits()
                                == Permissions::SEND_MESSAGES_IN_THREADS.bits()
                            {
                                truncated = truncated
                                    | Permissions::SEND_MESSAGES_IN_THREADS.bits();
                            }
                        };
                        {
                            if bits & Permissions::USE_EMBEDDED_ACTIVITIES.bits()
                                == Permissions::USE_EMBEDDED_ACTIVITIES.bits()
                            {
                                truncated = truncated
                                    | Permissions::USE_EMBEDDED_ACTIVITIES.bits();
                            }
                        };
                        {
                            if bits & Permissions::MODERATE_MEMBERS.bits()
                                == Permissions::MODERATE_MEMBERS.bits()
                            {
                                truncated = truncated
                                    | Permissions::MODERATE_MEMBERS.bits();
                            }
                        };
                        Self(truncated)
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                #[inline]
                pub const fn from_bits_retain(bits: u64) -> Self {
                    let bits = bits;
                    { Self(bits) }
                }
                /// Get the value for a flag from its stringified name.
                ///
                /// Names are _case-sensitive_, so must correspond exactly to
                /// the identifier given to the flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        {
                            if name == "CREATE_INSTANT_INVITE" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::CREATE_INSTANT_INVITE.bits()),
                                );
                            }
                        };
                        {
                            if name == "KICK_MEMBERS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::KICK_MEMBERS.bits()),
                                );
                            }
                        };
                        {
                            if name == "BAN_MEMBERS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::BAN_MEMBERS.bits()),
                                );
                            }
                        };
                        {
                            if name == "ADMINISTRATOR" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::ADMINISTRATOR.bits()),
                                );
                            }
                        };
                        {
                            if name == "MANAGE_CHANNELS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MANAGE_CHANNELS.bits()),
                                );
                            }
                        };
                        {
                            if name == "MANAGE_GUILD" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MANAGE_GUILD.bits()),
                                );
                            }
                        };
                        {
                            if name == "ADD_REACTIONS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::ADD_REACTIONS.bits()),
                                );
                            }
                        };
                        {
                            if name == "VIEW_AUDIT_LOG" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::VIEW_AUDIT_LOG.bits()),
                                );
                            }
                        };
                        {
                            if name == "PRIORITY_SPEAKER" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::PRIORITY_SPEAKER.bits()),
                                );
                            }
                        };
                        {
                            if name == "STREAM" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::STREAM.bits()),
                                );
                            }
                        };
                        {
                            if name == "VIEW_CHANNEL" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::VIEW_CHANNEL.bits()),
                                );
                            }
                        };
                        {
                            if name == "SEND_MESSAGES" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::SEND_MESSAGES.bits()),
                                );
                            }
                        };
                        {
                            if name == "SEND_TTS_MESSAGES" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::SEND_TTS_MESSAGES.bits()),
                                );
                            }
                        };
                        {
                            if name == "MANAGE_MESSAGES" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MANAGE_MESSAGES.bits()),
                                );
                            }
                        };
                        {
                            if name == "EMBED_LINKS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::EMBED_LINKS.bits()),
                                );
                            }
                        };
                        {
                            if name == "ATTACH_FILES" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::ATTACH_FILES.bits()),
                                );
                            }
                        };
                        {
                            if name == "READ_MESSAGE_HISTORY" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::READ_MESSAGE_HISTORY.bits()),
                                );
                            }
                        };
                        {
                            if name == "MENTION_EVERYONE" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MENTION_EVERYONE.bits()),
                                );
                            }
                        };
                        {
                            if name == "USE_EXTERNAL_EMOJIS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::USE_EXTERNAL_EMOJIS.bits()),
                                );
                            }
                        };
                        {
                            if name == "VIEW_GUILD_INSIGHTS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::VIEW_GUILD_INSIGHTS.bits()),
                                );
                            }
                        };
                        {
                            if name == "CONNECT" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::CONNECT.bits()),
                                );
                            }
                        };
                        {
                            if name == "SPEAK" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::SPEAK.bits()),
                                );
                            }
                        };
                        {
                            if name == "MUTE_MEMBERS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MUTE_MEMBERS.bits()),
                                );
                            }
                        };
                        {
                            if name == "DEAFEN_MEMBERS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::DEAFEN_MEMBERS.bits()),
                                );
                            }
                        };
                        {
                            if name == "MOVE_MEMBERS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MOVE_MEMBERS.bits()),
                                );
                            }
                        };
                        {
                            if name == "USE_VAD" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::USE_VAD.bits()),
                                );
                            }
                        };
                        {
                            if name == "CHANGE_NICKNAME" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::CHANGE_NICKNAME.bits()),
                                );
                            }
                        };
                        {
                            if name == "MANAGE_NICKNAME" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MANAGE_NICKNAME.bits()),
                                );
                            }
                        };
                        {
                            if name == "MANAGE_ROLES" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MANAGE_ROLES.bits()),
                                );
                            }
                        };
                        {
                            if name == "MANAGE_WEBHOOKS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MANAGE_WEBHOOKS.bits()),
                                );
                            }
                        };
                        {
                            if name == "MANAGE_EMOJIS_AND_STICKERS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MANAGE_EMOJIS_AND_STICKERS.bits()),
                                );
                            }
                        };
                        {
                            if name == "USE_APPLICATION_COMMANDS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::USE_APPLICATION_COMMANDS.bits()),
                                );
                            }
                        };
                        {
                            if name == "REQUEST_TO_SPEAK" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::REQUEST_TO_SPEAK.bits()),
                                );
                            }
                        };
                        {
                            if name == "MANAGE_EVENTS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MANAGE_EVENTS.bits()),
                                );
                            }
                        };
                        {
                            if name == "MANAGE_THREADS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MANAGE_THREADS.bits()),
                                );
                            }
                        };
                        {
                            if name == "CREATE_PUBLIC_THREADS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::CREATE_PUBLIC_THREADS.bits()),
                                );
                            }
                        };
                        {
                            if name == "CREATE_PRIVATE_THREADS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::CREATE_PRIVATE_THREADS.bits()),
                                );
                            }
                        };
                        {
                            if name == "USE_EXTERNAL_STICKERS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::USE_EXTERNAL_STICKERS.bits()),
                                );
                            }
                        };
                        {
                            if name == "SEND_MESSAGES_IN_THREADS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::SEND_MESSAGES_IN_THREADS.bits()),
                                );
                            }
                        };
                        {
                            if name == "USE_EMBEDDED_ACTIVITIES" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::USE_EMBEDDED_ACTIVITIES.bits()),
                                );
                            }
                        };
                        {
                            if name == "MODERATE_MEMBERS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(Permissions::MODERATE_MEMBERS.bits()),
                                );
                            }
                        };
                        let _ = name;
                        ::bitflags::__private::core::option::Option::None
                    }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.0 == Self::empty().0 }
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { Self::all().0 | f.0 == f.0 }
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { !(Self(f.0 & other.0)).is_empty() }
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { (f.0 & other.0) == other.0 }
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        f.0 = f.0 | other.0;
                    }
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        f.0 = f.0 & !other.0;
                    }
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        f.0 = f.0 ^ other.0;
                    }
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    {
                        if value {
                            f.insert(other);
                        } else {
                            f.remove(other);
                        }
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 & other.0) }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 | other.0) }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 & !other.0) }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 ^ other.0) }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self::from_bits_truncate(!f.0) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Binary::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Octal::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: InternalBitFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.0 = self.0 | other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for InternalBitFlags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.0 = self.0 ^ other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for InternalBitFlags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.0 = self.0 & other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.0 = self.0 & !other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
            for InternalBitFlags {
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
            for InternalBitFlags {
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl InternalBitFlags {
                /// Iterate over enabled flag values.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<Permissions> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <Permissions as ::bitflags::Flags>::FLAGS,
                        Permissions::from_bits_retain(self.bits()),
                        Permissions::from_bits_retain(self.bits()),
                    )
                }
                /// Iterate over enabled flag values with their stringified names.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<Permissions> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <Permissions as ::bitflags::Flags>::FLAGS,
                        Permissions::from_bits_retain(self.bits()),
                        Permissions::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for InternalBitFlags {
                type Item = Permissions;
                type IntoIter = ::bitflags::iter::Iter<Permissions>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
            impl InternalBitFlags {
                /// Returns a mutable reference to the raw value of the flags currently stored.
                #[inline]
                pub fn bits_mut(&mut self) -> &mut u64 {
                    &mut self.0
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl Permissions {
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(InternalBitFlags::empty()) }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    { Self(InternalBitFlags::all()) }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u64 {
                    let f = self;
                    { f.0.bits() }
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u64,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        match InternalBitFlags::from_bits(bits) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u64) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_truncate(bits)) }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                #[inline]
                pub const fn from_bits_retain(bits: u64) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_retain(bits)) }
                }
                /// Get the value for a flag from its stringified name.
                ///
                /// Names are _case-sensitive_, so must correspond exactly to
                /// the identifier given to the flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        match InternalBitFlags::from_name(name) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.0.is_empty() }
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { f.0.is_all() }
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.intersects(other.0) }
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.contains(other.0) }
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.insert(other.0) }
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.remove(other.0) }
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.toggle(other.0) }
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    { f.0.set(other.0, value) }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.intersection(other.0)) }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.union(other.0)) }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.difference(other.0)) }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.symmetric_difference(other.0)) }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self(f.0.complement()) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for Permissions {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Binary::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for Permissions {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Octal::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for Permissions {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for Permissions {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for Permissions {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Permissions) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for Permissions {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.0 = self.0 | other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for Permissions {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for Permissions {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.0 = self.0 ^ other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for Permissions {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for Permissions {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.0 = self.0 & other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Sub for Permissions {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for Permissions {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.0 = self.0 & !other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Not for Permissions {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<Permissions> for Permissions {
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<Permissions>
            for Permissions {
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl Permissions {
                /// Iterate over enabled flag values.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<Permissions> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <Permissions as ::bitflags::Flags>::FLAGS,
                        Permissions::from_bits_retain(self.bits()),
                        Permissions::from_bits_retain(self.bits()),
                    )
                }
                /// Iterate over enabled flag values with their stringified names.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<Permissions> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <Permissions as ::bitflags::Flags>::FLAGS,
                        Permissions::from_bits_retain(self.bits()),
                        Permissions::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for Permissions {
                type Item = Permissions;
                type IntoIter = ::bitflags::iter::Iter<Permissions>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
        };
        impl Permissions {
            pub const MFA_REQUIRED: Self = Self::from_bits_truncate(
                Self::KICK_MEMBERS.bits() | Self::BAN_MEMBERS.bits()
                    | Self::ADMINISTRATOR.bits() | Self::MANAGE_CHANNELS.bits()
                    | Self::MANAGE_GUILD.bits() | Self::MANAGE_MESSAGES.bits()
                    | Self::MANAGE_ROLES.bits() | Self::MANAGE_WEBHOOKS.bits()
                    | Self::MANAGE_EMOJIS_AND_STICKERS.bits()
                    | Self::MANAGE_THREADS.bits(),
            );
            pub fn requires_mfa(self) -> bool {
                !(Self::MFA_REQUIRED & self).is_empty()
            }
        }
        impl Permissions {
            pub const TEXT_CHANNEL: Self = Self::from_bits_truncate(
                Self::CREATE_INSTANT_INVITE.bits() | Self::MANAGE_CHANNELS.bits()
                    | Self::ADD_REACTIONS.bits() | Self::VIEW_CHANNEL.bits()
                    | Self::SEND_MESSAGES.bits() | Self::SEND_TTS_MESSAGES.bits()
                    | Self::MANAGE_MESSAGES.bits() | Self::EMBED_LINKS.bits()
                    | Self::ATTACH_FILES.bits() | Self::READ_MESSAGE_HISTORY.bits()
                    | Self::MENTION_EVERYONE.bits() | Self::USE_EXTERNAL_EMOJIS.bits()
                    | Self::MANAGE_ROLES.bits() | Self::MANAGE_WEBHOOKS.bits()
                    | Self::USE_APPLICATION_COMMANDS.bits() | Self::MANAGE_THREADS.bits()
                    | Self::CREATE_PUBLIC_THREADS.bits()
                    | Self::CREATE_PRIVATE_THREADS.bits()
                    | Self::USE_EXTERNAL_STICKERS.bits()
                    | Self::SEND_MESSAGES_IN_THREADS.bits(),
            );
            pub fn has_text_perms(self) -> bool {
                if self.contains(Self::ADMINISTRATOR) {
                    true
                } else {
                    !(Self::TEXT_CHANNEL & self).is_empty()
                }
            }
        }
        impl Permissions {
            pub const VOICE_CHANNEL: Self = Self::from_bits_truncate(
                Self::CREATE_INSTANT_INVITE.bits() | Self::MANAGE_CHANNELS.bits()
                    | Self::ADD_REACTIONS.bits() | Self::PRIORITY_SPEAKER.bits()
                    | Self::STREAM.bits() | Self::VIEW_CHANNEL.bits()
                    | Self::MANAGE_MESSAGES.bits() | Self::EMBED_LINKS.bits()
                    | Self::ATTACH_FILES.bits() | Self::READ_MESSAGE_HISTORY.bits()
                    | Self::MENTION_EVERYONE.bits() | Self::USE_EXTERNAL_EMOJIS.bits()
                    | Self::CONNECT.bits() | Self::SPEAK.bits()
                    | Self::MUTE_MEMBERS.bits() | Self::DEAFEN_MEMBERS.bits()
                    | Self::MOVE_MEMBERS.bits() | Self::USE_VAD.bits()
                    | Self::MANAGE_ROLES.bits() | Self::USE_APPLICATION_COMMANDS.bits()
                    | Self::MANAGE_EVENTS.bits() | Self::USE_EXTERNAL_STICKERS.bits()
                    | Self::USE_EMBEDDED_ACTIVITIES.bits(),
            );
            pub fn has_voice_perms(self) -> bool {
                if self.contains(Self::ADMINISTRATOR) {
                    true
                } else {
                    !(Self::VOICE_CHANNEL & self).is_empty()
                }
            }
        }
        impl Permissions {
            pub const STAGED_CHANNEL: Self = Self::from_bits_truncate(
                Self::CREATE_INSTANT_INVITE.bits() | Self::MANAGE_CHANNELS.bits()
                    | Self::ADD_REACTIONS.bits() | Self::VIEW_CHANNEL.bits()
                    | Self::MENTION_EVERYONE.bits() | Self::CONNECT.bits()
                    | Self::MUTE_MEMBERS.bits() | Self::DEAFEN_MEMBERS.bits()
                    | Self::MOVE_MEMBERS.bits() | Self::MANAGE_ROLES.bits()
                    | Self::REQUEST_TO_SPEAK.bits() | Self::MANAGE_EVENTS.bits(),
            );
            pub fn has_staged_perms(self) -> bool {
                if self.contains(Self::ADMINISTRATOR) {
                    true
                } else {
                    !(Self::STAGED_CHANNEL & self).is_empty()
                }
            }
        }
        impl std::fmt::Display for Permissions {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                self.0.0.fmt(f)
            }
        }
        impl<'de> serde::Deserialize<'de> for Permissions {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Permissions;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("discord permission flags")
                    }
                    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        let value = v.parse::<u64>().map_err(serde::de::Error::custom)?;
                        self.visit_u64(value)
                    }
                    fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        if v < 0 {
                            Err(
                                serde::de::Error::custom(
                                    "attempt to deserialize with negative integer",
                                ),
                            )
                        } else {
                            self.visit_u64(v as u64)
                        }
                    }
                    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Ok(Permissions::from_bits_truncate(v))
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }
        impl serde::Serialize for Permissions {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                serializer.collect_str(&self.bits())
            }
        }
    }
    pub(crate) mod timestamp {
        use thiserror::Error;
        use time::error::Parse as ParseError;
        use time::format_description::well_known::Rfc3339;
        use time::OffsetDateTime;
        const DISCORD_EPOCH_MS: i64 = 1420070400000;
        pub(crate) mod serde_impl {
            use super::Timestamp;
            use serde::{Serialize, Serializer};
            use time::format_description::well_known::Rfc3339;
            #[inline]
            fn serialize_inner<S: Serializer>(
                value: &Timestamp,
                serializer: S,
            ) -> Result<S::Ok, S::Error> {
                value
                    .0
                    .format(&Rfc3339)
                    .map_err(serde::ser::Error::custom)?
                    .serialize(serializer)
            }
            pub mod secs {
                use crate::misc::Timestamp;
                use serde::{Deserializer, Serializer};
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Timestamp;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("Unix timestamp")
                    }
                    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Timestamp::from_secs(v as i64)
                            .map_err(|v| {
                                serde::de::Error::custom(v)
                            })
                    }
                    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Timestamp::parse(v).map_err(serde::de::Error::custom)
                    }
                }
                pub fn deserialize<'de, D: Deserializer<'de>>(
                    deserializer: D,
                ) -> Result<Timestamp, D::Error> {
                    deserializer.deserialize_any(Visitor)
                }
                pub fn serialize<S: Serializer>(
                    value: &Timestamp,
                    serializer: S,
                ) -> Result<S::Ok, S::Error> {
                    super::serialize_inner(value, serializer)
                }
            }
            pub mod millis {
                use crate::misc::Timestamp;
                use serde::{Deserializer, Serializer};
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Timestamp;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("Unix timestamp in milliseconds")
                    }
                    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Timestamp::from_millis(v as i64)
                            .map_err(|v| {
                                serde::de::Error::custom(v)
                            })
                    }
                    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Timestamp::parse(v).map_err(serde::de::Error::custom)
                    }
                }
                pub fn deserialize<'de, D: Deserializer<'de>>(
                    deserializer: D,
                ) -> Result<Timestamp, D::Error> {
                    deserializer.deserialize_any(Visitor)
                }
                pub fn serialize<S: Serializer>(
                    value: &Timestamp,
                    serializer: S,
                ) -> Result<S::Ok, S::Error> {
                    super::serialize_inner(value, serializer)
                }
            }
            pub mod millis_opt {
                use crate::misc::Timestamp;
                use serde::{Deserializer, Serializer};
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Option<Timestamp>;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("Unix timestamp in milliseconds")
                    }
                    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Timestamp::from_millis(v as i64)
                            .map_err(|v| {
                                serde::de::Error::custom(v)
                            })
                            .map(Some)
                    }
                    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Timestamp::parse(v).map_err(serde::de::Error::custom).map(Some)
                    }
                    fn visit_none<E>(self) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Ok(None)
                    }
                    fn visit_unit<E>(self) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Ok(None)
                    }
                }
                pub fn deserialize<'de, D: Deserializer<'de>>(
                    deserializer: D,
                ) -> Result<Option<Timestamp>, D::Error> {
                    deserializer.deserialize_any(Visitor)
                }
                pub fn serialize<S: Serializer>(
                    value: &Option<Timestamp>,
                    serializer: S,
                ) -> Result<S::Ok, S::Error> {
                    match value {
                        Some(n) => super::serialize_inner(n, serializer),
                        None => serializer.serialize_none(),
                    }
                }
            }
            impl<'de> serde::Deserialize<'de> for Timestamp {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Timestamp;
                        fn expecting(
                            &self,
                            f: &mut std::fmt::Formatter<'_>,
                        ) -> std::fmt::Result {
                            f.write_str("RFC 3339 timestamp")
                        }
                        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            Timestamp::parse(v).map_err(serde::de::Error::custom)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }
            impl serde::Serialize for Timestamp {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    serialize_inner(self, serializer)
                }
            }
        }
        pub struct Timestamp(OffsetDateTime);
        #[automatically_derived]
        impl ::core::fmt::Debug for Timestamp {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Timestamp",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Timestamp {
            #[inline]
            fn clone(&self) -> Timestamp {
                let _: ::core::clone::AssertParamIsClone<OffsetDateTime>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Timestamp {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Timestamp {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Timestamp {
            #[inline]
            fn eq(&self, other: &Timestamp) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Timestamp {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Timestamp {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<OffsetDateTime>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Timestamp {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Timestamp,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Timestamp {
            #[inline]
            fn cmp(&self, other: &Timestamp) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Timestamp {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        pub enum TimestampError {
            #[error("failed to parse timestamp: {0}")]
            Parse(ParseError),
            #[error("invalid given unix timestamp")]
            InvalidUnixTimestamp,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TimestampError {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    TimestampError::Parse(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Parse",
                            &__self_0,
                        )
                    }
                    TimestampError::InvalidUnixTimestamp => {
                        ::core::fmt::Formatter::write_str(f, "InvalidUnixTimestamp")
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for TimestampError {}
        #[allow(unused_qualifications)]
        impl std::fmt::Display for TimestampError {
            fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                #[allow(unused_imports)]
                use thiserror::__private::{DisplayAsDisplay, PathAsDisplay};
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    TimestampError::Parse(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "failed to parse timestamp: {0}", _0.as_display()
                                ),
                            )
                    }
                    TimestampError::InvalidUnixTimestamp {} => {
                        __formatter
                            .write_fmt(format_args!("invalid given unix timestamp"))
                    }
                }
            }
        }
        impl Timestamp {
            #[must_use]
            pub fn now() -> Self {
                Self(OffsetDateTime::now_utc())
            }
            #[inline]
            pub fn from_millis(millis: i64) -> Result<Self, TimestampError> {
                let ns = time::Duration::milliseconds(millis).whole_nanoseconds();
                OffsetDateTime::from_unix_timestamp_nanos(ns)
                    .map_err(|_| TimestampError::InvalidUnixTimestamp)
                    .map(Self)
            }
            #[inline]
            pub fn from_secs(secs: i64) -> Result<Self, TimestampError> {
                OffsetDateTime::from_unix_timestamp(secs)
                    .map_err(|_| TimestampError::InvalidUnixTimestamp)
                    .map(Self)
            }
            #[inline]
            pub fn parse(input: &str) -> Result<Self, TimestampError> {
                OffsetDateTime::parse(input, &Rfc3339)
                    .map_err(TimestampError::Parse)
                    .map(Self)
            }
            #[inline]
            pub const fn from_inner(dt: OffsetDateTime) -> Self {
                Self(dt)
            }
        }
        impl Timestamp {
            pub(crate) fn from_snowflake(id: u64) -> Self {
                let timestamp_ms = (id >> 22) as i64 + DISCORD_EPOCH_MS;
                Self::from_millis(timestamp_ms).unwrap()
            }
        }
        impl Timestamp {
            #[must_use]
            pub const fn timestamp(&self) -> i64 {
                self.0.unix_timestamp()
            }
        }
        impl std::fmt::Display for Timestamp {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                self.0.fmt(f)
            }
        }
        impl From<OffsetDateTime> for Timestamp {
            fn from(value: OffsetDateTime) -> Self {
                Self(value)
            }
        }
        impl std::ops::Deref for Timestamp {
            type Target = OffsetDateTime;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
    }
    pub use color::*;
    pub use image_hash::*;
    pub use locale::*;
    pub use permissions::*;
    pub use timestamp::{Timestamp, TimestampError};
}
pub mod oauth {
    mod application {
        use crate::id::{ApplicationId, GameSkuId, GuildId};
        use crate::misc::ImageHash;
        use crate::user::User;
        use super::Team;
        use serde::{Deserialize, Serialize};
        mod flags {
            use crate::internal::macros::bitflags;
            pub struct ApplicationFlags(
                <ApplicationFlags as ::bitflags::__private::PublicFlags>::Internal,
            );
            #[automatically_derived]
            impl ::core::fmt::Debug for ApplicationFlags {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ApplicationFlags",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ApplicationFlags {
                #[inline]
                fn clone(&self) -> ApplicationFlags {
                    let _: ::core::clone::AssertParamIsClone<
                        <ApplicationFlags as ::bitflags::__private::PublicFlags>::Internal,
                    >;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ApplicationFlags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ApplicationFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ApplicationFlags {
                #[inline]
                fn eq(&self, other: &ApplicationFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ApplicationFlags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ApplicationFlags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        <ApplicationFlags as ::bitflags::__private::PublicFlags>::Internal,
                    >;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ApplicationFlags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            impl ApplicationFlags {
                /// Indicates if an app uses the Auto Moderation API
                #[allow(deprecated, non_upper_case_globals)]
                pub const APPLICATION_AUTO_MODERATION_RULE_CREATE_BADGE: Self = Self::from_bits_retain(
                    1 << 6,
                );
                /// Intent required for bots in 100 or more servers to receive presence_update events
                #[allow(deprecated, non_upper_case_globals)]
                pub const GATEWAY_PRESENCE: Self = Self::from_bits_retain(1 << 12);
                /// Intent required for bots in under 100 servers to receive presence_update events, found on the Bot page in your app's settings
                #[allow(deprecated, non_upper_case_globals)]
                pub const GATEWAY_PRESENCE_LIMITED: Self = Self::from_bits_retain(
                    1 << 13,
                );
                /// Intent required for bots in 100 or more servers to receive member-related events like guild_member_add. See the list of member-related events under GUILD_MEMBERS
                #[allow(deprecated, non_upper_case_globals)]
                pub const GATEWAY_GUILD_MEMBERS: Self = Self::from_bits_retain(1 << 14);
                /// Intent required for bots in under 100 servers to receive member-related events like guild_member_add, found on the Bot page in your app's settings. See the list of member-related events under GUILD_MEMBERS
                #[allow(deprecated, non_upper_case_globals)]
                pub const GATEWAY_GUILD_MEMBERS_LIMITED: Self = Self::from_bits_retain(
                    1 << 15,
                );
                /// Indicates unusual growth of an app that prevents verification
                #[allow(deprecated, non_upper_case_globals)]
                pub const VERIFICATION_PENDING_GUILD_LIMIT: Self = Self::from_bits_retain(
                    1 << 16,
                );
                /// Indicates if an app is embedded within the Discord client (currently unavailable publicly)
                #[allow(deprecated, non_upper_case_globals)]
                pub const EMBEDDED: Self = Self::from_bits_retain(1 << 17);
                /// Intent required for bots in 100 or more servers to receive message content
                #[allow(deprecated, non_upper_case_globals)]
                pub const GATEWAY_MESSAGE_CONTENT: Self = Self::from_bits_retain(
                    1 << 18,
                );
                /// Intent required for bots in under 100 servers to receive message content, found on the Bot page in your app's settings
                #[allow(deprecated, non_upper_case_globals)]
                pub const GATEWAY_MESSAGE_CONTENT_LIMITED: Self = Self::from_bits_retain(
                    1 << 19,
                );
                /// Indicates if an app has registered global application commands
                #[allow(deprecated, non_upper_case_globals)]
                pub const APPLICATION_COMMAND_BADGE: Self = Self::from_bits_retain(
                    1 << 23,
                );
            }
            impl ::bitflags::Flags for ApplicationFlags {
                const FLAGS: &'static [::bitflags::Flag<ApplicationFlags>] = &[
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "APPLICATION_AUTO_MODERATION_RULE_CREATE_BADGE",
                            ApplicationFlags::APPLICATION_AUTO_MODERATION_RULE_CREATE_BADGE,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "GATEWAY_PRESENCE",
                            ApplicationFlags::GATEWAY_PRESENCE,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "GATEWAY_PRESENCE_LIMITED",
                            ApplicationFlags::GATEWAY_PRESENCE_LIMITED,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "GATEWAY_GUILD_MEMBERS",
                            ApplicationFlags::GATEWAY_GUILD_MEMBERS,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "GATEWAY_GUILD_MEMBERS_LIMITED",
                            ApplicationFlags::GATEWAY_GUILD_MEMBERS_LIMITED,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "VERIFICATION_PENDING_GUILD_LIMIT",
                            ApplicationFlags::VERIFICATION_PENDING_GUILD_LIMIT,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("EMBEDDED", ApplicationFlags::EMBEDDED)
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "GATEWAY_MESSAGE_CONTENT",
                            ApplicationFlags::GATEWAY_MESSAGE_CONTENT,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "GATEWAY_MESSAGE_CONTENT_LIMITED",
                            ApplicationFlags::GATEWAY_MESSAGE_CONTENT_LIMITED,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "APPLICATION_COMMAND_BADGE",
                            ApplicationFlags::APPLICATION_COMMAND_BADGE,
                        )
                    },
                ];
                type Bits = u32;
                fn bits(&self) -> u32 {
                    ApplicationFlags::bits(self)
                }
                fn from_bits_retain(bits: u32) -> ApplicationFlags {
                    ApplicationFlags::from_bits_retain(bits)
                }
            }
            #[allow(
                dead_code,
                deprecated,
                unused_doc_comments,
                unused_attributes,
                unused_mut,
                unused_imports,
                non_upper_case_globals,
                clippy::assign_op_pattern
            )]
            const _: () = {
                #[repr(transparent)]
                pub struct InternalBitFlags(u32);
                #[automatically_derived]
                impl ::core::clone::Clone for InternalBitFlags {
                    #[inline]
                    fn clone(&self) -> InternalBitFlags {
                        let _: ::core::clone::AssertParamIsClone<u32>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for InternalBitFlags {
                    #[inline]
                    fn eq(&self, other: &InternalBitFlags) -> bool {
                        self.0 == other.0
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::cmp::Eq for InternalBitFlags {
                    #[inline]
                    #[doc(hidden)]
                    #[no_coverage]
                    fn assert_receiver_is_total_eq(&self) -> () {
                        let _: ::core::cmp::AssertParamIsEq<u32>;
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::PartialOrd for InternalBitFlags {
                    #[inline]
                    fn partial_cmp(
                        &self,
                        other: &InternalBitFlags,
                    ) -> ::core::option::Option<::core::cmp::Ordering> {
                        ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Ord for InternalBitFlags {
                    #[inline]
                    fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                        ::core::cmp::Ord::cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::hash::Hash for InternalBitFlags {
                    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                        ::core::hash::Hash::hash(&self.0, state)
                    }
                }
                impl ::bitflags::__private::PublicFlags for ApplicationFlags {
                    type Primitive = u32;
                    type Internal = InternalBitFlags;
                }
                impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                    #[inline]
                    fn default() -> Self {
                        InternalBitFlags::empty()
                    }
                }
                impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        if self.is_empty() {
                            f.write_fmt(
                                format_args!("{0:#x}", < u32 as ::bitflags::Bits >::EMPTY),
                            )
                        } else {
                            ::bitflags::__private::core::fmt::Display::fmt(self, f)
                        }
                    }
                }
                impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::parser::to_writer(&ApplicationFlags(*self), f)
                    }
                }
                impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                    type Err = ::bitflags::parser::ParseError;
                    fn from_str(
                        s: &str,
                    ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                        ::bitflags::parser::from_str::<ApplicationFlags>(s)
                            .map(|flags| flags.0)
                    }
                }
                impl ::bitflags::__private::core::convert::AsRef<u32>
                for InternalBitFlags {
                    fn as_ref(&self) -> &u32 {
                        &self.0
                    }
                }
                impl ::bitflags::__private::core::convert::From<u32>
                for InternalBitFlags {
                    fn from(bits: u32) -> Self {
                        Self::from_bits_retain(bits)
                    }
                }
                #[allow(dead_code, deprecated, unused_attributes)]
                impl InternalBitFlags {
                    /// Returns an empty set of flags.
                    #[inline]
                    pub const fn empty() -> Self {
                        { Self(<u32 as ::bitflags::Bits>::EMPTY) }
                    }
                    /// Returns the set containing all flags.
                    #[inline]
                    pub const fn all() -> Self {
                        { Self::from_bits_truncate(<u32 as ::bitflags::Bits>::ALL) }
                    }
                    /// Returns the raw value of the flags currently stored.
                    #[inline]
                    pub const fn bits(&self) -> u32 {
                        let f = self;
                        { f.0 }
                    }
                    /// Convert from underlying bit representation, unless that
                    /// representation contains bits that do not correspond to a flag.
                    #[inline]
                    pub const fn from_bits(
                        bits: u32,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        let bits = bits;
                        {
                            let truncated = Self::from_bits_truncate(bits).0;
                            if truncated == bits {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            } else {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                    /// Convert from underlying bit representation, dropping any bits
                    /// that do not correspond to flags.
                    #[inline]
                    pub const fn from_bits_truncate(bits: u32) -> Self {
                        let bits = bits;
                        {
                            if bits == <u32 as ::bitflags::Bits>::EMPTY {
                                return Self(bits);
                            }
                            let mut truncated = <u32 as ::bitflags::Bits>::EMPTY;
                            {
                                if bits
                                    & ApplicationFlags::APPLICATION_AUTO_MODERATION_RULE_CREATE_BADGE
                                        .bits()
                                    == ApplicationFlags::APPLICATION_AUTO_MODERATION_RULE_CREATE_BADGE
                                        .bits()
                                {
                                    truncated = truncated
                                        | ApplicationFlags::APPLICATION_AUTO_MODERATION_RULE_CREATE_BADGE
                                            .bits();
                                }
                            };
                            {
                                if bits & ApplicationFlags::GATEWAY_PRESENCE.bits()
                                    == ApplicationFlags::GATEWAY_PRESENCE.bits()
                                {
                                    truncated = truncated
                                        | ApplicationFlags::GATEWAY_PRESENCE.bits();
                                }
                            };
                            {
                                if bits & ApplicationFlags::GATEWAY_PRESENCE_LIMITED.bits()
                                    == ApplicationFlags::GATEWAY_PRESENCE_LIMITED.bits()
                                {
                                    truncated = truncated
                                        | ApplicationFlags::GATEWAY_PRESENCE_LIMITED.bits();
                                }
                            };
                            {
                                if bits & ApplicationFlags::GATEWAY_GUILD_MEMBERS.bits()
                                    == ApplicationFlags::GATEWAY_GUILD_MEMBERS.bits()
                                {
                                    truncated = truncated
                                        | ApplicationFlags::GATEWAY_GUILD_MEMBERS.bits();
                                }
                            };
                            {
                                if bits
                                    & ApplicationFlags::GATEWAY_GUILD_MEMBERS_LIMITED.bits()
                                    == ApplicationFlags::GATEWAY_GUILD_MEMBERS_LIMITED.bits()
                                {
                                    truncated = truncated
                                        | ApplicationFlags::GATEWAY_GUILD_MEMBERS_LIMITED.bits();
                                }
                            };
                            {
                                if bits
                                    & ApplicationFlags::VERIFICATION_PENDING_GUILD_LIMIT.bits()
                                    == ApplicationFlags::VERIFICATION_PENDING_GUILD_LIMIT.bits()
                                {
                                    truncated = truncated
                                        | ApplicationFlags::VERIFICATION_PENDING_GUILD_LIMIT.bits();
                                }
                            };
                            {
                                if bits & ApplicationFlags::EMBEDDED.bits()
                                    == ApplicationFlags::EMBEDDED.bits()
                                {
                                    truncated = truncated | ApplicationFlags::EMBEDDED.bits();
                                }
                            };
                            {
                                if bits & ApplicationFlags::GATEWAY_MESSAGE_CONTENT.bits()
                                    == ApplicationFlags::GATEWAY_MESSAGE_CONTENT.bits()
                                {
                                    truncated = truncated
                                        | ApplicationFlags::GATEWAY_MESSAGE_CONTENT.bits();
                                }
                            };
                            {
                                if bits
                                    & ApplicationFlags::GATEWAY_MESSAGE_CONTENT_LIMITED.bits()
                                    == ApplicationFlags::GATEWAY_MESSAGE_CONTENT_LIMITED.bits()
                                {
                                    truncated = truncated
                                        | ApplicationFlags::GATEWAY_MESSAGE_CONTENT_LIMITED.bits();
                                }
                            };
                            {
                                if bits & ApplicationFlags::APPLICATION_COMMAND_BADGE.bits()
                                    == ApplicationFlags::APPLICATION_COMMAND_BADGE.bits()
                                {
                                    truncated = truncated
                                        | ApplicationFlags::APPLICATION_COMMAND_BADGE.bits();
                                }
                            };
                            Self(truncated)
                        }
                    }
                    /// Convert from underlying bit representation, preserving all
                    /// bits (even those not corresponding to a defined flag).
                    #[inline]
                    pub const fn from_bits_retain(bits: u32) -> Self {
                        let bits = bits;
                        { Self(bits) }
                    }
                    /// Get the value for a flag from its stringified name.
                    ///
                    /// Names are _case-sensitive_, so must correspond exactly to
                    /// the identifier given to the flag.
                    #[inline]
                    pub fn from_name(
                        name: &str,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        let name = name;
                        {
                            {
                                if name == "APPLICATION_AUTO_MODERATION_RULE_CREATE_BADGE" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(
                                            ApplicationFlags::APPLICATION_AUTO_MODERATION_RULE_CREATE_BADGE
                                                .bits(),
                                        ),
                                    );
                                }
                            };
                            {
                                if name == "GATEWAY_PRESENCE" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ApplicationFlags::GATEWAY_PRESENCE.bits()),
                                    );
                                }
                            };
                            {
                                if name == "GATEWAY_PRESENCE_LIMITED" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ApplicationFlags::GATEWAY_PRESENCE_LIMITED.bits()),
                                    );
                                }
                            };
                            {
                                if name == "GATEWAY_GUILD_MEMBERS" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ApplicationFlags::GATEWAY_GUILD_MEMBERS.bits()),
                                    );
                                }
                            };
                            {
                                if name == "GATEWAY_GUILD_MEMBERS_LIMITED" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ApplicationFlags::GATEWAY_GUILD_MEMBERS_LIMITED.bits()),
                                    );
                                }
                            };
                            {
                                if name == "VERIFICATION_PENDING_GUILD_LIMIT" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(
                                            ApplicationFlags::VERIFICATION_PENDING_GUILD_LIMIT.bits(),
                                        ),
                                    );
                                }
                            };
                            {
                                if name == "EMBEDDED" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ApplicationFlags::EMBEDDED.bits()),
                                    );
                                }
                            };
                            {
                                if name == "GATEWAY_MESSAGE_CONTENT" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ApplicationFlags::GATEWAY_MESSAGE_CONTENT.bits()),
                                    );
                                }
                            };
                            {
                                if name == "GATEWAY_MESSAGE_CONTENT_LIMITED" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(
                                            ApplicationFlags::GATEWAY_MESSAGE_CONTENT_LIMITED.bits(),
                                        ),
                                    );
                                }
                            };
                            {
                                if name == "APPLICATION_COMMAND_BADGE" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ApplicationFlags::APPLICATION_COMMAND_BADGE.bits()),
                                    );
                                }
                            };
                            let _ = name;
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                    /// Returns `true` if no flags are currently stored.
                    #[inline]
                    pub const fn is_empty(&self) -> bool {
                        let f = self;
                        { f.0 == Self::empty().0 }
                    }
                    /// Returns `true` if all flags are currently set.
                    #[inline]
                    pub const fn is_all(&self) -> bool {
                        let f = self;
                        { Self::all().0 | f.0 == f.0 }
                    }
                    /// Returns `true` if there are flags common to both `self` and `other`.
                    #[inline]
                    pub const fn intersects(&self, other: Self) -> bool {
                        let f = self;
                        let other = other;
                        { !(Self(f.0 & other.0)).is_empty() }
                    }
                    /// Returns `true` if all of the flags in `other` are contained within `self`.
                    #[inline]
                    pub const fn contains(&self, other: Self) -> bool {
                        let f = self;
                        let other = other;
                        { (f.0 & other.0) == other.0 }
                    }
                    /// Inserts the specified flags in-place.
                    #[inline]
                    pub fn insert(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        {
                            f.0 = f.0 | other.0;
                        }
                    }
                    /// Removes the specified flags in-place.
                    #[inline]
                    pub fn remove(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        {
                            f.0 = f.0 & !other.0;
                        }
                    }
                    /// Toggles the specified flags in-place.
                    #[inline]
                    pub fn toggle(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        {
                            f.0 = f.0 ^ other.0;
                        }
                    }
                    /// Inserts or removes the specified flags depending on the passed value.
                    #[inline]
                    pub fn set(&mut self, other: Self, value: bool) {
                        let f = self;
                        let other = other;
                        let value = value;
                        {
                            if value {
                                f.insert(other);
                            } else {
                                f.remove(other);
                            }
                        }
                    }
                    /// Returns the intersection between the flags in `self` and
                    /// `other`.
                    ///
                    /// Specifically, the returned set contains only the flags which are
                    /// present in *both* `self` *and* `other`.
                    ///
                    /// This is equivalent to using the `&` operator (e.g.
                    /// [`ops::BitAnd`]), as in `flags & other`.
                    ///
                    /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                    #[inline]
                    #[must_use]
                    pub const fn intersection(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0 & other.0) }
                    }
                    /// Returns the union of between the flags in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains all flags which are
                    /// present in *either* `self` *or* `other`, including any which are
                    /// present in both (see [`Self::symmetric_difference`] if that
                    /// is undesirable).
                    ///
                    /// This is equivalent to using the `|` operator (e.g.
                    /// [`ops::BitOr`]), as in `flags | other`.
                    ///
                    /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                    #[inline]
                    #[must_use]
                    pub const fn union(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0 | other.0) }
                    }
                    /// Returns the difference between the flags in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains all flags present in
                    /// `self`, except for the ones present in `other`.
                    ///
                    /// It is also conceptually equivalent to the "bit-clear" operation:
                    /// `flags & !other` (and this syntax is also supported).
                    ///
                    /// This is equivalent to using the `-` operator (e.g.
                    /// [`ops::Sub`]), as in `flags - other`.
                    ///
                    /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                    #[inline]
                    #[must_use]
                    pub const fn difference(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0 & !other.0) }
                    }
                    /// Returns the [symmetric difference][sym-diff] between the flags
                    /// in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains the flags present which
                    /// are present in `self` or `other`, but that are not present in
                    /// both. Equivalently, it contains the flags present in *exactly
                    /// one* of the sets `self` and `other`.
                    ///
                    /// This is equivalent to using the `^` operator (e.g.
                    /// [`ops::BitXor`]), as in `flags ^ other`.
                    ///
                    /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                    /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                    #[inline]
                    #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0 ^ other.0) }
                    }
                    /// Returns the complement of this set of flags.
                    ///
                    /// Specifically, the returned set contains all the flags which are
                    /// not set in `self`, but which are allowed for this type.
                    ///
                    /// Alternatively, it can be thought of as the set difference
                    /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                    ///
                    /// This is equivalent to using the `!` operator (e.g.
                    /// [`ops::Not`]), as in `!flags`.
                    ///
                    /// [`Self::all()`]: Self::all
                    /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                    #[inline]
                    #[must_use]
                    pub const fn complement(self) -> Self {
                        let f = self;
                        { Self::from_bits_truncate(!f.0) }
                    }
                }
                impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::Binary::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::Octal::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::LowerHex::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::UpperHex::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                    type Output = Self;
                    /// Returns the union of the two sets of flags.
                    #[inline]
                    fn bitor(self, other: InternalBitFlags) -> Self {
                        self.union(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                    /// Adds the set of flags.
                    #[inline]
                    fn bitor_assign(&mut self, other: Self) {
                        self.0 = self.0 | other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                    type Output = Self;
                    /// Returns the left flags, but with all the right flags toggled.
                    #[inline]
                    fn bitxor(self, other: Self) -> Self {
                        self.symmetric_difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitXorAssign
                for InternalBitFlags {
                    /// Toggles the set of flags.
                    #[inline]
                    fn bitxor_assign(&mut self, other: Self) {
                        self.0 = self.0 ^ other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                    type Output = Self;
                    /// Returns the intersection between the two sets of flags.
                    #[inline]
                    fn bitand(self, other: Self) -> Self {
                        self.intersection(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitAndAssign
                for InternalBitFlags {
                    /// Disables all flags disabled in the set.
                    #[inline]
                    fn bitand_assign(&mut self, other: Self) {
                        self.0 = self.0 & other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                    type Output = Self;
                    /// Returns the set difference of the two sets of flags.
                    #[inline]
                    fn sub(self, other: Self) -> Self {
                        self.difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                    /// Disables all flags enabled in the set.
                    #[inline]
                    fn sub_assign(&mut self, other: Self) {
                        self.0 = self.0 & !other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                    type Output = Self;
                    /// Returns the complement of this set of flags.
                    #[inline]
                    fn not(self) -> Self {
                        self.complement()
                    }
                }
                impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
                for InternalBitFlags {
                    fn extend<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(&mut self, iterator: T) {
                        for item in iterator {
                            self.insert(item)
                        }
                    }
                }
                impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
                for InternalBitFlags {
                    fn from_iter<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(iterator: T) -> Self {
                        use ::bitflags::__private::core::iter::Extend;
                        let mut result = Self::empty();
                        result.extend(iterator);
                        result
                    }
                }
                impl InternalBitFlags {
                    /// Iterate over enabled flag values.
                    #[inline]
                    pub const fn iter(
                        &self,
                    ) -> ::bitflags::iter::Iter<ApplicationFlags> {
                        ::bitflags::iter::Iter::__private_const_new(
                            <ApplicationFlags as ::bitflags::Flags>::FLAGS,
                            ApplicationFlags::from_bits_retain(self.bits()),
                            ApplicationFlags::from_bits_retain(self.bits()),
                        )
                    }
                    /// Iterate over enabled flag values with their stringified names.
                    #[inline]
                    pub const fn iter_names(
                        &self,
                    ) -> ::bitflags::iter::IterNames<ApplicationFlags> {
                        ::bitflags::iter::IterNames::__private_const_new(
                            <ApplicationFlags as ::bitflags::Flags>::FLAGS,
                            ApplicationFlags::from_bits_retain(self.bits()),
                            ApplicationFlags::from_bits_retain(self.bits()),
                        )
                    }
                }
                impl ::bitflags::__private::core::iter::IntoIterator
                for InternalBitFlags {
                    type Item = ApplicationFlags;
                    type IntoIter = ::bitflags::iter::Iter<ApplicationFlags>;
                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }
                impl InternalBitFlags {
                    /// Returns a mutable reference to the raw value of the flags currently stored.
                    #[inline]
                    pub fn bits_mut(&mut self) -> &mut u32 {
                        &mut self.0
                    }
                }
                #[allow(dead_code, deprecated, unused_attributes)]
                impl ApplicationFlags {
                    /// Returns an empty set of flags.
                    #[inline]
                    pub const fn empty() -> Self {
                        { Self(InternalBitFlags::empty()) }
                    }
                    /// Returns the set containing all flags.
                    #[inline]
                    pub const fn all() -> Self {
                        { Self(InternalBitFlags::all()) }
                    }
                    /// Returns the raw value of the flags currently stored.
                    #[inline]
                    pub const fn bits(&self) -> u32 {
                        let f = self;
                        { f.0.bits() }
                    }
                    /// Convert from underlying bit representation, unless that
                    /// representation contains bits that do not correspond to a flag.
                    #[inline]
                    pub const fn from_bits(
                        bits: u32,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        let bits = bits;
                        {
                            match InternalBitFlags::from_bits(bits) {
                                ::bitflags::__private::core::option::Option::Some(bits) => {
                                    ::bitflags::__private::core::option::Option::Some(
                                        Self(bits),
                                    )
                                }
                                ::bitflags::__private::core::option::Option::None => {
                                    ::bitflags::__private::core::option::Option::None
                                }
                            }
                        }
                    }
                    /// Convert from underlying bit representation, dropping any bits
                    /// that do not correspond to flags.
                    #[inline]
                    pub const fn from_bits_truncate(bits: u32) -> Self {
                        let bits = bits;
                        { Self(InternalBitFlags::from_bits_truncate(bits)) }
                    }
                    /// Convert from underlying bit representation, preserving all
                    /// bits (even those not corresponding to a defined flag).
                    #[inline]
                    pub const fn from_bits_retain(bits: u32) -> Self {
                        let bits = bits;
                        { Self(InternalBitFlags::from_bits_retain(bits)) }
                    }
                    /// Get the value for a flag from its stringified name.
                    ///
                    /// Names are _case-sensitive_, so must correspond exactly to
                    /// the identifier given to the flag.
                    #[inline]
                    pub fn from_name(
                        name: &str,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        let name = name;
                        {
                            match InternalBitFlags::from_name(name) {
                                ::bitflags::__private::core::option::Option::Some(bits) => {
                                    ::bitflags::__private::core::option::Option::Some(
                                        Self(bits),
                                    )
                                }
                                ::bitflags::__private::core::option::Option::None => {
                                    ::bitflags::__private::core::option::Option::None
                                }
                            }
                        }
                    }
                    /// Returns `true` if no flags are currently stored.
                    #[inline]
                    pub const fn is_empty(&self) -> bool {
                        let f = self;
                        { f.0.is_empty() }
                    }
                    /// Returns `true` if all flags are currently set.
                    #[inline]
                    pub const fn is_all(&self) -> bool {
                        let f = self;
                        { f.0.is_all() }
                    }
                    /// Returns `true` if there are flags common to both `self` and `other`.
                    #[inline]
                    pub const fn intersects(&self, other: Self) -> bool {
                        let f = self;
                        let other = other;
                        { f.0.intersects(other.0) }
                    }
                    /// Returns `true` if all of the flags in `other` are contained within `self`.
                    #[inline]
                    pub const fn contains(&self, other: Self) -> bool {
                        let f = self;
                        let other = other;
                        { f.0.contains(other.0) }
                    }
                    /// Inserts the specified flags in-place.
                    #[inline]
                    pub fn insert(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        { f.0.insert(other.0) }
                    }
                    /// Removes the specified flags in-place.
                    #[inline]
                    pub fn remove(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        { f.0.remove(other.0) }
                    }
                    /// Toggles the specified flags in-place.
                    #[inline]
                    pub fn toggle(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        { f.0.toggle(other.0) }
                    }
                    /// Inserts or removes the specified flags depending on the passed value.
                    #[inline]
                    pub fn set(&mut self, other: Self, value: bool) {
                        let f = self;
                        let other = other;
                        let value = value;
                        { f.0.set(other.0, value) }
                    }
                    /// Returns the intersection between the flags in `self` and
                    /// `other`.
                    ///
                    /// Specifically, the returned set contains only the flags which are
                    /// present in *both* `self` *and* `other`.
                    ///
                    /// This is equivalent to using the `&` operator (e.g.
                    /// [`ops::BitAnd`]), as in `flags & other`.
                    ///
                    /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                    #[inline]
                    #[must_use]
                    pub const fn intersection(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0.intersection(other.0)) }
                    }
                    /// Returns the union of between the flags in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains all flags which are
                    /// present in *either* `self` *or* `other`, including any which are
                    /// present in both (see [`Self::symmetric_difference`] if that
                    /// is undesirable).
                    ///
                    /// This is equivalent to using the `|` operator (e.g.
                    /// [`ops::BitOr`]), as in `flags | other`.
                    ///
                    /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                    #[inline]
                    #[must_use]
                    pub const fn union(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0.union(other.0)) }
                    }
                    /// Returns the difference between the flags in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains all flags present in
                    /// `self`, except for the ones present in `other`.
                    ///
                    /// It is also conceptually equivalent to the "bit-clear" operation:
                    /// `flags & !other` (and this syntax is also supported).
                    ///
                    /// This is equivalent to using the `-` operator (e.g.
                    /// [`ops::Sub`]), as in `flags - other`.
                    ///
                    /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                    #[inline]
                    #[must_use]
                    pub const fn difference(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0.difference(other.0)) }
                    }
                    /// Returns the [symmetric difference][sym-diff] between the flags
                    /// in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains the flags present which
                    /// are present in `self` or `other`, but that are not present in
                    /// both. Equivalently, it contains the flags present in *exactly
                    /// one* of the sets `self` and `other`.
                    ///
                    /// This is equivalent to using the `^` operator (e.g.
                    /// [`ops::BitXor`]), as in `flags ^ other`.
                    ///
                    /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                    /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                    #[inline]
                    #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0.symmetric_difference(other.0)) }
                    }
                    /// Returns the complement of this set of flags.
                    ///
                    /// Specifically, the returned set contains all the flags which are
                    /// not set in `self`, but which are allowed for this type.
                    ///
                    /// Alternatively, it can be thought of as the set difference
                    /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                    ///
                    /// This is equivalent to using the `!` operator (e.g.
                    /// [`ops::Not`]), as in `!flags`.
                    ///
                    /// [`Self::all()`]: Self::all
                    /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                    #[inline]
                    #[must_use]
                    pub const fn complement(self) -> Self {
                        let f = self;
                        { Self(f.0.complement()) }
                    }
                }
                impl ::bitflags::__private::core::fmt::Binary for ApplicationFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::Binary::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::Octal for ApplicationFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::Octal::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::LowerHex for ApplicationFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::LowerHex::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::UpperHex for ApplicationFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::UpperHex::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOr for ApplicationFlags {
                    type Output = Self;
                    /// Returns the union of the two sets of flags.
                    #[inline]
                    fn bitor(self, other: ApplicationFlags) -> Self {
                        self.union(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOrAssign for ApplicationFlags {
                    /// Adds the set of flags.
                    #[inline]
                    fn bitor_assign(&mut self, other: Self) {
                        self.0 = self.0 | other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::BitXor for ApplicationFlags {
                    type Output = Self;
                    /// Returns the left flags, but with all the right flags toggled.
                    #[inline]
                    fn bitxor(self, other: Self) -> Self {
                        self.symmetric_difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitXorAssign
                for ApplicationFlags {
                    /// Toggles the set of flags.
                    #[inline]
                    fn bitxor_assign(&mut self, other: Self) {
                        self.0 = self.0 ^ other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::BitAnd for ApplicationFlags {
                    type Output = Self;
                    /// Returns the intersection between the two sets of flags.
                    #[inline]
                    fn bitand(self, other: Self) -> Self {
                        self.intersection(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitAndAssign
                for ApplicationFlags {
                    /// Disables all flags disabled in the set.
                    #[inline]
                    fn bitand_assign(&mut self, other: Self) {
                        self.0 = self.0 & other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::Sub for ApplicationFlags {
                    type Output = Self;
                    /// Returns the set difference of the two sets of flags.
                    #[inline]
                    fn sub(self, other: Self) -> Self {
                        self.difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::SubAssign for ApplicationFlags {
                    /// Disables all flags enabled in the set.
                    #[inline]
                    fn sub_assign(&mut self, other: Self) {
                        self.0 = self.0 & !other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::Not for ApplicationFlags {
                    type Output = Self;
                    /// Returns the complement of this set of flags.
                    #[inline]
                    fn not(self) -> Self {
                        self.complement()
                    }
                }
                impl ::bitflags::__private::core::iter::Extend<ApplicationFlags>
                for ApplicationFlags {
                    fn extend<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(&mut self, iterator: T) {
                        for item in iterator {
                            self.insert(item)
                        }
                    }
                }
                impl ::bitflags::__private::core::iter::FromIterator<ApplicationFlags>
                for ApplicationFlags {
                    fn from_iter<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(iterator: T) -> Self {
                        use ::bitflags::__private::core::iter::Extend;
                        let mut result = Self::empty();
                        result.extend(iterator);
                        result
                    }
                }
                impl ApplicationFlags {
                    /// Iterate over enabled flag values.
                    #[inline]
                    pub const fn iter(
                        &self,
                    ) -> ::bitflags::iter::Iter<ApplicationFlags> {
                        ::bitflags::iter::Iter::__private_const_new(
                            <ApplicationFlags as ::bitflags::Flags>::FLAGS,
                            ApplicationFlags::from_bits_retain(self.bits()),
                            ApplicationFlags::from_bits_retain(self.bits()),
                        )
                    }
                    /// Iterate over enabled flag values with their stringified names.
                    #[inline]
                    pub const fn iter_names(
                        &self,
                    ) -> ::bitflags::iter::IterNames<ApplicationFlags> {
                        ::bitflags::iter::IterNames::__private_const_new(
                            <ApplicationFlags as ::bitflags::Flags>::FLAGS,
                            ApplicationFlags::from_bits_retain(self.bits()),
                            ApplicationFlags::from_bits_retain(self.bits()),
                        )
                    }
                }
                impl ::bitflags::__private::core::iter::IntoIterator
                for ApplicationFlags {
                    type Item = ApplicationFlags;
                    type IntoIter = ::bitflags::iter::Iter<ApplicationFlags>;
                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }
            };
            impl<'de> ::serde::Deserialize<'de> for ApplicationFlags {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    <u32>::deserialize(deserializer).map(Self::from_bits_truncate)
                }
            }
            impl ::serde::Serialize for ApplicationFlags {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    self.bits().serialize(serializer)
                }
            }
        }
        mod install_params {
            use crate::{misc::Permissions, oauth::OAuthScope};
            use serde::{Deserialize, Serialize};
            pub struct InstallParams {
                pub scopes: Vec<OAuthScope>,
                pub permissions: Permissions,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for InstallParams {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "InstallParams",
                        "scopes",
                        &self.scopes,
                        "permissions",
                        &&self.permissions,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for InstallParams {
                #[inline]
                fn clone(&self) -> InstallParams {
                    InstallParams {
                        scopes: ::core::clone::Clone::clone(&self.scopes),
                        permissions: ::core::clone::Clone::clone(&self.permissions),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for InstallParams {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for InstallParams {
                #[inline]
                fn eq(&self, other: &InstallParams) -> bool {
                    self.scopes == other.scopes && self.permissions == other.permissions
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for InstallParams {}
            #[automatically_derived]
            impl ::core::cmp::Eq for InstallParams {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Vec<OAuthScope>>;
                    let _: ::core::cmp::AssertParamIsEq<Permissions>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for InstallParams {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.scopes, state);
                    ::core::hash::Hash::hash(&self.permissions, state)
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for InstallParams {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "scopes" => _serde::__private::Ok(__Field::__field0),
                                    "permissions" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"scopes" => _serde::__private::Ok(__Field::__field0),
                                    b"permissions" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<InstallParams>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = InstallParams;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct InstallParams",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    Vec<OAuthScope>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct InstallParams with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match match _serde::de::SeqAccess::next_element::<
                                    Permissions,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct InstallParams with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(InstallParams {
                                    scopes: __field0,
                                    permissions: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    Vec<OAuthScope>,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Permissions> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = match _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("scopes"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Vec<OAuthScope>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "permissions",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Permissions,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("scopes") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("permissions") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::__private::Ok(InstallParams {
                                    scopes: __field0,
                                    permissions: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "scopes",
                            "permissions",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "InstallParams",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<InstallParams>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for InstallParams {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "InstallParams",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "scopes",
                            &self.scopes,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "permissions",
                            &self.permissions,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        }
        pub use flags::*;
        pub use install_params::*;
        pub struct PartialApplication {
            pub id: ApplicationId,
            pub flags: ApplicationFlags,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PartialApplication {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "PartialApplication",
                    "id",
                    &self.id,
                    "flags",
                    &&self.flags,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PartialApplication {
            #[inline]
            fn clone(&self) -> PartialApplication {
                PartialApplication {
                    id: ::core::clone::Clone::clone(&self.id),
                    flags: ::core::clone::Clone::clone(&self.flags),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PartialApplication {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PartialApplication {
            #[inline]
            fn eq(&self, other: &PartialApplication) -> bool {
                self.id == other.id && self.flags == other.flags
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for PartialApplication {}
        #[automatically_derived]
        impl ::core::cmp::Eq for PartialApplication {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ApplicationId>;
                let _: ::core::cmp::AssertParamIsEq<ApplicationFlags>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PartialApplication {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.id, state);
                ::core::hash::Hash::hash(&self.flags, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PartialApplication {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "flags" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"flags" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PartialApplication>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PartialApplication;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PartialApplication",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                ApplicationId,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct PartialApplication with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                ApplicationFlags,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct PartialApplication with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(PartialApplication {
                                id: __field0,
                                flags: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ApplicationId> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                ApplicationFlags,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = match _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ApplicationId,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("flags"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ApplicationFlags,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("id") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("flags") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(PartialApplication {
                                id: __field0,
                                flags: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["id", "flags"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PartialApplication",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<PartialApplication>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PartialApplication {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "PartialApplication",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "flags",
                        &self.flags,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        pub struct Application {
            pub id: ApplicationId,
            pub name: String,
            pub icon: Option<ImageHash>,
            pub description: String,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub rpc_origins: Option<Vec<String>>,
            pub bot_public: bool,
            pub bot_require_code_grant: bool,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub terms_of_service_url: Option<String>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub privacy_policy_url: Option<String>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub owner: Option<User>,
            pub verify_key: String,
            pub team: Option<Team>,
            pub guild_id: Option<GuildId>,
            pub primary_sku_id: Option<GameSkuId>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub slug: Option<String>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub cover_image: Option<String>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub flags: Option<ApplicationFlags>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub install_params: Option<InstallParams>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub custom_install_url: Option<String>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub role_connections_verification_url: Option<String>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Application {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "name",
                    "icon",
                    "description",
                    "rpc_origins",
                    "bot_public",
                    "bot_require_code_grant",
                    "terms_of_service_url",
                    "privacy_policy_url",
                    "owner",
                    "verify_key",
                    "team",
                    "guild_id",
                    "primary_sku_id",
                    "slug",
                    "cover_image",
                    "flags",
                    "install_params",
                    "custom_install_url",
                    "role_connections_verification_url",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.name,
                    &self.icon,
                    &self.description,
                    &self.rpc_origins,
                    &self.bot_public,
                    &self.bot_require_code_grant,
                    &self.terms_of_service_url,
                    &self.privacy_policy_url,
                    &self.owner,
                    &self.verify_key,
                    &self.team,
                    &self.guild_id,
                    &self.primary_sku_id,
                    &self.slug,
                    &self.cover_image,
                    &self.flags,
                    &self.install_params,
                    &self.custom_install_url,
                    &&self.role_connections_verification_url,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Application",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Application {
            #[inline]
            fn clone(&self) -> Application {
                Application {
                    id: ::core::clone::Clone::clone(&self.id),
                    name: ::core::clone::Clone::clone(&self.name),
                    icon: ::core::clone::Clone::clone(&self.icon),
                    description: ::core::clone::Clone::clone(&self.description),
                    rpc_origins: ::core::clone::Clone::clone(&self.rpc_origins),
                    bot_public: ::core::clone::Clone::clone(&self.bot_public),
                    bot_require_code_grant: ::core::clone::Clone::clone(
                        &self.bot_require_code_grant,
                    ),
                    terms_of_service_url: ::core::clone::Clone::clone(
                        &self.terms_of_service_url,
                    ),
                    privacy_policy_url: ::core::clone::Clone::clone(
                        &self.privacy_policy_url,
                    ),
                    owner: ::core::clone::Clone::clone(&self.owner),
                    verify_key: ::core::clone::Clone::clone(&self.verify_key),
                    team: ::core::clone::Clone::clone(&self.team),
                    guild_id: ::core::clone::Clone::clone(&self.guild_id),
                    primary_sku_id: ::core::clone::Clone::clone(&self.primary_sku_id),
                    slug: ::core::clone::Clone::clone(&self.slug),
                    cover_image: ::core::clone::Clone::clone(&self.cover_image),
                    flags: ::core::clone::Clone::clone(&self.flags),
                    install_params: ::core::clone::Clone::clone(&self.install_params),
                    custom_install_url: ::core::clone::Clone::clone(
                        &self.custom_install_url,
                    ),
                    role_connections_verification_url: ::core::clone::Clone::clone(
                        &self.role_connections_verification_url,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Application {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Application {
            #[inline]
            fn eq(&self, other: &Application) -> bool {
                self.id == other.id && self.name == other.name && self.icon == other.icon
                    && self.description == other.description
                    && self.rpc_origins == other.rpc_origins
                    && self.bot_public == other.bot_public
                    && self.bot_require_code_grant == other.bot_require_code_grant
                    && self.terms_of_service_url == other.terms_of_service_url
                    && self.privacy_policy_url == other.privacy_policy_url
                    && self.owner == other.owner && self.verify_key == other.verify_key
                    && self.team == other.team && self.guild_id == other.guild_id
                    && self.primary_sku_id == other.primary_sku_id
                    && self.slug == other.slug && self.cover_image == other.cover_image
                    && self.flags == other.flags
                    && self.install_params == other.install_params
                    && self.custom_install_url == other.custom_install_url
                    && self.role_connections_verification_url
                        == other.role_connections_verification_url
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Application {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Application {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ApplicationId>;
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<Option<ImageHash>>;
                let _: ::core::cmp::AssertParamIsEq<Option<Vec<String>>>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Option<User>>;
                let _: ::core::cmp::AssertParamIsEq<Option<Team>>;
                let _: ::core::cmp::AssertParamIsEq<Option<GuildId>>;
                let _: ::core::cmp::AssertParamIsEq<Option<GameSkuId>>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Option<ApplicationFlags>>;
                let _: ::core::cmp::AssertParamIsEq<Option<InstallParams>>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Application {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.id, state);
                ::core::hash::Hash::hash(&self.name, state);
                ::core::hash::Hash::hash(&self.icon, state);
                ::core::hash::Hash::hash(&self.description, state);
                ::core::hash::Hash::hash(&self.rpc_origins, state);
                ::core::hash::Hash::hash(&self.bot_public, state);
                ::core::hash::Hash::hash(&self.bot_require_code_grant, state);
                ::core::hash::Hash::hash(&self.terms_of_service_url, state);
                ::core::hash::Hash::hash(&self.privacy_policy_url, state);
                ::core::hash::Hash::hash(&self.owner, state);
                ::core::hash::Hash::hash(&self.verify_key, state);
                ::core::hash::Hash::hash(&self.team, state);
                ::core::hash::Hash::hash(&self.guild_id, state);
                ::core::hash::Hash::hash(&self.primary_sku_id, state);
                ::core::hash::Hash::hash(&self.slug, state);
                ::core::hash::Hash::hash(&self.cover_image, state);
                ::core::hash::Hash::hash(&self.flags, state);
                ::core::hash::Hash::hash(&self.install_params, state);
                ::core::hash::Hash::hash(&self.custom_install_url, state);
                ::core::hash::Hash::hash(&self.role_connections_verification_url, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Application {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                        __field13,
                        __field14,
                        __field15,
                        __field16,
                        __field17,
                        __field18,
                        __field19,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                12u64 => _serde::__private::Ok(__Field::__field12),
                                13u64 => _serde::__private::Ok(__Field::__field13),
                                14u64 => _serde::__private::Ok(__Field::__field14),
                                15u64 => _serde::__private::Ok(__Field::__field15),
                                16u64 => _serde::__private::Ok(__Field::__field16),
                                17u64 => _serde::__private::Ok(__Field::__field17),
                                18u64 => _serde::__private::Ok(__Field::__field18),
                                19u64 => _serde::__private::Ok(__Field::__field19),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "name" => _serde::__private::Ok(__Field::__field1),
                                "icon" => _serde::__private::Ok(__Field::__field2),
                                "description" => _serde::__private::Ok(__Field::__field3),
                                "rpc_origins" => _serde::__private::Ok(__Field::__field4),
                                "bot_public" => _serde::__private::Ok(__Field::__field5),
                                "bot_require_code_grant" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                "terms_of_service_url" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                "privacy_policy_url" => {
                                    _serde::__private::Ok(__Field::__field8)
                                }
                                "owner" => _serde::__private::Ok(__Field::__field9),
                                "verify_key" => _serde::__private::Ok(__Field::__field10),
                                "team" => _serde::__private::Ok(__Field::__field11),
                                "guild_id" => _serde::__private::Ok(__Field::__field12),
                                "primary_sku_id" => {
                                    _serde::__private::Ok(__Field::__field13)
                                }
                                "slug" => _serde::__private::Ok(__Field::__field14),
                                "cover_image" => _serde::__private::Ok(__Field::__field15),
                                "flags" => _serde::__private::Ok(__Field::__field16),
                                "install_params" => {
                                    _serde::__private::Ok(__Field::__field17)
                                }
                                "custom_install_url" => {
                                    _serde::__private::Ok(__Field::__field18)
                                }
                                "role_connections_verification_url" => {
                                    _serde::__private::Ok(__Field::__field19)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"name" => _serde::__private::Ok(__Field::__field1),
                                b"icon" => _serde::__private::Ok(__Field::__field2),
                                b"description" => _serde::__private::Ok(__Field::__field3),
                                b"rpc_origins" => _serde::__private::Ok(__Field::__field4),
                                b"bot_public" => _serde::__private::Ok(__Field::__field5),
                                b"bot_require_code_grant" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                b"terms_of_service_url" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                b"privacy_policy_url" => {
                                    _serde::__private::Ok(__Field::__field8)
                                }
                                b"owner" => _serde::__private::Ok(__Field::__field9),
                                b"verify_key" => _serde::__private::Ok(__Field::__field10),
                                b"team" => _serde::__private::Ok(__Field::__field11),
                                b"guild_id" => _serde::__private::Ok(__Field::__field12),
                                b"primary_sku_id" => {
                                    _serde::__private::Ok(__Field::__field13)
                                }
                                b"slug" => _serde::__private::Ok(__Field::__field14),
                                b"cover_image" => _serde::__private::Ok(__Field::__field15),
                                b"flags" => _serde::__private::Ok(__Field::__field16),
                                b"install_params" => {
                                    _serde::__private::Ok(__Field::__field17)
                                }
                                b"custom_install_url" => {
                                    _serde::__private::Ok(__Field::__field18)
                                }
                                b"role_connections_verification_url" => {
                                    _serde::__private::Ok(__Field::__field19)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Application>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Application;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Application",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                ApplicationId,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<ImageHash>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Option<Vec<String>>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field9 = match match _serde::de::SeqAccess::next_element::<
                                Option<User>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field10 = match match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field11 = match match _serde::de::SeqAccess::next_element::<
                                Option<Team>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            11usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field12 = match match _serde::de::SeqAccess::next_element::<
                                Option<GuildId>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            12usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field13 = match match _serde::de::SeqAccess::next_element::<
                                Option<GameSkuId>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            13usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field14 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            14usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field15 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            15usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field16 = match match _serde::de::SeqAccess::next_element::<
                                Option<ApplicationFlags>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            16usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field17 = match match _serde::de::SeqAccess::next_element::<
                                Option<InstallParams>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            17usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field18 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            18usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            let __field19 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            19usize,
                                            &"struct Application with 20 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Application {
                                id: __field0,
                                name: __field1,
                                icon: __field2,
                                description: __field3,
                                rpc_origins: __field4,
                                bot_public: __field5,
                                bot_require_code_grant: __field6,
                                terms_of_service_url: __field7,
                                privacy_policy_url: __field8,
                                owner: __field9,
                                verify_key: __field10,
                                team: __field11,
                                guild_id: __field12,
                                primary_sku_id: __field13,
                                slug: __field14,
                                cover_image: __field15,
                                flags: __field16,
                                install_params: __field17,
                                custom_install_url: __field18,
                                role_connections_verification_url: __field19,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ApplicationId> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<ImageHash>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                Option<Vec<String>>,
                            > = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field9: _serde::__private::Option<Option<User>> = _serde::__private::None;
                            let mut __field10: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field11: _serde::__private::Option<Option<Team>> = _serde::__private::None;
                            let mut __field12: _serde::__private::Option<
                                Option<GuildId>,
                            > = _serde::__private::None;
                            let mut __field13: _serde::__private::Option<
                                Option<GameSkuId>,
                            > = _serde::__private::None;
                            let mut __field14: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field15: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field16: _serde::__private::Option<
                                Option<ApplicationFlags>,
                            > = _serde::__private::None;
                            let mut __field17: _serde::__private::Option<
                                Option<InstallParams>,
                            > = _serde::__private::None;
                            let mut __field18: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field19: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = match _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ApplicationId,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                String,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("icon"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ImageHash>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "description",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                String,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "rpc_origins",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<Vec<String>>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "bot_public",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                bool,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "bot_require_code_grant",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                bool,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "terms_of_service_url",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "privacy_policy_url",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::__private::Option::is_some(&__field9) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("owner"),
                                            );
                                        }
                                        __field9 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<User>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field10 => {
                                        if _serde::__private::Option::is_some(&__field10) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "verify_key",
                                                ),
                                            );
                                        }
                                        __field10 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                String,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field11 => {
                                        if _serde::__private::Option::is_some(&__field11) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("team"),
                                            );
                                        }
                                        __field11 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<Team>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field12 => {
                                        if _serde::__private::Option::is_some(&__field12) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "guild_id",
                                                ),
                                            );
                                        }
                                        __field12 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<GuildId>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field13 => {
                                        if _serde::__private::Option::is_some(&__field13) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "primary_sku_id",
                                                ),
                                            );
                                        }
                                        __field13 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<GameSkuId>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field14 => {
                                        if _serde::__private::Option::is_some(&__field14) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("slug"),
                                            );
                                        }
                                        __field14 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field15 => {
                                        if _serde::__private::Option::is_some(&__field15) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "cover_image",
                                                ),
                                            );
                                        }
                                        __field15 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field16 => {
                                        if _serde::__private::Option::is_some(&__field16) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("flags"),
                                            );
                                        }
                                        __field16 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ApplicationFlags>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field17 => {
                                        if _serde::__private::Option::is_some(&__field17) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "install_params",
                                                ),
                                            );
                                        }
                                        __field17 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<InstallParams>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field18 => {
                                        if _serde::__private::Option::is_some(&__field18) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "custom_install_url",
                                                ),
                                            );
                                        }
                                        __field18 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field19 => {
                                        if _serde::__private::Option::is_some(&__field19) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "role_connections_verification_url",
                                                ),
                                            );
                                        }
                                        __field19 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("id") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("name") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("icon") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("description") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("rpc_origins") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("bot_public") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "bot_require_code_grant",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "terms_of_service_url",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "privacy_policy_url",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::__private::Some(__field9) => __field9,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("owner") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field10 = match __field10 {
                                _serde::__private::Some(__field10) => __field10,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("verify_key") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field11 = match __field11 {
                                _serde::__private::Some(__field11) => __field11,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("team") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field12 = match __field12 {
                                _serde::__private::Some(__field12) => __field12,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("guild_id") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field13 = match __field13 {
                                _serde::__private::Some(__field13) => __field13,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "primary_sku_id",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field14 = match __field14 {
                                _serde::__private::Some(__field14) => __field14,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("slug") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field15 = match __field15 {
                                _serde::__private::Some(__field15) => __field15,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("cover_image") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field16 = match __field16 {
                                _serde::__private::Some(__field16) => __field16,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("flags") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field17 = match __field17 {
                                _serde::__private::Some(__field17) => __field17,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "install_params",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field18 = match __field18 {
                                _serde::__private::Some(__field18) => __field18,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "custom_install_url",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field19 = match __field19 {
                                _serde::__private::Some(__field19) => __field19,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "role_connections_verification_url",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Application {
                                id: __field0,
                                name: __field1,
                                icon: __field2,
                                description: __field3,
                                rpc_origins: __field4,
                                bot_public: __field5,
                                bot_require_code_grant: __field6,
                                terms_of_service_url: __field7,
                                privacy_policy_url: __field8,
                                owner: __field9,
                                verify_key: __field10,
                                team: __field11,
                                guild_id: __field12,
                                primary_sku_id: __field13,
                                slug: __field14,
                                cover_image: __field15,
                                flags: __field16,
                                install_params: __field17,
                                custom_install_url: __field18,
                                role_connections_verification_url: __field19,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "name",
                        "icon",
                        "description",
                        "rpc_origins",
                        "bot_public",
                        "bot_require_code_grant",
                        "terms_of_service_url",
                        "privacy_policy_url",
                        "owner",
                        "verify_key",
                        "team",
                        "guild_id",
                        "primary_sku_id",
                        "slug",
                        "cover_image",
                        "flags",
                        "install_params",
                        "custom_install_url",
                        "role_connections_verification_url",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Application",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Application>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Application {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Application",
                        false as usize + 1 + 1 + 1 + 1
                            + if Option::is_none(&self.rpc_origins) { 0 } else { 1 } + 1
                            + 1
                            + if Option::is_none(&self.terms_of_service_url) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.privacy_policy_url) {
                                0
                            } else {
                                1
                            } + if Option::is_none(&self.owner) { 0 } else { 1 } + 1 + 1
                            + 1 + 1 + if Option::is_none(&self.slug) { 0 } else { 1 }
                            + if Option::is_none(&self.cover_image) { 0 } else { 1 }
                            + if Option::is_none(&self.flags) { 0 } else { 1 }
                            + if Option::is_none(&self.install_params) { 0 } else { 1 }
                            + if Option::is_none(&self.custom_install_url) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(
                                &self.role_connections_verification_url,
                            ) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "icon",
                        &self.icon,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description",
                        &self.description,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.rpc_origins) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "rpc_origins",
                            &self.rpc_origins,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "rpc_origins",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "bot_public",
                        &self.bot_public,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "bot_require_code_grant",
                        &self.bot_require_code_grant,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.terms_of_service_url) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "terms_of_service_url",
                            &self.terms_of_service_url,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "terms_of_service_url",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.privacy_policy_url) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "privacy_policy_url",
                            &self.privacy_policy_url,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "privacy_policy_url",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.owner) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "owner",
                            &self.owner,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "owner",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "verify_key",
                        &self.verify_key,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "team",
                        &self.team,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "guild_id",
                        &self.guild_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "primary_sku_id",
                        &self.primary_sku_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.slug) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "slug",
                            &self.slug,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "slug",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.cover_image) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "cover_image",
                            &self.cover_image,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "cover_image",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.flags) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "flags",
                            &self.flags,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "flags",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.install_params) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "install_params",
                            &self.install_params,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "install_params",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.custom_install_url) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "custom_install_url",
                            &self.custom_install_url,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "custom_install_url",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.role_connections_verification_url) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role_connections_verification_url",
                            &self.role_connections_verification_url,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "role_connections_verification_url",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    }
    mod scope {
        use crate::internal::macros::enum_string;
        #[non_exhaustive]
        pub enum OAuthScope {
            ActivitiesRead,
            ActivitiesWrite,
            ApplicationBuildsRead,
            ApplicationBuildsUpload,
            ApplicationCommands,
            ApplicationCommandsUpdate,
            ApplicationCommandsPermUpdate,
            ApplicationEntitlements,
            ApplicationStoreUpdate,
            Bot,
            UserConnections,
            DMChannelsRead,
            Email,
            GroupDMJoin,
            ShowCurrentUserGuilds,
            GuildsJoin,
            ReadGuildMemberInfo,
            Identify,
            MessagesRead,
            UserRelationshipsRead,
            UserRoleConnectionsWrite,
            RPC,
            RPCActivitiesWrite,
            RPCNotificationsRead,
            RPCVoiceRead,
            RPCVoiceWrite,
            Voice,
            WebhookIncoming,
            Unknown(String),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for OAuthScope {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    OAuthScope::ActivitiesRead => {
                        ::core::fmt::Formatter::write_str(f, "ActivitiesRead")
                    }
                    OAuthScope::ActivitiesWrite => {
                        ::core::fmt::Formatter::write_str(f, "ActivitiesWrite")
                    }
                    OAuthScope::ApplicationBuildsRead => {
                        ::core::fmt::Formatter::write_str(f, "ApplicationBuildsRead")
                    }
                    OAuthScope::ApplicationBuildsUpload => {
                        ::core::fmt::Formatter::write_str(f, "ApplicationBuildsUpload")
                    }
                    OAuthScope::ApplicationCommands => {
                        ::core::fmt::Formatter::write_str(f, "ApplicationCommands")
                    }
                    OAuthScope::ApplicationCommandsUpdate => {
                        ::core::fmt::Formatter::write_str(f, "ApplicationCommandsUpdate")
                    }
                    OAuthScope::ApplicationCommandsPermUpdate => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "ApplicationCommandsPermUpdate",
                        )
                    }
                    OAuthScope::ApplicationEntitlements => {
                        ::core::fmt::Formatter::write_str(f, "ApplicationEntitlements")
                    }
                    OAuthScope::ApplicationStoreUpdate => {
                        ::core::fmt::Formatter::write_str(f, "ApplicationStoreUpdate")
                    }
                    OAuthScope::Bot => ::core::fmt::Formatter::write_str(f, "Bot"),
                    OAuthScope::UserConnections => {
                        ::core::fmt::Formatter::write_str(f, "UserConnections")
                    }
                    OAuthScope::DMChannelsRead => {
                        ::core::fmt::Formatter::write_str(f, "DMChannelsRead")
                    }
                    OAuthScope::Email => ::core::fmt::Formatter::write_str(f, "Email"),
                    OAuthScope::GroupDMJoin => {
                        ::core::fmt::Formatter::write_str(f, "GroupDMJoin")
                    }
                    OAuthScope::ShowCurrentUserGuilds => {
                        ::core::fmt::Formatter::write_str(f, "ShowCurrentUserGuilds")
                    }
                    OAuthScope::GuildsJoin => {
                        ::core::fmt::Formatter::write_str(f, "GuildsJoin")
                    }
                    OAuthScope::ReadGuildMemberInfo => {
                        ::core::fmt::Formatter::write_str(f, "ReadGuildMemberInfo")
                    }
                    OAuthScope::Identify => {
                        ::core::fmt::Formatter::write_str(f, "Identify")
                    }
                    OAuthScope::MessagesRead => {
                        ::core::fmt::Formatter::write_str(f, "MessagesRead")
                    }
                    OAuthScope::UserRelationshipsRead => {
                        ::core::fmt::Formatter::write_str(f, "UserRelationshipsRead")
                    }
                    OAuthScope::UserRoleConnectionsWrite => {
                        ::core::fmt::Formatter::write_str(f, "UserRoleConnectionsWrite")
                    }
                    OAuthScope::RPC => ::core::fmt::Formatter::write_str(f, "RPC"),
                    OAuthScope::RPCActivitiesWrite => {
                        ::core::fmt::Formatter::write_str(f, "RPCActivitiesWrite")
                    }
                    OAuthScope::RPCNotificationsRead => {
                        ::core::fmt::Formatter::write_str(f, "RPCNotificationsRead")
                    }
                    OAuthScope::RPCVoiceRead => {
                        ::core::fmt::Formatter::write_str(f, "RPCVoiceRead")
                    }
                    OAuthScope::RPCVoiceWrite => {
                        ::core::fmt::Formatter::write_str(f, "RPCVoiceWrite")
                    }
                    OAuthScope::Voice => ::core::fmt::Formatter::write_str(f, "Voice"),
                    OAuthScope::WebhookIncoming => {
                        ::core::fmt::Formatter::write_str(f, "WebhookIncoming")
                    }
                    OAuthScope::Unknown(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Unknown",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OAuthScope {
            #[inline]
            fn clone(&self) -> OAuthScope {
                match self {
                    OAuthScope::ActivitiesRead => OAuthScope::ActivitiesRead,
                    OAuthScope::ActivitiesWrite => OAuthScope::ActivitiesWrite,
                    OAuthScope::ApplicationBuildsRead => {
                        OAuthScope::ApplicationBuildsRead
                    }
                    OAuthScope::ApplicationBuildsUpload => {
                        OAuthScope::ApplicationBuildsUpload
                    }
                    OAuthScope::ApplicationCommands => OAuthScope::ApplicationCommands,
                    OAuthScope::ApplicationCommandsUpdate => {
                        OAuthScope::ApplicationCommandsUpdate
                    }
                    OAuthScope::ApplicationCommandsPermUpdate => {
                        OAuthScope::ApplicationCommandsPermUpdate
                    }
                    OAuthScope::ApplicationEntitlements => {
                        OAuthScope::ApplicationEntitlements
                    }
                    OAuthScope::ApplicationStoreUpdate => {
                        OAuthScope::ApplicationStoreUpdate
                    }
                    OAuthScope::Bot => OAuthScope::Bot,
                    OAuthScope::UserConnections => OAuthScope::UserConnections,
                    OAuthScope::DMChannelsRead => OAuthScope::DMChannelsRead,
                    OAuthScope::Email => OAuthScope::Email,
                    OAuthScope::GroupDMJoin => OAuthScope::GroupDMJoin,
                    OAuthScope::ShowCurrentUserGuilds => {
                        OAuthScope::ShowCurrentUserGuilds
                    }
                    OAuthScope::GuildsJoin => OAuthScope::GuildsJoin,
                    OAuthScope::ReadGuildMemberInfo => OAuthScope::ReadGuildMemberInfo,
                    OAuthScope::Identify => OAuthScope::Identify,
                    OAuthScope::MessagesRead => OAuthScope::MessagesRead,
                    OAuthScope::UserRelationshipsRead => {
                        OAuthScope::UserRelationshipsRead
                    }
                    OAuthScope::UserRoleConnectionsWrite => {
                        OAuthScope::UserRoleConnectionsWrite
                    }
                    OAuthScope::RPC => OAuthScope::RPC,
                    OAuthScope::RPCActivitiesWrite => OAuthScope::RPCActivitiesWrite,
                    OAuthScope::RPCNotificationsRead => OAuthScope::RPCNotificationsRead,
                    OAuthScope::RPCVoiceRead => OAuthScope::RPCVoiceRead,
                    OAuthScope::RPCVoiceWrite => OAuthScope::RPCVoiceWrite,
                    OAuthScope::Voice => OAuthScope::Voice,
                    OAuthScope::WebhookIncoming => OAuthScope::WebhookIncoming,
                    OAuthScope::Unknown(__self_0) => {
                        OAuthScope::Unknown(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OAuthScope {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OAuthScope {
            #[inline]
            fn eq(&self, other: &OAuthScope) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            OAuthScope::Unknown(__self_0),
                            OAuthScope::Unknown(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => true,
                    }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for OAuthScope {}
        #[automatically_derived]
        impl ::core::cmp::Eq for OAuthScope {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for OAuthScope {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state);
                match self {
                    OAuthScope::Unknown(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    _ => {}
                }
            }
        }
        impl OAuthScope {
            #[doc(hidden)]
            fn __internal_enum_string(value: &str) -> Option<Self> {
                match value {
                    "activities.read" => Some(Self::ActivitiesRead),
                    "activities.write" => Some(Self::ActivitiesWrite),
                    "applications.builds.read" => Some(Self::ApplicationBuildsRead),
                    "applications.builds.upload" => Some(Self::ApplicationBuildsUpload),
                    "applications.commands" => Some(Self::ApplicationCommands),
                    "applications.commands.update" => {
                        Some(Self::ApplicationCommandsUpdate)
                    }
                    "applications.commands.permissions.update" => {
                        Some(Self::ApplicationCommandsPermUpdate)
                    }
                    "applications.entitlements" => Some(Self::ApplicationEntitlements),
                    "applications.store.update" => Some(Self::ApplicationStoreUpdate),
                    "bot" => Some(Self::Bot),
                    "connections" => Some(Self::UserConnections),
                    "dm_channels.read" => Some(Self::DMChannelsRead),
                    "email" => Some(Self::Email),
                    "gdm.join" => Some(Self::GroupDMJoin),
                    "guilds" => Some(Self::ShowCurrentUserGuilds),
                    "guilds.join" => Some(Self::GuildsJoin),
                    "guilds.members.read" => Some(Self::ReadGuildMemberInfo),
                    "identify" => Some(Self::Identify),
                    "messages.read" => Some(Self::MessagesRead),
                    "relationships.read" => Some(Self::UserRelationshipsRead),
                    "role_connections.write" => Some(Self::UserRoleConnectionsWrite),
                    "rpc" => Some(Self::RPC),
                    "rpc.activities.write" => Some(Self::RPCActivitiesWrite),
                    "rpc.notifications.read" => Some(Self::RPCNotificationsRead),
                    "rpc.voice.read" => Some(Self::RPCVoiceRead),
                    "rpc.voice.write" => Some(Self::RPCVoiceWrite),
                    "voice" => Some(Self::Voice),
                    "webhook.incoming" => Some(Self::WebhookIncoming),
                    _ => Some(Self::Unknown(value.to_string())),
                }
            }
        }
        impl std::fmt::Display for OAuthScope {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                match self {
                    Self::ActivitiesRead => f.write_str("activities.read"),
                    Self::ActivitiesWrite => f.write_str("activities.write"),
                    Self::ApplicationBuildsRead => {
                        f.write_str("applications.builds.read")
                    }
                    Self::ApplicationBuildsUpload => {
                        f.write_str("applications.builds.upload")
                    }
                    Self::ApplicationCommands => f.write_str("applications.commands"),
                    Self::ApplicationCommandsUpdate => {
                        f.write_str("applications.commands.update")
                    }
                    Self::ApplicationCommandsPermUpdate => {
                        f.write_str("applications.commands.permissions.update")
                    }
                    Self::ApplicationEntitlements => {
                        f.write_str("applications.entitlements")
                    }
                    Self::ApplicationStoreUpdate => {
                        f.write_str("applications.store.update")
                    }
                    Self::Bot => f.write_str("bot"),
                    Self::UserConnections => f.write_str("connections"),
                    Self::DMChannelsRead => f.write_str("dm_channels.read"),
                    Self::Email => f.write_str("email"),
                    Self::GroupDMJoin => f.write_str("gdm.join"),
                    Self::ShowCurrentUserGuilds => f.write_str("guilds"),
                    Self::GuildsJoin => f.write_str("guilds.join"),
                    Self::ReadGuildMemberInfo => f.write_str("guilds.members.read"),
                    Self::Identify => f.write_str("identify"),
                    Self::MessagesRead => f.write_str("messages.read"),
                    Self::UserRelationshipsRead => f.write_str("relationships.read"),
                    Self::UserRoleConnectionsWrite => {
                        f.write_str("role_connections.write")
                    }
                    Self::RPC => f.write_str("rpc"),
                    Self::RPCActivitiesWrite => f.write_str("rpc.activities.write"),
                    Self::RPCNotificationsRead => f.write_str("rpc.notifications.read"),
                    Self::RPCVoiceRead => f.write_str("rpc.voice.read"),
                    Self::RPCVoiceWrite => f.write_str("rpc.voice.write"),
                    Self::Voice => f.write_str("voice"),
                    Self::WebhookIncoming => f.write_str("webhook.incoming"),
                    Self::Unknown(n) => n.fmt(f),
                }
            }
        }
        impl<'de> serde::Deserialize<'de> for OAuthScope {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = OAuthScope;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("OAuthScope enum")
                    }
                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        OAuthScope::__internal_enum_string(value)
                            .ok_or_else(|| {
                                serde::de::Error::custom({
                                    let res = ::alloc::fmt::format(
                                        format_args!("unknown OAuthScope variant: {0:?}", value),
                                    );
                                    res
                                })
                            })
                    }
                }
                deserializer.deserialize_str(Visitor)
            }
        }
        impl serde::Serialize for OAuthScope {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                serializer.collect_str(self)
            }
        }
    }
    mod team {
        use crate::id::{TeamId, UserId};
        use crate::misc::ImageHash;
        use serde::{Deserialize, Serialize};
        mod member {
            use super::TeamMemberState;
            use crate::{id::TeamId, user::User};
            use serde::{Deserialize, Serialize};
            pub struct TeamMember {
                #[serde(rename = "membership_state")]
                pub state: TeamMemberState,
                pub team_id: TeamId,
                pub user: User,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for TeamMember {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "TeamMember",
                        "state",
                        &self.state,
                        "team_id",
                        &self.team_id,
                        "user",
                        &&self.user,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TeamMember {
                #[inline]
                fn clone(&self) -> TeamMember {
                    TeamMember {
                        state: ::core::clone::Clone::clone(&self.state),
                        team_id: ::core::clone::Clone::clone(&self.team_id),
                        user: ::core::clone::Clone::clone(&self.user),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TeamMember {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TeamMember {
                #[inline]
                fn eq(&self, other: &TeamMember) -> bool {
                    self.state == other.state && self.team_id == other.team_id
                        && self.user == other.user
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for TeamMember {}
            #[automatically_derived]
            impl ::core::cmp::Eq for TeamMember {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<TeamMemberState>;
                    let _: ::core::cmp::AssertParamIsEq<TeamId>;
                    let _: ::core::cmp::AssertParamIsEq<User>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TeamMember {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "membership_state" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    "team_id" => _serde::__private::Ok(__Field::__field1),
                                    "user" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"membership_state" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    b"team_id" => _serde::__private::Ok(__Field::__field1),
                                    b"user" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TeamMember>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TeamMember;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TeamMember",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    TeamMemberState,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TeamMember with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match match _serde::de::SeqAccess::next_element::<
                                    TeamId,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct TeamMember with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match match _serde::de::SeqAccess::next_element::<
                                    User,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct TeamMember with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TeamMember {
                                    state: __field0,
                                    team_id: __field1,
                                    user: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    TeamMemberState,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<TeamId> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<User> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = match _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "membership_state",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    TeamMemberState,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "team_id",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    TeamId,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("user"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    User,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field(
                                            "membership_state",
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("team_id") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("user") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::__private::Ok(TeamMember {
                                    state: __field0,
                                    team_id: __field1,
                                    user: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "membership_state",
                            "team_id",
                            "user",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TeamMember",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TeamMember>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TeamMember {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TeamMember",
                            false as usize + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "membership_state",
                            &self.state,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "team_id",
                            &self.team_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "user",
                            &self.user,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl std::hash::Hash for TeamMember {
                fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
                    self.state.hash(state);
                    self.team_id.hash(state);
                    self.user.hash(state);
                }
            }
        }
        mod member_state {
            use crate::internal::macros::enum_repr;
            #[non_exhaustive]
            pub enum TeamMemberState {
                Invited = 1,
                Accepted,
                Unknown = !0,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for TeamMemberState {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            TeamMemberState::Invited => "Invited",
                            TeamMemberState::Accepted => "Accepted",
                            TeamMemberState::Unknown => "Unknown",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TeamMemberState {
                #[inline]
                fn clone(&self) -> TeamMemberState {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for TeamMemberState {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TeamMemberState {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TeamMemberState {
                #[inline]
                fn eq(&self, other: &TeamMemberState) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for TeamMemberState {}
            #[automatically_derived]
            impl ::core::cmp::Eq for TeamMemberState {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for TeamMemberState {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            impl TeamMemberState {
                #[doc(hidden)]
                fn __internal_enum_repr(value: u64) -> Option<Self> {
                    match value {
                        _ if value == TeamMemberState::Invited.value() => {
                            Some(Self::Invited)
                        }
                        _ if value == TeamMemberState::Accepted.value() => {
                            Some(Self::Accepted)
                        }
                        _ => Some(Self::Unknown),
                    }
                }
            }
            impl TeamMemberState {
                pub const fn value(&self) -> u64 {
                    *self as u64
                }
            }
            impl<'de> serde::Deserialize<'de> for TeamMemberState {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = TeamMemberState;
                        fn expecting(
                            &self,
                            f: &mut std::fmt::Formatter<'_>,
                        ) -> std::fmt::Result {
                            f.write_str("TeamMemberState type (integer)")
                        }
                        fn visit_u64<E>(self, value: u64) -> Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            TeamMemberState::__internal_enum_repr(value)
                                .ok_or_else(|| {
                                    serde::de::Error::custom({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown TeamMemberState variant: {0}", value),
                                        );
                                        res
                                    })
                                })
                        }
                    }
                    deserializer.deserialize_u64(Visitor)
                }
            }
            impl serde::Serialize for TeamMemberState {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    serializer.serialize_u64(self.value())
                }
            }
        }
        pub use member::*;
        pub use member_state::*;
        pub struct Team {
            pub id: TeamId,
            pub name: String,
            pub owner_user_id: UserId,
            pub icon: Option<ImageHash>,
            pub members: Vec<TeamMember>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Team {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "Team",
                    "id",
                    &self.id,
                    "name",
                    &self.name,
                    "owner_user_id",
                    &self.owner_user_id,
                    "icon",
                    &self.icon,
                    "members",
                    &&self.members,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Team {
            #[inline]
            fn clone(&self) -> Team {
                Team {
                    id: ::core::clone::Clone::clone(&self.id),
                    name: ::core::clone::Clone::clone(&self.name),
                    owner_user_id: ::core::clone::Clone::clone(&self.owner_user_id),
                    icon: ::core::clone::Clone::clone(&self.icon),
                    members: ::core::clone::Clone::clone(&self.members),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Team {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Team {
            #[inline]
            fn eq(&self, other: &Team) -> bool {
                self.id == other.id && self.name == other.name
                    && self.owner_user_id == other.owner_user_id
                    && self.icon == other.icon && self.members == other.members
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Team {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Team {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<TeamId>;
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<UserId>;
                let _: ::core::cmp::AssertParamIsEq<Option<ImageHash>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<TeamMember>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Team {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.id, state);
                ::core::hash::Hash::hash(&self.name, state);
                ::core::hash::Hash::hash(&self.owner_user_id, state);
                ::core::hash::Hash::hash(&self.icon, state);
                ::core::hash::Hash::hash(&self.members, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Team {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "name" => _serde::__private::Ok(__Field::__field1),
                                "owner_user_id" => _serde::__private::Ok(__Field::__field2),
                                "icon" => _serde::__private::Ok(__Field::__field3),
                                "members" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"name" => _serde::__private::Ok(__Field::__field1),
                                b"owner_user_id" => _serde::__private::Ok(__Field::__field2),
                                b"icon" => _serde::__private::Ok(__Field::__field3),
                                b"members" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Team>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Team;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Team",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                TeamId,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Team with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Team with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                UserId,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Team with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Option<ImageHash>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Team with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Vec<TeamMember>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct Team with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Team {
                                id: __field0,
                                name: __field1,
                                owner_user_id: __field2,
                                icon: __field3,
                                members: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<TeamId> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<UserId> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                Option<ImageHash>,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                Vec<TeamMember>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = match _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                TeamId,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                String,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "owner_user_id",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                UserId,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("icon"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ImageHash>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "members",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Vec<TeamMember>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("id") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("name") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "owner_user_id",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("icon") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("members") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Team {
                                id: __field0,
                                name: __field1,
                                owner_user_id: __field2,
                                icon: __field3,
                                members: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "name",
                        "owner_user_id",
                        "icon",
                        "members",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Team",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Team>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Team {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Team",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "owner_user_id",
                        &self.owner_user_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "icon",
                        &self.icon,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "members",
                        &self.members,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    }
    pub use application::*;
    pub use scope::*;
    pub use team::*;
}
pub mod presence {
    mod activity {
        use crate::{id::ApplicationId, misc::Timestamp};
        use serde::{Deserialize, Serialize};
        mod assets {
            use serde::{Deserialize, Serialize};
            pub struct ActivityAsset {
                #[serde(skip_serializing_if = "Option::is_none")]
                pub large_image: Option<String>,
                #[serde(skip_serializing_if = "Option::is_none")]
                pub large_text: Option<String>,
                #[serde(skip_serializing_if = "Option::is_none")]
                pub small_image: Option<String>,
                #[serde(skip_serializing_if = "Option::is_none")]
                pub small_text: Option<String>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ActivityAsset {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "ActivityAsset",
                        "large_image",
                        &self.large_image,
                        "large_text",
                        &self.large_text,
                        "small_image",
                        &self.small_image,
                        "small_text",
                        &&self.small_text,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActivityAsset {
                #[inline]
                fn clone(&self) -> ActivityAsset {
                    ActivityAsset {
                        large_image: ::core::clone::Clone::clone(&self.large_image),
                        large_text: ::core::clone::Clone::clone(&self.large_text),
                        small_image: ::core::clone::Clone::clone(&self.small_image),
                        small_text: ::core::clone::Clone::clone(&self.small_text),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActivityAsset {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActivityAsset {
                #[inline]
                fn eq(&self, other: &ActivityAsset) -> bool {
                    self.large_image == other.large_image
                        && self.large_text == other.large_text
                        && self.small_image == other.small_image
                        && self.small_text == other.small_text
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ActivityAsset {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ActivityAsset {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ActivityAsset {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.large_image, state);
                    ::core::hash::Hash::hash(&self.large_text, state);
                    ::core::hash::Hash::hash(&self.small_image, state);
                    ::core::hash::Hash::hash(&self.small_text, state)
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ActivityAsset {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "large_image" => _serde::__private::Ok(__Field::__field0),
                                    "large_text" => _serde::__private::Ok(__Field::__field1),
                                    "small_image" => _serde::__private::Ok(__Field::__field2),
                                    "small_text" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"large_image" => _serde::__private::Ok(__Field::__field0),
                                    b"large_text" => _serde::__private::Ok(__Field::__field1),
                                    b"small_image" => _serde::__private::Ok(__Field::__field2),
                                    b"small_text" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ActivityAsset>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ActivityAsset;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ActivityAsset",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ActivityAsset with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ActivityAsset with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ActivityAsset with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct ActivityAsset with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ActivityAsset {
                                    large_image: __field0,
                                    large_text: __field1,
                                    small_image: __field2,
                                    small_text: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = match _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "large_image",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "large_text",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "small_image",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "small_text",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("large_image") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("large_text") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("small_image") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("small_text") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::__private::Ok(ActivityAsset {
                                    large_image: __field0,
                                    large_text: __field1,
                                    small_image: __field2,
                                    small_text: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "large_image",
                            "large_text",
                            "small_image",
                            "small_text",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ActivityAsset",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ActivityAsset>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ActivityAsset {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "ActivityAsset",
                            false as usize
                                + if Option::is_none(&self.large_image) { 0 } else { 1 }
                                + if Option::is_none(&self.large_text) { 0 } else { 1 }
                                + if Option::is_none(&self.small_image) { 0 } else { 1 }
                                + if Option::is_none(&self.small_text) { 0 } else { 1 },
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        if !Option::is_none(&self.large_image) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "large_image",
                                &self.large_image,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "large_image",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.large_text) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "large_text",
                                &self.large_text,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "large_text",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.small_image) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "small_image",
                                &self.small_image,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "small_image",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.small_text) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "small_text",
                                &self.small_text,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "small_text",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        }
        mod button {
            use serde::{Deserialize, Serialize};
            pub struct ActivityButton {
                pub label: String,
                pub url: String,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ActivityButton {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ActivityButton",
                        "label",
                        &self.label,
                        "url",
                        &&self.url,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActivityButton {
                #[inline]
                fn clone(&self) -> ActivityButton {
                    ActivityButton {
                        label: ::core::clone::Clone::clone(&self.label),
                        url: ::core::clone::Clone::clone(&self.url),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActivityButton {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActivityButton {
                #[inline]
                fn eq(&self, other: &ActivityButton) -> bool {
                    self.label == other.label && self.url == other.url
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ActivityButton {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ActivityButton {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ActivityButton {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.label, state);
                    ::core::hash::Hash::hash(&self.url, state)
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ActivityButton {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "label" => _serde::__private::Ok(__Field::__field0),
                                    "url" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"label" => _serde::__private::Ok(__Field::__field0),
                                    b"url" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ActivityButton>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ActivityButton;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ActivityButton",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ActivityButton with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ActivityButton with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ActivityButton {
                                    label: __field0,
                                    url: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = match _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("label"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    String,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("url"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    String,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("label") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("url") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::__private::Ok(ActivityButton {
                                    label: __field0,
                                    url: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["label", "url"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ActivityButton",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ActivityButton>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ActivityButton {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "ActivityButton",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "label",
                            &self.label,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "url",
                            &self.url,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        }
        mod emoji {
            use crate::id::EmojiId;
            use serde::{Deserialize, Serialize};
            pub struct ActivityEmoji {
                #[serde(skip_serializing_if = "Option::is_none")]
                pub id: Option<EmojiId>,
                pub name: String,
                #[serde(skip_serializing_if = "Option::is_none")]
                pub animated: Option<bool>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ActivityEmoji {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ActivityEmoji",
                        "id",
                        &self.id,
                        "name",
                        &self.name,
                        "animated",
                        &&self.animated,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActivityEmoji {
                #[inline]
                fn clone(&self) -> ActivityEmoji {
                    ActivityEmoji {
                        id: ::core::clone::Clone::clone(&self.id),
                        name: ::core::clone::Clone::clone(&self.name),
                        animated: ::core::clone::Clone::clone(&self.animated),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActivityEmoji {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActivityEmoji {
                #[inline]
                fn eq(&self, other: &ActivityEmoji) -> bool {
                    self.id == other.id && self.name == other.name
                        && self.animated == other.animated
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ActivityEmoji {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ActivityEmoji {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Option<EmojiId>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                    let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ActivityEmoji {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.id, state);
                    ::core::hash::Hash::hash(&self.name, state);
                    ::core::hash::Hash::hash(&self.animated, state)
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ActivityEmoji {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "id" => _serde::__private::Ok(__Field::__field0),
                                    "name" => _serde::__private::Ok(__Field::__field1),
                                    "animated" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"id" => _serde::__private::Ok(__Field::__field0),
                                    b"name" => _serde::__private::Ok(__Field::__field1),
                                    b"animated" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ActivityEmoji>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ActivityEmoji;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ActivityEmoji",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    Option<EmojiId>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ActivityEmoji with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ActivityEmoji with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match match _serde::de::SeqAccess::next_element::<
                                    Option<bool>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ActivityEmoji with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ActivityEmoji {
                                    id: __field0,
                                    name: __field1,
                                    animated: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    Option<EmojiId>,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = match _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<EmojiId>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    String,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "animated",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<bool>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("id") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("name") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("animated") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::__private::Ok(ActivityEmoji {
                                    id: __field0,
                                    name: __field1,
                                    animated: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "id",
                            "name",
                            "animated",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ActivityEmoji",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ActivityEmoji>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ActivityEmoji {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "ActivityEmoji",
                            false as usize
                                + if Option::is_none(&self.id) { 0 } else { 1 } + 1
                                + if Option::is_none(&self.animated) { 0 } else { 1 },
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        if !Option::is_none(&self.id) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "id",
                                &self.id,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "id",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        if !Option::is_none(&self.animated) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "animated",
                                &self.animated,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "animated",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        }
        mod flags {
            use crate::internal::macros::bitflags;
            pub struct ActivityFlags(
                <ActivityFlags as ::bitflags::__private::PublicFlags>::Internal,
            );
            #[automatically_derived]
            impl ::core::fmt::Debug for ActivityFlags {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ActivityFlags",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActivityFlags {
                #[inline]
                fn clone(&self) -> ActivityFlags {
                    let _: ::core::clone::AssertParamIsClone<
                        <ActivityFlags as ::bitflags::__private::PublicFlags>::Internal,
                    >;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ActivityFlags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActivityFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActivityFlags {
                #[inline]
                fn eq(&self, other: &ActivityFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ActivityFlags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ActivityFlags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        <ActivityFlags as ::bitflags::__private::PublicFlags>::Internal,
                    >;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ActivityFlags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            impl ActivityFlags {
                #[allow(deprecated, non_upper_case_globals)]
                pub const INSTANCE: Self = Self::from_bits_retain(1 << 0);
                #[allow(deprecated, non_upper_case_globals)]
                pub const JOIN: Self = Self::from_bits_retain(1 << 1);
                #[allow(deprecated, non_upper_case_globals)]
                pub const SPECTATE: Self = Self::from_bits_retain(1 << 2);
                #[allow(deprecated, non_upper_case_globals)]
                pub const JOIN_REQUEST: Self = Self::from_bits_retain(1 << 3);
                #[allow(deprecated, non_upper_case_globals)]
                pub const SYNC: Self = Self::from_bits_retain(1 << 4);
                #[allow(deprecated, non_upper_case_globals)]
                pub const PLAY: Self = Self::from_bits_retain(1 << 5);
                #[allow(deprecated, non_upper_case_globals)]
                pub const PARTY_PRIVACY_FRIENDS: Self = Self::from_bits_retain(1 << 6);
                #[allow(deprecated, non_upper_case_globals)]
                pub const PARTY_PRIVACY_VOICE_CHANNEL: Self = Self::from_bits_retain(
                    1 << 7,
                );
                #[allow(deprecated, non_upper_case_globals)]
                pub const EMBEDDED: Self = Self::from_bits_retain(1 << 8);
            }
            impl ::bitflags::Flags for ActivityFlags {
                const FLAGS: &'static [::bitflags::Flag<ActivityFlags>] = &[
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("INSTANCE", ActivityFlags::INSTANCE)
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("JOIN", ActivityFlags::JOIN)
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("SPECTATE", ActivityFlags::SPECTATE)
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "JOIN_REQUEST",
                            ActivityFlags::JOIN_REQUEST,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("SYNC", ActivityFlags::SYNC)
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("PLAY", ActivityFlags::PLAY)
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "PARTY_PRIVACY_FRIENDS",
                            ActivityFlags::PARTY_PRIVACY_FRIENDS,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new(
                            "PARTY_PRIVACY_VOICE_CHANNEL",
                            ActivityFlags::PARTY_PRIVACY_VOICE_CHANNEL,
                        )
                    },
                    {
                        #[allow(deprecated, non_upper_case_globals)]
                        ::bitflags::Flag::new("EMBEDDED", ActivityFlags::EMBEDDED)
                    },
                ];
                type Bits = u16;
                fn bits(&self) -> u16 {
                    ActivityFlags::bits(self)
                }
                fn from_bits_retain(bits: u16) -> ActivityFlags {
                    ActivityFlags::from_bits_retain(bits)
                }
            }
            #[allow(
                dead_code,
                deprecated,
                unused_doc_comments,
                unused_attributes,
                unused_mut,
                unused_imports,
                non_upper_case_globals,
                clippy::assign_op_pattern
            )]
            const _: () = {
                #[repr(transparent)]
                pub struct InternalBitFlags(u16);
                #[automatically_derived]
                impl ::core::clone::Clone for InternalBitFlags {
                    #[inline]
                    fn clone(&self) -> InternalBitFlags {
                        let _: ::core::clone::AssertParamIsClone<u16>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for InternalBitFlags {
                    #[inline]
                    fn eq(&self, other: &InternalBitFlags) -> bool {
                        self.0 == other.0
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for InternalBitFlags {}
                #[automatically_derived]
                impl ::core::cmp::Eq for InternalBitFlags {
                    #[inline]
                    #[doc(hidden)]
                    #[no_coverage]
                    fn assert_receiver_is_total_eq(&self) -> () {
                        let _: ::core::cmp::AssertParamIsEq<u16>;
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::PartialOrd for InternalBitFlags {
                    #[inline]
                    fn partial_cmp(
                        &self,
                        other: &InternalBitFlags,
                    ) -> ::core::option::Option<::core::cmp::Ordering> {
                        ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Ord for InternalBitFlags {
                    #[inline]
                    fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                        ::core::cmp::Ord::cmp(&self.0, &other.0)
                    }
                }
                #[automatically_derived]
                impl ::core::hash::Hash for InternalBitFlags {
                    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                        ::core::hash::Hash::hash(&self.0, state)
                    }
                }
                impl ::bitflags::__private::PublicFlags for ActivityFlags {
                    type Primitive = u16;
                    type Internal = InternalBitFlags;
                }
                impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                    #[inline]
                    fn default() -> Self {
                        InternalBitFlags::empty()
                    }
                }
                impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        if self.is_empty() {
                            f.write_fmt(
                                format_args!("{0:#x}", < u16 as ::bitflags::Bits >::EMPTY),
                            )
                        } else {
                            ::bitflags::__private::core::fmt::Display::fmt(self, f)
                        }
                    }
                }
                impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::parser::to_writer(&ActivityFlags(*self), f)
                    }
                }
                impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                    type Err = ::bitflags::parser::ParseError;
                    fn from_str(
                        s: &str,
                    ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                        ::bitflags::parser::from_str::<ActivityFlags>(s)
                            .map(|flags| flags.0)
                    }
                }
                impl ::bitflags::__private::core::convert::AsRef<u16>
                for InternalBitFlags {
                    fn as_ref(&self) -> &u16 {
                        &self.0
                    }
                }
                impl ::bitflags::__private::core::convert::From<u16>
                for InternalBitFlags {
                    fn from(bits: u16) -> Self {
                        Self::from_bits_retain(bits)
                    }
                }
                #[allow(dead_code, deprecated, unused_attributes)]
                impl InternalBitFlags {
                    /// Returns an empty set of flags.
                    #[inline]
                    pub const fn empty() -> Self {
                        { Self(<u16 as ::bitflags::Bits>::EMPTY) }
                    }
                    /// Returns the set containing all flags.
                    #[inline]
                    pub const fn all() -> Self {
                        { Self::from_bits_truncate(<u16 as ::bitflags::Bits>::ALL) }
                    }
                    /// Returns the raw value of the flags currently stored.
                    #[inline]
                    pub const fn bits(&self) -> u16 {
                        let f = self;
                        { f.0 }
                    }
                    /// Convert from underlying bit representation, unless that
                    /// representation contains bits that do not correspond to a flag.
                    #[inline]
                    pub const fn from_bits(
                        bits: u16,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        let bits = bits;
                        {
                            let truncated = Self::from_bits_truncate(bits).0;
                            if truncated == bits {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            } else {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                    /// Convert from underlying bit representation, dropping any bits
                    /// that do not correspond to flags.
                    #[inline]
                    pub const fn from_bits_truncate(bits: u16) -> Self {
                        let bits = bits;
                        {
                            if bits == <u16 as ::bitflags::Bits>::EMPTY {
                                return Self(bits);
                            }
                            let mut truncated = <u16 as ::bitflags::Bits>::EMPTY;
                            {
                                if bits & ActivityFlags::INSTANCE.bits()
                                    == ActivityFlags::INSTANCE.bits()
                                {
                                    truncated = truncated | ActivityFlags::INSTANCE.bits();
                                }
                            };
                            {
                                if bits & ActivityFlags::JOIN.bits()
                                    == ActivityFlags::JOIN.bits()
                                {
                                    truncated = truncated | ActivityFlags::JOIN.bits();
                                }
                            };
                            {
                                if bits & ActivityFlags::SPECTATE.bits()
                                    == ActivityFlags::SPECTATE.bits()
                                {
                                    truncated = truncated | ActivityFlags::SPECTATE.bits();
                                }
                            };
                            {
                                if bits & ActivityFlags::JOIN_REQUEST.bits()
                                    == ActivityFlags::JOIN_REQUEST.bits()
                                {
                                    truncated = truncated | ActivityFlags::JOIN_REQUEST.bits();
                                }
                            };
                            {
                                if bits & ActivityFlags::SYNC.bits()
                                    == ActivityFlags::SYNC.bits()
                                {
                                    truncated = truncated | ActivityFlags::SYNC.bits();
                                }
                            };
                            {
                                if bits & ActivityFlags::PLAY.bits()
                                    == ActivityFlags::PLAY.bits()
                                {
                                    truncated = truncated | ActivityFlags::PLAY.bits();
                                }
                            };
                            {
                                if bits & ActivityFlags::PARTY_PRIVACY_FRIENDS.bits()
                                    == ActivityFlags::PARTY_PRIVACY_FRIENDS.bits()
                                {
                                    truncated = truncated
                                        | ActivityFlags::PARTY_PRIVACY_FRIENDS.bits();
                                }
                            };
                            {
                                if bits & ActivityFlags::PARTY_PRIVACY_VOICE_CHANNEL.bits()
                                    == ActivityFlags::PARTY_PRIVACY_VOICE_CHANNEL.bits()
                                {
                                    truncated = truncated
                                        | ActivityFlags::PARTY_PRIVACY_VOICE_CHANNEL.bits();
                                }
                            };
                            {
                                if bits & ActivityFlags::EMBEDDED.bits()
                                    == ActivityFlags::EMBEDDED.bits()
                                {
                                    truncated = truncated | ActivityFlags::EMBEDDED.bits();
                                }
                            };
                            Self(truncated)
                        }
                    }
                    /// Convert from underlying bit representation, preserving all
                    /// bits (even those not corresponding to a defined flag).
                    #[inline]
                    pub const fn from_bits_retain(bits: u16) -> Self {
                        let bits = bits;
                        { Self(bits) }
                    }
                    /// Get the value for a flag from its stringified name.
                    ///
                    /// Names are _case-sensitive_, so must correspond exactly to
                    /// the identifier given to the flag.
                    #[inline]
                    pub fn from_name(
                        name: &str,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        let name = name;
                        {
                            {
                                if name == "INSTANCE" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ActivityFlags::INSTANCE.bits()),
                                    );
                                }
                            };
                            {
                                if name == "JOIN" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ActivityFlags::JOIN.bits()),
                                    );
                                }
                            };
                            {
                                if name == "SPECTATE" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ActivityFlags::SPECTATE.bits()),
                                    );
                                }
                            };
                            {
                                if name == "JOIN_REQUEST" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ActivityFlags::JOIN_REQUEST.bits()),
                                    );
                                }
                            };
                            {
                                if name == "SYNC" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ActivityFlags::SYNC.bits()),
                                    );
                                }
                            };
                            {
                                if name == "PLAY" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ActivityFlags::PLAY.bits()),
                                    );
                                }
                            };
                            {
                                if name == "PARTY_PRIVACY_FRIENDS" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ActivityFlags::PARTY_PRIVACY_FRIENDS.bits()),
                                    );
                                }
                            };
                            {
                                if name == "PARTY_PRIVACY_VOICE_CHANNEL" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ActivityFlags::PARTY_PRIVACY_VOICE_CHANNEL.bits()),
                                    );
                                }
                            };
                            {
                                if name == "EMBEDDED" {
                                    return ::bitflags::__private::core::option::Option::Some(
                                        Self(ActivityFlags::EMBEDDED.bits()),
                                    );
                                }
                            };
                            let _ = name;
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                    /// Returns `true` if no flags are currently stored.
                    #[inline]
                    pub const fn is_empty(&self) -> bool {
                        let f = self;
                        { f.0 == Self::empty().0 }
                    }
                    /// Returns `true` if all flags are currently set.
                    #[inline]
                    pub const fn is_all(&self) -> bool {
                        let f = self;
                        { Self::all().0 | f.0 == f.0 }
                    }
                    /// Returns `true` if there are flags common to both `self` and `other`.
                    #[inline]
                    pub const fn intersects(&self, other: Self) -> bool {
                        let f = self;
                        let other = other;
                        { !(Self(f.0 & other.0)).is_empty() }
                    }
                    /// Returns `true` if all of the flags in `other` are contained within `self`.
                    #[inline]
                    pub const fn contains(&self, other: Self) -> bool {
                        let f = self;
                        let other = other;
                        { (f.0 & other.0) == other.0 }
                    }
                    /// Inserts the specified flags in-place.
                    #[inline]
                    pub fn insert(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        {
                            f.0 = f.0 | other.0;
                        }
                    }
                    /// Removes the specified flags in-place.
                    #[inline]
                    pub fn remove(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        {
                            f.0 = f.0 & !other.0;
                        }
                    }
                    /// Toggles the specified flags in-place.
                    #[inline]
                    pub fn toggle(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        {
                            f.0 = f.0 ^ other.0;
                        }
                    }
                    /// Inserts or removes the specified flags depending on the passed value.
                    #[inline]
                    pub fn set(&mut self, other: Self, value: bool) {
                        let f = self;
                        let other = other;
                        let value = value;
                        {
                            if value {
                                f.insert(other);
                            } else {
                                f.remove(other);
                            }
                        }
                    }
                    /// Returns the intersection between the flags in `self` and
                    /// `other`.
                    ///
                    /// Specifically, the returned set contains only the flags which are
                    /// present in *both* `self` *and* `other`.
                    ///
                    /// This is equivalent to using the `&` operator (e.g.
                    /// [`ops::BitAnd`]), as in `flags & other`.
                    ///
                    /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                    #[inline]
                    #[must_use]
                    pub const fn intersection(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0 & other.0) }
                    }
                    /// Returns the union of between the flags in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains all flags which are
                    /// present in *either* `self` *or* `other`, including any which are
                    /// present in both (see [`Self::symmetric_difference`] if that
                    /// is undesirable).
                    ///
                    /// This is equivalent to using the `|` operator (e.g.
                    /// [`ops::BitOr`]), as in `flags | other`.
                    ///
                    /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                    #[inline]
                    #[must_use]
                    pub const fn union(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0 | other.0) }
                    }
                    /// Returns the difference between the flags in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains all flags present in
                    /// `self`, except for the ones present in `other`.
                    ///
                    /// It is also conceptually equivalent to the "bit-clear" operation:
                    /// `flags & !other` (and this syntax is also supported).
                    ///
                    /// This is equivalent to using the `-` operator (e.g.
                    /// [`ops::Sub`]), as in `flags - other`.
                    ///
                    /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                    #[inline]
                    #[must_use]
                    pub const fn difference(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0 & !other.0) }
                    }
                    /// Returns the [symmetric difference][sym-diff] between the flags
                    /// in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains the flags present which
                    /// are present in `self` or `other`, but that are not present in
                    /// both. Equivalently, it contains the flags present in *exactly
                    /// one* of the sets `self` and `other`.
                    ///
                    /// This is equivalent to using the `^` operator (e.g.
                    /// [`ops::BitXor`]), as in `flags ^ other`.
                    ///
                    /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                    /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                    #[inline]
                    #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0 ^ other.0) }
                    }
                    /// Returns the complement of this set of flags.
                    ///
                    /// Specifically, the returned set contains all the flags which are
                    /// not set in `self`, but which are allowed for this type.
                    ///
                    /// Alternatively, it can be thought of as the set difference
                    /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                    ///
                    /// This is equivalent to using the `!` operator (e.g.
                    /// [`ops::Not`]), as in `!flags`.
                    ///
                    /// [`Self::all()`]: Self::all
                    /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                    #[inline]
                    #[must_use]
                    pub const fn complement(self) -> Self {
                        let f = self;
                        { Self::from_bits_truncate(!f.0) }
                    }
                }
                impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::Binary::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::Octal::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::LowerHex::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::UpperHex::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                    type Output = Self;
                    /// Returns the union of the two sets of flags.
                    #[inline]
                    fn bitor(self, other: InternalBitFlags) -> Self {
                        self.union(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                    /// Adds the set of flags.
                    #[inline]
                    fn bitor_assign(&mut self, other: Self) {
                        self.0 = self.0 | other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                    type Output = Self;
                    /// Returns the left flags, but with all the right flags toggled.
                    #[inline]
                    fn bitxor(self, other: Self) -> Self {
                        self.symmetric_difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitXorAssign
                for InternalBitFlags {
                    /// Toggles the set of flags.
                    #[inline]
                    fn bitxor_assign(&mut self, other: Self) {
                        self.0 = self.0 ^ other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                    type Output = Self;
                    /// Returns the intersection between the two sets of flags.
                    #[inline]
                    fn bitand(self, other: Self) -> Self {
                        self.intersection(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitAndAssign
                for InternalBitFlags {
                    /// Disables all flags disabled in the set.
                    #[inline]
                    fn bitand_assign(&mut self, other: Self) {
                        self.0 = self.0 & other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                    type Output = Self;
                    /// Returns the set difference of the two sets of flags.
                    #[inline]
                    fn sub(self, other: Self) -> Self {
                        self.difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                    /// Disables all flags enabled in the set.
                    #[inline]
                    fn sub_assign(&mut self, other: Self) {
                        self.0 = self.0 & !other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                    type Output = Self;
                    /// Returns the complement of this set of flags.
                    #[inline]
                    fn not(self) -> Self {
                        self.complement()
                    }
                }
                impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
                for InternalBitFlags {
                    fn extend<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(&mut self, iterator: T) {
                        for item in iterator {
                            self.insert(item)
                        }
                    }
                }
                impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
                for InternalBitFlags {
                    fn from_iter<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(iterator: T) -> Self {
                        use ::bitflags::__private::core::iter::Extend;
                        let mut result = Self::empty();
                        result.extend(iterator);
                        result
                    }
                }
                impl InternalBitFlags {
                    /// Iterate over enabled flag values.
                    #[inline]
                    pub const fn iter(&self) -> ::bitflags::iter::Iter<ActivityFlags> {
                        ::bitflags::iter::Iter::__private_const_new(
                            <ActivityFlags as ::bitflags::Flags>::FLAGS,
                            ActivityFlags::from_bits_retain(self.bits()),
                            ActivityFlags::from_bits_retain(self.bits()),
                        )
                    }
                    /// Iterate over enabled flag values with their stringified names.
                    #[inline]
                    pub const fn iter_names(
                        &self,
                    ) -> ::bitflags::iter::IterNames<ActivityFlags> {
                        ::bitflags::iter::IterNames::__private_const_new(
                            <ActivityFlags as ::bitflags::Flags>::FLAGS,
                            ActivityFlags::from_bits_retain(self.bits()),
                            ActivityFlags::from_bits_retain(self.bits()),
                        )
                    }
                }
                impl ::bitflags::__private::core::iter::IntoIterator
                for InternalBitFlags {
                    type Item = ActivityFlags;
                    type IntoIter = ::bitflags::iter::Iter<ActivityFlags>;
                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }
                impl InternalBitFlags {
                    /// Returns a mutable reference to the raw value of the flags currently stored.
                    #[inline]
                    pub fn bits_mut(&mut self) -> &mut u16 {
                        &mut self.0
                    }
                }
                #[allow(dead_code, deprecated, unused_attributes)]
                impl ActivityFlags {
                    /// Returns an empty set of flags.
                    #[inline]
                    pub const fn empty() -> Self {
                        { Self(InternalBitFlags::empty()) }
                    }
                    /// Returns the set containing all flags.
                    #[inline]
                    pub const fn all() -> Self {
                        { Self(InternalBitFlags::all()) }
                    }
                    /// Returns the raw value of the flags currently stored.
                    #[inline]
                    pub const fn bits(&self) -> u16 {
                        let f = self;
                        { f.0.bits() }
                    }
                    /// Convert from underlying bit representation, unless that
                    /// representation contains bits that do not correspond to a flag.
                    #[inline]
                    pub const fn from_bits(
                        bits: u16,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        let bits = bits;
                        {
                            match InternalBitFlags::from_bits(bits) {
                                ::bitflags::__private::core::option::Option::Some(bits) => {
                                    ::bitflags::__private::core::option::Option::Some(
                                        Self(bits),
                                    )
                                }
                                ::bitflags::__private::core::option::Option::None => {
                                    ::bitflags::__private::core::option::Option::None
                                }
                            }
                        }
                    }
                    /// Convert from underlying bit representation, dropping any bits
                    /// that do not correspond to flags.
                    #[inline]
                    pub const fn from_bits_truncate(bits: u16) -> Self {
                        let bits = bits;
                        { Self(InternalBitFlags::from_bits_truncate(bits)) }
                    }
                    /// Convert from underlying bit representation, preserving all
                    /// bits (even those not corresponding to a defined flag).
                    #[inline]
                    pub const fn from_bits_retain(bits: u16) -> Self {
                        let bits = bits;
                        { Self(InternalBitFlags::from_bits_retain(bits)) }
                    }
                    /// Get the value for a flag from its stringified name.
                    ///
                    /// Names are _case-sensitive_, so must correspond exactly to
                    /// the identifier given to the flag.
                    #[inline]
                    pub fn from_name(
                        name: &str,
                    ) -> ::bitflags::__private::core::option::Option<Self> {
                        let name = name;
                        {
                            match InternalBitFlags::from_name(name) {
                                ::bitflags::__private::core::option::Option::Some(bits) => {
                                    ::bitflags::__private::core::option::Option::Some(
                                        Self(bits),
                                    )
                                }
                                ::bitflags::__private::core::option::Option::None => {
                                    ::bitflags::__private::core::option::Option::None
                                }
                            }
                        }
                    }
                    /// Returns `true` if no flags are currently stored.
                    #[inline]
                    pub const fn is_empty(&self) -> bool {
                        let f = self;
                        { f.0.is_empty() }
                    }
                    /// Returns `true` if all flags are currently set.
                    #[inline]
                    pub const fn is_all(&self) -> bool {
                        let f = self;
                        { f.0.is_all() }
                    }
                    /// Returns `true` if there are flags common to both `self` and `other`.
                    #[inline]
                    pub const fn intersects(&self, other: Self) -> bool {
                        let f = self;
                        let other = other;
                        { f.0.intersects(other.0) }
                    }
                    /// Returns `true` if all of the flags in `other` are contained within `self`.
                    #[inline]
                    pub const fn contains(&self, other: Self) -> bool {
                        let f = self;
                        let other = other;
                        { f.0.contains(other.0) }
                    }
                    /// Inserts the specified flags in-place.
                    #[inline]
                    pub fn insert(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        { f.0.insert(other.0) }
                    }
                    /// Removes the specified flags in-place.
                    #[inline]
                    pub fn remove(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        { f.0.remove(other.0) }
                    }
                    /// Toggles the specified flags in-place.
                    #[inline]
                    pub fn toggle(&mut self, other: Self) {
                        let f = self;
                        let other = other;
                        { f.0.toggle(other.0) }
                    }
                    /// Inserts or removes the specified flags depending on the passed value.
                    #[inline]
                    pub fn set(&mut self, other: Self, value: bool) {
                        let f = self;
                        let other = other;
                        let value = value;
                        { f.0.set(other.0, value) }
                    }
                    /// Returns the intersection between the flags in `self` and
                    /// `other`.
                    ///
                    /// Specifically, the returned set contains only the flags which are
                    /// present in *both* `self` *and* `other`.
                    ///
                    /// This is equivalent to using the `&` operator (e.g.
                    /// [`ops::BitAnd`]), as in `flags & other`.
                    ///
                    /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                    #[inline]
                    #[must_use]
                    pub const fn intersection(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0.intersection(other.0)) }
                    }
                    /// Returns the union of between the flags in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains all flags which are
                    /// present in *either* `self` *or* `other`, including any which are
                    /// present in both (see [`Self::symmetric_difference`] if that
                    /// is undesirable).
                    ///
                    /// This is equivalent to using the `|` operator (e.g.
                    /// [`ops::BitOr`]), as in `flags | other`.
                    ///
                    /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                    #[inline]
                    #[must_use]
                    pub const fn union(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0.union(other.0)) }
                    }
                    /// Returns the difference between the flags in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains all flags present in
                    /// `self`, except for the ones present in `other`.
                    ///
                    /// It is also conceptually equivalent to the "bit-clear" operation:
                    /// `flags & !other` (and this syntax is also supported).
                    ///
                    /// This is equivalent to using the `-` operator (e.g.
                    /// [`ops::Sub`]), as in `flags - other`.
                    ///
                    /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                    #[inline]
                    #[must_use]
                    pub const fn difference(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0.difference(other.0)) }
                    }
                    /// Returns the [symmetric difference][sym-diff] between the flags
                    /// in `self` and `other`.
                    ///
                    /// Specifically, the returned set contains the flags present which
                    /// are present in `self` or `other`, but that are not present in
                    /// both. Equivalently, it contains the flags present in *exactly
                    /// one* of the sets `self` and `other`.
                    ///
                    /// This is equivalent to using the `^` operator (e.g.
                    /// [`ops::BitXor`]), as in `flags ^ other`.
                    ///
                    /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                    /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                    #[inline]
                    #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self {
                        let f = self;
                        let other = other;
                        { Self(f.0.symmetric_difference(other.0)) }
                    }
                    /// Returns the complement of this set of flags.
                    ///
                    /// Specifically, the returned set contains all the flags which are
                    /// not set in `self`, but which are allowed for this type.
                    ///
                    /// Alternatively, it can be thought of as the set difference
                    /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                    ///
                    /// This is equivalent to using the `!` operator (e.g.
                    /// [`ops::Not`]), as in `!flags`.
                    ///
                    /// [`Self::all()`]: Self::all
                    /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                    #[inline]
                    #[must_use]
                    pub const fn complement(self) -> Self {
                        let f = self;
                        { Self(f.0.complement()) }
                    }
                }
                impl ::bitflags::__private::core::fmt::Binary for ActivityFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::Binary::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::Octal for ActivityFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::Octal::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::LowerHex for ActivityFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::LowerHex::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::fmt::UpperHex for ActivityFlags {
                    fn fmt(
                        &self,
                        f: &mut ::bitflags::__private::core::fmt::Formatter,
                    ) -> ::bitflags::__private::core::fmt::Result {
                        ::bitflags::__private::core::fmt::UpperHex::fmt(&self.0, f)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOr for ActivityFlags {
                    type Output = Self;
                    /// Returns the union of the two sets of flags.
                    #[inline]
                    fn bitor(self, other: ActivityFlags) -> Self {
                        self.union(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitOrAssign for ActivityFlags {
                    /// Adds the set of flags.
                    #[inline]
                    fn bitor_assign(&mut self, other: Self) {
                        self.0 = self.0 | other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::BitXor for ActivityFlags {
                    type Output = Self;
                    /// Returns the left flags, but with all the right flags toggled.
                    #[inline]
                    fn bitxor(self, other: Self) -> Self {
                        self.symmetric_difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitXorAssign for ActivityFlags {
                    /// Toggles the set of flags.
                    #[inline]
                    fn bitxor_assign(&mut self, other: Self) {
                        self.0 = self.0 ^ other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::BitAnd for ActivityFlags {
                    type Output = Self;
                    /// Returns the intersection between the two sets of flags.
                    #[inline]
                    fn bitand(self, other: Self) -> Self {
                        self.intersection(other)
                    }
                }
                impl ::bitflags::__private::core::ops::BitAndAssign for ActivityFlags {
                    /// Disables all flags disabled in the set.
                    #[inline]
                    fn bitand_assign(&mut self, other: Self) {
                        self.0 = self.0 & other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::Sub for ActivityFlags {
                    type Output = Self;
                    /// Returns the set difference of the two sets of flags.
                    #[inline]
                    fn sub(self, other: Self) -> Self {
                        self.difference(other)
                    }
                }
                impl ::bitflags::__private::core::ops::SubAssign for ActivityFlags {
                    /// Disables all flags enabled in the set.
                    #[inline]
                    fn sub_assign(&mut self, other: Self) {
                        self.0 = self.0 & !other.0;
                    }
                }
                impl ::bitflags::__private::core::ops::Not for ActivityFlags {
                    type Output = Self;
                    /// Returns the complement of this set of flags.
                    #[inline]
                    fn not(self) -> Self {
                        self.complement()
                    }
                }
                impl ::bitflags::__private::core::iter::Extend<ActivityFlags>
                for ActivityFlags {
                    fn extend<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(&mut self, iterator: T) {
                        for item in iterator {
                            self.insert(item)
                        }
                    }
                }
                impl ::bitflags::__private::core::iter::FromIterator<ActivityFlags>
                for ActivityFlags {
                    fn from_iter<
                        T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                    >(iterator: T) -> Self {
                        use ::bitflags::__private::core::iter::Extend;
                        let mut result = Self::empty();
                        result.extend(iterator);
                        result
                    }
                }
                impl ActivityFlags {
                    /// Iterate over enabled flag values.
                    #[inline]
                    pub const fn iter(&self) -> ::bitflags::iter::Iter<ActivityFlags> {
                        ::bitflags::iter::Iter::__private_const_new(
                            <ActivityFlags as ::bitflags::Flags>::FLAGS,
                            ActivityFlags::from_bits_retain(self.bits()),
                            ActivityFlags::from_bits_retain(self.bits()),
                        )
                    }
                    /// Iterate over enabled flag values with their stringified names.
                    #[inline]
                    pub const fn iter_names(
                        &self,
                    ) -> ::bitflags::iter::IterNames<ActivityFlags> {
                        ::bitflags::iter::IterNames::__private_const_new(
                            <ActivityFlags as ::bitflags::Flags>::FLAGS,
                            ActivityFlags::from_bits_retain(self.bits()),
                            ActivityFlags::from_bits_retain(self.bits()),
                        )
                    }
                }
                impl ::bitflags::__private::core::iter::IntoIterator for ActivityFlags {
                    type Item = ActivityFlags;
                    type IntoIter = ::bitflags::iter::Iter<ActivityFlags>;
                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }
            };
            impl<'de> ::serde::Deserialize<'de> for ActivityFlags {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    <u16>::deserialize(deserializer).map(Self::from_bits_truncate)
                }
            }
            impl ::serde::Serialize for ActivityFlags {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    self.bits().serialize(serializer)
                }
            }
        }
        mod kind {
            use crate::internal::macros::enum_repr;
            #[non_exhaustive]
            pub enum ActivityType {
                Game = 0,
                Streaming = 1,
                Listening = 2,
                Watching = 3,
                Custom = 4,
                Competing = 5,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ActivityType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            ActivityType::Game => "Game",
                            ActivityType::Streaming => "Streaming",
                            ActivityType::Listening => "Listening",
                            ActivityType::Watching => "Watching",
                            ActivityType::Custom => "Custom",
                            ActivityType::Competing => "Competing",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActivityType {
                #[inline]
                fn clone(&self) -> ActivityType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ActivityType {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActivityType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActivityType {
                #[inline]
                fn eq(&self, other: &ActivityType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ActivityType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ActivityType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ActivityType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            impl ActivityType {
                #[doc(hidden)]
                fn __internal_enum_repr(value: u64) -> Option<Self> {
                    match value {
                        _ if value == ActivityType::Game.value() => Some(Self::Game),
                        _ if value == ActivityType::Streaming.value() => {
                            Some(Self::Streaming)
                        }
                        _ if value == ActivityType::Listening.value() => {
                            Some(Self::Listening)
                        }
                        _ if value == ActivityType::Watching.value() => {
                            Some(Self::Watching)
                        }
                        _ if value == ActivityType::Custom.value() => Some(Self::Custom),
                        _ if value == ActivityType::Competing.value() => {
                            Some(Self::Competing)
                        }
                        _ => None,
                    }
                }
            }
            impl ActivityType {
                pub const fn value(&self) -> u64 {
                    *self as u64
                }
            }
            impl<'de> serde::Deserialize<'de> for ActivityType {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ActivityType;
                        fn expecting(
                            &self,
                            f: &mut std::fmt::Formatter<'_>,
                        ) -> std::fmt::Result {
                            f.write_str("ActivityType type (integer)")
                        }
                        fn visit_u64<E>(self, value: u64) -> Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            ActivityType::__internal_enum_repr(value)
                                .ok_or_else(|| {
                                    serde::de::Error::custom({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unknown ActivityType variant: {0}", value),
                                        );
                                        res
                                    })
                                })
                        }
                    }
                    deserializer.deserialize_u64(Visitor)
                }
            }
            impl serde::Serialize for ActivityType {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    serializer.serialize_u64(self.value())
                }
            }
        }
        mod party {
            use serde::{Deserialize, Serialize};
            pub struct ActivityParty {
                #[serde(skip_serializing_if = "Option::is_none")]
                pub id: Option<String>,
                #[serde(skip_serializing_if = "Option::is_none")]
                pub size: Option<()>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ActivityParty {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ActivityParty",
                        "id",
                        &self.id,
                        "size",
                        &&self.size,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActivityParty {
                #[inline]
                fn clone(&self) -> ActivityParty {
                    ActivityParty {
                        id: ::core::clone::Clone::clone(&self.id),
                        size: ::core::clone::Clone::clone(&self.size),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActivityParty {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActivityParty {
                #[inline]
                fn eq(&self, other: &ActivityParty) -> bool {
                    self.id == other.id && self.size == other.size
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ActivityParty {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ActivityParty {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<()>>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ActivityParty {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.id, state);
                    ::core::hash::Hash::hash(&self.size, state)
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ActivityParty {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "id" => _serde::__private::Ok(__Field::__field0),
                                    "size" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"id" => _serde::__private::Ok(__Field::__field0),
                                    b"size" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ActivityParty>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ActivityParty;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ActivityParty",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ActivityParty with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match match _serde::de::SeqAccess::next_element::<
                                    Option<()>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ActivityParty with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ActivityParty {
                                    id: __field0,
                                    size: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Option<()>> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = match _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<()>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("id") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("size") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::__private::Ok(ActivityParty {
                                    id: __field0,
                                    size: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["id", "size"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ActivityParty",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ActivityParty>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ActivityParty {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "ActivityParty",
                            false as usize
                                + if Option::is_none(&self.id) { 0 } else { 1 }
                                + if Option::is_none(&self.size) { 0 } else { 1 },
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        if !Option::is_none(&self.id) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "id",
                                &self.id,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "id",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.size) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "size",
                                &self.size,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "size",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        }
        mod secrets {
            use serde::{Deserialize, Serialize};
            pub struct ActivitySecrets {
                #[serde(skip_serializing_if = "Option::is_none")]
                pub join: Option<String>,
                #[serde(skip_serializing_if = "Option::is_none")]
                pub spectate: Option<String>,
                #[serde(skip_serializing_if = "Option::is_none")]
                #[serde(rename = "match")]
                pub specified_match: Option<String>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ActivitySecrets {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ActivitySecrets",
                        "join",
                        &self.join,
                        "spectate",
                        &self.spectate,
                        "specified_match",
                        &&self.specified_match,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActivitySecrets {
                #[inline]
                fn clone(&self) -> ActivitySecrets {
                    ActivitySecrets {
                        join: ::core::clone::Clone::clone(&self.join),
                        spectate: ::core::clone::Clone::clone(&self.spectate),
                        specified_match: ::core::clone::Clone::clone(
                            &self.specified_match,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActivitySecrets {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActivitySecrets {
                #[inline]
                fn eq(&self, other: &ActivitySecrets) -> bool {
                    self.join == other.join && self.spectate == other.spectate
                        && self.specified_match == other.specified_match
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ActivitySecrets {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ActivitySecrets {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ActivitySecrets {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.join, state);
                    ::core::hash::Hash::hash(&self.spectate, state);
                    ::core::hash::Hash::hash(&self.specified_match, state)
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ActivitySecrets {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "join" => _serde::__private::Ok(__Field::__field0),
                                    "spectate" => _serde::__private::Ok(__Field::__field1),
                                    "match" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"join" => _serde::__private::Ok(__Field::__field0),
                                    b"spectate" => _serde::__private::Ok(__Field::__field1),
                                    b"match" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ActivitySecrets>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ActivitySecrets;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ActivitySecrets",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ActivitySecrets with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ActivitySecrets with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ActivitySecrets with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ActivitySecrets {
                                    join: __field0,
                                    spectate: __field1,
                                    specified_match: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = match _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("join"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "spectate",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("match"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("join") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("spectate") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("match") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::__private::Ok(ActivitySecrets {
                                    join: __field0,
                                    spectate: __field1,
                                    specified_match: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "join",
                            "spectate",
                            "match",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ActivitySecrets",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ActivitySecrets>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ActivitySecrets {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "ActivitySecrets",
                            false as usize
                                + if Option::is_none(&self.join) { 0 } else { 1 }
                                + if Option::is_none(&self.spectate) { 0 } else { 1 }
                                + if Option::is_none(&self.specified_match) { 0 } else { 1 },
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        if !Option::is_none(&self.join) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "join",
                                &self.join,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "join",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.spectate) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "spectate",
                                &self.spectate,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "spectate",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.specified_match) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "match",
                                &self.specified_match,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "match",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        }
        mod timestamps {
            use crate::misc::Timestamp;
            use serde::{Deserialize, Serialize};
            pub struct ActivityTimestamps {
                #[serde(skip_serializing_if = "Option::is_none")]
                #[serde(with = "crate::misc::timestamp::serde_impl::millis_opt")]
                #[serde(default)]
                pub start: Option<Timestamp>,
                #[serde(skip_serializing_if = "Option::is_none")]
                #[serde(with = "crate::misc::timestamp::serde_impl::millis_opt")]
                #[serde(default)]
                pub end: Option<Timestamp>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ActivityTimestamps {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ActivityTimestamps",
                        "start",
                        &self.start,
                        "end",
                        &&self.end,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActivityTimestamps {
                #[inline]
                fn clone(&self) -> ActivityTimestamps {
                    let _: ::core::clone::AssertParamIsClone<Option<Timestamp>>;
                    let _: ::core::clone::AssertParamIsClone<Option<Timestamp>>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ActivityTimestamps {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActivityTimestamps {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActivityTimestamps {
                #[inline]
                fn eq(&self, other: &ActivityTimestamps) -> bool {
                    self.start == other.start && self.end == other.end
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ActivityTimestamps {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ActivityTimestamps {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Option<Timestamp>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<Timestamp>>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ActivityTimestamps {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.start, state);
                    ::core::hash::Hash::hash(&self.end, state)
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ActivityTimestamps {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "start" => _serde::__private::Ok(__Field::__field0),
                                    "end" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"start" => _serde::__private::Ok(__Field::__field0),
                                    b"end" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ActivityTimestamps>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ActivityTimestamps;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ActivityTimestamps",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Option<Timestamp>,
                                        phantom: _serde::__private::PhantomData<ActivityTimestamps>,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: match crate::misc::timestamp::serde_impl::millis_opt::deserialize(
                                                    __deserializer,
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        match _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        _serde::__private::Default::default()
                                    }
                                };
                                let __field1 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Option<Timestamp>,
                                        phantom: _serde::__private::PhantomData<ActivityTimestamps>,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: match crate::misc::timestamp::serde_impl::millis_opt::deserialize(
                                                    __deserializer,
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        match _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        _serde::__private::Default::default()
                                    }
                                };
                                _serde::__private::Ok(ActivityTimestamps {
                                    start: __field0,
                                    end: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    Option<Timestamp>,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Option<Timestamp>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = match _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("start"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: Option<Timestamp>,
                                                    phantom: _serde::__private::PhantomData<ActivityTimestamps>,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: match crate::misc::timestamp::serde_impl::millis_opt::deserialize(
                                                                __deserializer,
                                                            ) {
                                                                _serde::__private::Ok(__val) => __val,
                                                                _serde::__private::Err(__err) => {
                                                                    return _serde::__private::Err(__err);
                                                                }
                                                            },
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("end"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: Option<Timestamp>,
                                                    phantom: _serde::__private::PhantomData<ActivityTimestamps>,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: match crate::misc::timestamp::serde_impl::millis_opt::deserialize(
                                                                __deserializer,
                                                            ) {
                                                                _serde::__private::Ok(__val) => __val,
                                                                _serde::__private::Err(__err) => {
                                                                    return _serde::__private::Err(__err);
                                                                }
                                                            },
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::Default::default()
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::Default::default()
                                    }
                                };
                                _serde::__private::Ok(ActivityTimestamps {
                                    start: __field0,
                                    end: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["start", "end"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ActivityTimestamps",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ActivityTimestamps,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ActivityTimestamps {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "ActivityTimestamps",
                            false as usize
                                + if Option::is_none(&self.start) { 0 } else { 1 }
                                + if Option::is_none(&self.end) { 0 } else { 1 },
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        if !Option::is_none(&self.start) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "start",
                                {
                                    #[doc(hidden)]
                                    struct __SerializeWith<'__a> {
                                        values: (&'__a Option<Timestamp>,),
                                        phantom: _serde::__private::PhantomData<ActivityTimestamps>,
                                    }
                                    impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                        fn serialize<__S>(
                                            &self,
                                            __s: __S,
                                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                        where
                                            __S: _serde::Serializer,
                                        {
                                            crate::misc::timestamp::serde_impl::millis_opt::serialize(
                                                self.values.0,
                                                __s,
                                            )
                                        }
                                    }
                                    &__SerializeWith {
                                        values: (&self.start,),
                                        phantom: _serde::__private::PhantomData::<
                                            ActivityTimestamps,
                                        >,
                                    }
                                },
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "start",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.end) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "end",
                                {
                                    #[doc(hidden)]
                                    struct __SerializeWith<'__a> {
                                        values: (&'__a Option<Timestamp>,),
                                        phantom: _serde::__private::PhantomData<ActivityTimestamps>,
                                    }
                                    impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                        fn serialize<__S>(
                                            &self,
                                            __s: __S,
                                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                        where
                                            __S: _serde::Serializer,
                                        {
                                            crate::misc::timestamp::serde_impl::millis_opt::serialize(
                                                self.values.0,
                                                __s,
                                            )
                                        }
                                    }
                                    &__SerializeWith {
                                        values: (&self.end,),
                                        phantom: _serde::__private::PhantomData::<
                                            ActivityTimestamps,
                                        >,
                                    }
                                },
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "end",
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                        }
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        }
        pub use assets::*;
        pub use button::*;
        pub use emoji::*;
        pub use flags::*;
        pub use kind::*;
        pub use party::*;
        pub use secrets::*;
        pub use timestamps::*;
        pub struct Activity {
            pub name: String,
            #[serde(rename = "type")]
            pub kind: ActivityType,
            pub url: Option<String>,
            #[serde(with = "crate::misc::timestamp::serde_impl::millis")]
            pub created_at: Timestamp,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub timestamps: Option<ActivityTimestamps>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub application_id: Option<ApplicationId>,
            pub details: Option<String>,
            #[serde(rename = "state")]
            pub status: Option<String>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub party: Option<ActivityParty>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub assets: Option<ActivityAsset>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub secrets: Option<ActivitySecrets>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub instance: Option<bool>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub flags: Option<ActivityFlags>,
            #[serde(default)]
            pub buttons: Vec<ActivityButton>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Activity {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "name",
                    "kind",
                    "url",
                    "created_at",
                    "timestamps",
                    "application_id",
                    "details",
                    "status",
                    "party",
                    "assets",
                    "secrets",
                    "instance",
                    "flags",
                    "buttons",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.name,
                    &self.kind,
                    &self.url,
                    &self.created_at,
                    &self.timestamps,
                    &self.application_id,
                    &self.details,
                    &self.status,
                    &self.party,
                    &self.assets,
                    &self.secrets,
                    &self.instance,
                    &self.flags,
                    &&self.buttons,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Activity",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Activity {
            #[inline]
            fn clone(&self) -> Activity {
                Activity {
                    name: ::core::clone::Clone::clone(&self.name),
                    kind: ::core::clone::Clone::clone(&self.kind),
                    url: ::core::clone::Clone::clone(&self.url),
                    created_at: ::core::clone::Clone::clone(&self.created_at),
                    timestamps: ::core::clone::Clone::clone(&self.timestamps),
                    application_id: ::core::clone::Clone::clone(&self.application_id),
                    details: ::core::clone::Clone::clone(&self.details),
                    status: ::core::clone::Clone::clone(&self.status),
                    party: ::core::clone::Clone::clone(&self.party),
                    assets: ::core::clone::Clone::clone(&self.assets),
                    secrets: ::core::clone::Clone::clone(&self.secrets),
                    instance: ::core::clone::Clone::clone(&self.instance),
                    flags: ::core::clone::Clone::clone(&self.flags),
                    buttons: ::core::clone::Clone::clone(&self.buttons),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Activity {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Activity {
            #[inline]
            fn eq(&self, other: &Activity) -> bool {
                self.name == other.name && self.kind == other.kind
                    && self.url == other.url && self.created_at == other.created_at
                    && self.timestamps == other.timestamps
                    && self.application_id == other.application_id
                    && self.details == other.details && self.status == other.status
                    && self.party == other.party && self.assets == other.assets
                    && self.secrets == other.secrets && self.instance == other.instance
                    && self.flags == other.flags && self.buttons == other.buttons
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Activity {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Activity {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<ActivityType>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Timestamp>;
                let _: ::core::cmp::AssertParamIsEq<Option<ActivityTimestamps>>;
                let _: ::core::cmp::AssertParamIsEq<Option<ApplicationId>>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Option<ActivityParty>>;
                let _: ::core::cmp::AssertParamIsEq<Option<ActivityAsset>>;
                let _: ::core::cmp::AssertParamIsEq<Option<ActivitySecrets>>;
                let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
                let _: ::core::cmp::AssertParamIsEq<Option<ActivityFlags>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<ActivityButton>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Activity {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.name, state);
                ::core::hash::Hash::hash(&self.kind, state);
                ::core::hash::Hash::hash(&self.url, state);
                ::core::hash::Hash::hash(&self.created_at, state);
                ::core::hash::Hash::hash(&self.timestamps, state);
                ::core::hash::Hash::hash(&self.application_id, state);
                ::core::hash::Hash::hash(&self.details, state);
                ::core::hash::Hash::hash(&self.status, state);
                ::core::hash::Hash::hash(&self.party, state);
                ::core::hash::Hash::hash(&self.assets, state);
                ::core::hash::Hash::hash(&self.secrets, state);
                ::core::hash::Hash::hash(&self.instance, state);
                ::core::hash::Hash::hash(&self.flags, state);
                ::core::hash::Hash::hash(&self.buttons, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Activity {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                        __field13,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                12u64 => _serde::__private::Ok(__Field::__field12),
                                13u64 => _serde::__private::Ok(__Field::__field13),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "type" => _serde::__private::Ok(__Field::__field1),
                                "url" => _serde::__private::Ok(__Field::__field2),
                                "created_at" => _serde::__private::Ok(__Field::__field3),
                                "timestamps" => _serde::__private::Ok(__Field::__field4),
                                "application_id" => _serde::__private::Ok(__Field::__field5),
                                "details" => _serde::__private::Ok(__Field::__field6),
                                "state" => _serde::__private::Ok(__Field::__field7),
                                "party" => _serde::__private::Ok(__Field::__field8),
                                "assets" => _serde::__private::Ok(__Field::__field9),
                                "secrets" => _serde::__private::Ok(__Field::__field10),
                                "instance" => _serde::__private::Ok(__Field::__field11),
                                "flags" => _serde::__private::Ok(__Field::__field12),
                                "buttons" => _serde::__private::Ok(__Field::__field13),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"type" => _serde::__private::Ok(__Field::__field1),
                                b"url" => _serde::__private::Ok(__Field::__field2),
                                b"created_at" => _serde::__private::Ok(__Field::__field3),
                                b"timestamps" => _serde::__private::Ok(__Field::__field4),
                                b"application_id" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                b"details" => _serde::__private::Ok(__Field::__field6),
                                b"state" => _serde::__private::Ok(__Field::__field7),
                                b"party" => _serde::__private::Ok(__Field::__field8),
                                b"assets" => _serde::__private::Ok(__Field::__field9),
                                b"secrets" => _serde::__private::Ok(__Field::__field10),
                                b"instance" => _serde::__private::Ok(__Field::__field11),
                                b"flags" => _serde::__private::Ok(__Field::__field12),
                                b"buttons" => _serde::__private::Ok(__Field::__field13),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Activity>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Activity;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Activity",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                ActivityType,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<'de> {
                                    value: Timestamp,
                                    phantom: _serde::__private::PhantomData<Activity>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::Deserialize<'de>
                                for __DeserializeWith<'de> {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: match crate::misc::timestamp::serde_impl::millis::deserialize(
                                                __deserializer,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    match _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<'de>,
                                    >(&mut __seq) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Option<ActivityTimestamps>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                Option<ApplicationId>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match match _serde::de::SeqAccess::next_element::<
                                Option<ActivityParty>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field9 = match match _serde::de::SeqAccess::next_element::<
                                Option<ActivityAsset>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field10 = match match _serde::de::SeqAccess::next_element::<
                                Option<ActivitySecrets>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field11 = match match _serde::de::SeqAccess::next_element::<
                                Option<bool>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            11usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field12 = match match _serde::de::SeqAccess::next_element::<
                                Option<ActivityFlags>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            12usize,
                                            &"struct Activity with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field13 = match match _serde::de::SeqAccess::next_element::<
                                Vec<ActivityButton>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    _serde::__private::Default::default()
                                }
                            };
                            _serde::__private::Ok(Activity {
                                name: __field0,
                                kind: __field1,
                                url: __field2,
                                created_at: __field3,
                                timestamps: __field4,
                                application_id: __field5,
                                details: __field6,
                                status: __field7,
                                party: __field8,
                                assets: __field9,
                                secrets: __field10,
                                instance: __field11,
                                flags: __field12,
                                buttons: __field13,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<ActivityType> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Timestamp> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                Option<ActivityTimestamps>,
                            > = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<
                                Option<ApplicationId>,
                            > = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<
                                Option<ActivityParty>,
                            > = _serde::__private::None;
                            let mut __field9: _serde::__private::Option<
                                Option<ActivityAsset>,
                            > = _serde::__private::None;
                            let mut __field10: _serde::__private::Option<
                                Option<ActivitySecrets>,
                            > = _serde::__private::None;
                            let mut __field11: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                            let mut __field12: _serde::__private::Option<
                                Option<ActivityFlags>,
                            > = _serde::__private::None;
                            let mut __field13: _serde::__private::Option<
                                Vec<ActivityButton>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = match _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                String,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("type"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ActivityType,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("url"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "created_at",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de> {
                                                value: Timestamp,
                                                phantom: _serde::__private::PhantomData<Activity>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            impl<'de> _serde::Deserialize<'de>
                                            for __DeserializeWith<'de> {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: match crate::misc::timestamp::serde_impl::millis::deserialize(
                                                            __deserializer,
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<'de>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "timestamps",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ActivityTimestamps>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "application_id",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ApplicationId>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "details",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("state"),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("party"),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ActivityParty>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::__private::Option::is_some(&__field9) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("assets"),
                                            );
                                        }
                                        __field9 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ActivityAsset>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field10 => {
                                        if _serde::__private::Option::is_some(&__field10) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "secrets",
                                                ),
                                            );
                                        }
                                        __field10 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ActivitySecrets>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field11 => {
                                        if _serde::__private::Option::is_some(&__field11) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "instance",
                                                ),
                                            );
                                        }
                                        __field11 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<bool>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field12 => {
                                        if _serde::__private::Option::is_some(&__field12) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("flags"),
                                            );
                                        }
                                        __field12 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ActivityFlags>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field13 => {
                                        if _serde::__private::Option::is_some(&__field13) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "buttons",
                                                ),
                                            );
                                        }
                                        __field13 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Vec<ActivityButton>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("name") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("type") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("url") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field(
                                            "created_at",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("timestamps") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "application_id",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("details") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("state") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("party") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::__private::Some(__field9) => __field9,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("assets") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field10 = match __field10 {
                                _serde::__private::Some(__field10) => __field10,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("secrets") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field11 = match __field11 {
                                _serde::__private::Some(__field11) => __field11,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("instance") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field12 = match __field12 {
                                _serde::__private::Some(__field12) => __field12,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("flags") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field13 = match __field13 {
                                _serde::__private::Some(__field13) => __field13,
                                _serde::__private::None => {
                                    _serde::__private::Default::default()
                                }
                            };
                            _serde::__private::Ok(Activity {
                                name: __field0,
                                kind: __field1,
                                url: __field2,
                                created_at: __field3,
                                timestamps: __field4,
                                application_id: __field5,
                                details: __field6,
                                status: __field7,
                                party: __field8,
                                assets: __field9,
                                secrets: __field10,
                                instance: __field11,
                                flags: __field12,
                                buttons: __field13,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "name",
                        "type",
                        "url",
                        "created_at",
                        "timestamps",
                        "application_id",
                        "details",
                        "state",
                        "party",
                        "assets",
                        "secrets",
                        "instance",
                        "flags",
                        "buttons",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Activity",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Activity>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Activity {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Activity",
                        false as usize + 1 + 1 + 1 + 1
                            + if Option::is_none(&self.timestamps) { 0 } else { 1 }
                            + if Option::is_none(&self.application_id) { 0 } else { 1 }
                            + 1 + 1 + if Option::is_none(&self.party) { 0 } else { 1 }
                            + if Option::is_none(&self.assets) { 0 } else { 1 }
                            + if Option::is_none(&self.secrets) { 0 } else { 1 }
                            + if Option::is_none(&self.instance) { 0 } else { 1 }
                            + if Option::is_none(&self.flags) { 0 } else { 1 } + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "type",
                        &self.kind,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "url",
                        &self.url,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "created_at",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<'__a> {
                                values: (&'__a Timestamp,),
                                phantom: _serde::__private::PhantomData<Activity>,
                            }
                            impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    crate::misc::timestamp::serde_impl::millis::serialize(
                                        self.values.0,
                                        __s,
                                    )
                                }
                            }
                            &__SerializeWith {
                                values: (&self.created_at,),
                                phantom: _serde::__private::PhantomData::<Activity>,
                            }
                        },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.timestamps) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "timestamps",
                            &self.timestamps,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "timestamps",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.application_id) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "application_id",
                            &self.application_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "application_id",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "details",
                        &self.details,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "state",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.party) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "party",
                            &self.party,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "party",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.assets) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "assets",
                            &self.assets,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "assets",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.secrets) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "secrets",
                            &self.secrets,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "secrets",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.instance) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "instance",
                            &self.instance,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "instance",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.flags) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "flags",
                            &self.flags,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "flags",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "buttons",
                        &self.buttons,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    }
    mod statuses {
        use crate::internal::macros::enum_string;
        use serde::{Deserialize, Serialize};
        #[non_exhaustive]
        pub enum PresenceStatus {
            Online,
            DoNotDisturb,
            AFK,
            Invisible,
            Offline,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PresenceStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        PresenceStatus::Online => "Online",
                        PresenceStatus::DoNotDisturb => "DoNotDisturb",
                        PresenceStatus::AFK => "AFK",
                        PresenceStatus::Invisible => "Invisible",
                        PresenceStatus::Offline => "Offline",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PresenceStatus {
            #[inline]
            fn clone(&self) -> PresenceStatus {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for PresenceStatus {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PresenceStatus {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PresenceStatus {
            #[inline]
            fn eq(&self, other: &PresenceStatus) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for PresenceStatus {}
        #[automatically_derived]
        impl ::core::cmp::Eq for PresenceStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PresenceStatus {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl PresenceStatus {
            #[doc(hidden)]
            fn __internal_enum_string(value: &str) -> Option<Self> {
                match value {
                    "online" => Some(Self::Online),
                    "dnd" => Some(Self::DoNotDisturb),
                    "idle" => Some(Self::AFK),
                    "invisible" => Some(Self::Invisible),
                    "offline" => Some(Self::Offline),
                    _ => None,
                }
            }
        }
        impl std::fmt::Display for PresenceStatus {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                match self {
                    Self::Online => f.write_str("online"),
                    Self::DoNotDisturb => f.write_str("dnd"),
                    Self::AFK => f.write_str("idle"),
                    Self::Invisible => f.write_str("invisible"),
                    Self::Offline => f.write_str("offline"),
                }
            }
        }
        impl<'de> serde::Deserialize<'de> for PresenceStatus {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = PresenceStatus;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("PresenceStatus enum")
                    }
                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        PresenceStatus::__internal_enum_string(value)
                            .ok_or_else(|| {
                                serde::de::Error::custom({
                                    let res = ::alloc::fmt::format(
                                        format_args!("unknown PresenceStatus variant: {0:?}", value),
                                    );
                                    res
                                })
                            })
                    }
                }
                deserializer.deserialize_str(Visitor)
            }
        }
        impl serde::Serialize for PresenceStatus {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                serializer.collect_str(self)
            }
        }
        pub struct ClientPresenceStatus {
            #[serde(skip_serializing_if = "Option::is_none")]
            pub desktop: Option<PresenceStatus>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub mobile: Option<PresenceStatus>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub web: Option<PresenceStatus>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ClientPresenceStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "ClientPresenceStatus",
                    "desktop",
                    &self.desktop,
                    "mobile",
                    &self.mobile,
                    "web",
                    &&self.web,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ClientPresenceStatus {
            #[inline]
            fn clone(&self) -> ClientPresenceStatus {
                let _: ::core::clone::AssertParamIsClone<Option<PresenceStatus>>;
                let _: ::core::clone::AssertParamIsClone<Option<PresenceStatus>>;
                let _: ::core::clone::AssertParamIsClone<Option<PresenceStatus>>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ClientPresenceStatus {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ClientPresenceStatus {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ClientPresenceStatus {
            #[inline]
            fn eq(&self, other: &ClientPresenceStatus) -> bool {
                self.desktop == other.desktop && self.mobile == other.mobile
                    && self.web == other.web
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for ClientPresenceStatus {}
        #[automatically_derived]
        impl ::core::cmp::Eq for ClientPresenceStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Option<PresenceStatus>>;
                let _: ::core::cmp::AssertParamIsEq<Option<PresenceStatus>>;
                let _: ::core::cmp::AssertParamIsEq<Option<PresenceStatus>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ClientPresenceStatus {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.desktop, state);
                ::core::hash::Hash::hash(&self.mobile, state);
                ::core::hash::Hash::hash(&self.web, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ClientPresenceStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "desktop" => _serde::__private::Ok(__Field::__field0),
                                "mobile" => _serde::__private::Ok(__Field::__field1),
                                "web" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"desktop" => _serde::__private::Ok(__Field::__field0),
                                b"mobile" => _serde::__private::Ok(__Field::__field1),
                                b"web" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ClientPresenceStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ClientPresenceStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ClientPresenceStatus",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<PresenceStatus>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ClientPresenceStatus with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<PresenceStatus>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ClientPresenceStatus with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<PresenceStatus>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ClientPresenceStatus with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ClientPresenceStatus {
                                desktop: __field0,
                                mobile: __field1,
                                web: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Option<PresenceStatus>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Option<PresenceStatus>,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<PresenceStatus>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = match _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "desktop",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<PresenceStatus>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("mobile"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<PresenceStatus>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("web"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<PresenceStatus>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("desktop") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("mobile") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("web") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ClientPresenceStatus {
                                desktop: __field0,
                                mobile: __field1,
                                web: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "desktop",
                        "mobile",
                        "web",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ClientPresenceStatus",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ClientPresenceStatus,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ClientPresenceStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ClientPresenceStatus",
                        false as usize
                            + if Option::is_none(&self.desktop) { 0 } else { 1 }
                            + if Option::is_none(&self.mobile) { 0 } else { 1 }
                            + if Option::is_none(&self.web) { 0 } else { 1 },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.desktop) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "desktop",
                            &self.desktop,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "desktop",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.mobile) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "mobile",
                            &self.mobile,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "mobile",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.web) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "web",
                            &self.web,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "web",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    }
    pub use activity::*;
    pub use statuses::*;
}
pub mod user {
    use crate::id::UserId;
    use crate::misc::{Color, ImageHash, Locale};
    use serde::{Deserialize, Serialize};
    mod connection {
        use serde::{Deserialize, Serialize};
        mod service {
            use crate::internal::macros::enum_string;
            #[non_exhaustive]
            pub enum ConnectionService {
                BattleNet,
                Ebay,
                EpicGames,
                Facebook,
                GitHub,
                Instagram,
                LeagueOfLegends,
                Paypal,
                PlayStationNetwork,
                Reddit,
                RiotGames,
                Spotify,
                Skype,
                Steam,
                TikTok,
                Twitch,
                Twitter,
                Xbox,
                YouTube,
                Unknown(String),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ConnectionService {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        ConnectionService::BattleNet => {
                            ::core::fmt::Formatter::write_str(f, "BattleNet")
                        }
                        ConnectionService::Ebay => {
                            ::core::fmt::Formatter::write_str(f, "Ebay")
                        }
                        ConnectionService::EpicGames => {
                            ::core::fmt::Formatter::write_str(f, "EpicGames")
                        }
                        ConnectionService::Facebook => {
                            ::core::fmt::Formatter::write_str(f, "Facebook")
                        }
                        ConnectionService::GitHub => {
                            ::core::fmt::Formatter::write_str(f, "GitHub")
                        }
                        ConnectionService::Instagram => {
                            ::core::fmt::Formatter::write_str(f, "Instagram")
                        }
                        ConnectionService::LeagueOfLegends => {
                            ::core::fmt::Formatter::write_str(f, "LeagueOfLegends")
                        }
                        ConnectionService::Paypal => {
                            ::core::fmt::Formatter::write_str(f, "Paypal")
                        }
                        ConnectionService::PlayStationNetwork => {
                            ::core::fmt::Formatter::write_str(f, "PlayStationNetwork")
                        }
                        ConnectionService::Reddit => {
                            ::core::fmt::Formatter::write_str(f, "Reddit")
                        }
                        ConnectionService::RiotGames => {
                            ::core::fmt::Formatter::write_str(f, "RiotGames")
                        }
                        ConnectionService::Spotify => {
                            ::core::fmt::Formatter::write_str(f, "Spotify")
                        }
                        ConnectionService::Skype => {
                            ::core::fmt::Formatter::write_str(f, "Skype")
                        }
                        ConnectionService::Steam => {
                            ::core::fmt::Formatter::write_str(f, "Steam")
                        }
                        ConnectionService::TikTok => {
                            ::core::fmt::Formatter::write_str(f, "TikTok")
                        }
                        ConnectionService::Twitch => {
                            ::core::fmt::Formatter::write_str(f, "Twitch")
                        }
                        ConnectionService::Twitter => {
                            ::core::fmt::Formatter::write_str(f, "Twitter")
                        }
                        ConnectionService::Xbox => {
                            ::core::fmt::Formatter::write_str(f, "Xbox")
                        }
                        ConnectionService::YouTube => {
                            ::core::fmt::Formatter::write_str(f, "YouTube")
                        }
                        ConnectionService::Unknown(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Unknown",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ConnectionService {
                #[inline]
                fn clone(&self) -> ConnectionService {
                    match self {
                        ConnectionService::BattleNet => ConnectionService::BattleNet,
                        ConnectionService::Ebay => ConnectionService::Ebay,
                        ConnectionService::EpicGames => ConnectionService::EpicGames,
                        ConnectionService::Facebook => ConnectionService::Facebook,
                        ConnectionService::GitHub => ConnectionService::GitHub,
                        ConnectionService::Instagram => ConnectionService::Instagram,
                        ConnectionService::LeagueOfLegends => {
                            ConnectionService::LeagueOfLegends
                        }
                        ConnectionService::Paypal => ConnectionService::Paypal,
                        ConnectionService::PlayStationNetwork => {
                            ConnectionService::PlayStationNetwork
                        }
                        ConnectionService::Reddit => ConnectionService::Reddit,
                        ConnectionService::RiotGames => ConnectionService::RiotGames,
                        ConnectionService::Spotify => ConnectionService::Spotify,
                        ConnectionService::Skype => ConnectionService::Skype,
                        ConnectionService::Steam => ConnectionService::Steam,
                        ConnectionService::TikTok => ConnectionService::TikTok,
                        ConnectionService::Twitch => ConnectionService::Twitch,
                        ConnectionService::Twitter => ConnectionService::Twitter,
                        ConnectionService::Xbox => ConnectionService::Xbox,
                        ConnectionService::YouTube => ConnectionService::YouTube,
                        ConnectionService::Unknown(__self_0) => {
                            ConnectionService::Unknown(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ConnectionService {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ConnectionService {
                #[inline]
                fn eq(&self, other: &ConnectionService) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                ConnectionService::Unknown(__self_0),
                                ConnectionService::Unknown(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => true,
                        }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ConnectionService {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ConnectionService {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ConnectionService {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        ConnectionService::Unknown(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        _ => {}
                    }
                }
            }
            impl ConnectionService {
                #[doc(hidden)]
                fn __internal_enum_string(value: &str) -> Option<Self> {
                    match value {
                        "battlenet" => Some(Self::BattleNet),
                        "ebay" => Some(Self::Ebay),
                        "epicgames" => Some(Self::EpicGames),
                        "facebook" => Some(Self::Facebook),
                        "github" => Some(Self::GitHub),
                        "instagram" => Some(Self::Instagram),
                        "leagueoflegends" => Some(Self::LeagueOfLegends),
                        "paypal" => Some(Self::Paypal),
                        "playstation" => Some(Self::PlayStationNetwork),
                        "reddit" => Some(Self::Reddit),
                        "riotgames" => Some(Self::RiotGames),
                        "spotify" => Some(Self::Spotify),
                        "skype" => Some(Self::Skype),
                        "steam" => Some(Self::Steam),
                        "tiktok" => Some(Self::TikTok),
                        "twitch" => Some(Self::Twitch),
                        "twitter" => Some(Self::Twitter),
                        "xbox" => Some(Self::Xbox),
                        "youtube" => Some(Self::YouTube),
                        _ => Some(Self::Unknown(value.to_string())),
                    }
                }
            }
            impl std::fmt::Display for ConnectionService {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        Self::BattleNet => f.write_str("battlenet"),
                        Self::Ebay => f.write_str("ebay"),
                        Self::EpicGames => f.write_str("epicgames"),
                        Self::Facebook => f.write_str("facebook"),
                        Self::GitHub => f.write_str("github"),
                        Self::Instagram => f.write_str("instagram"),
                        Self::LeagueOfLegends => f.write_str("leagueoflegends"),
                        Self::Paypal => f.write_str("paypal"),
                        Self::PlayStationNetwork => f.write_str("playstation"),
                        Self::Reddit => f.write_str("reddit"),
                        Self::RiotGames => f.write_str("riotgames"),
                        Self::Spotify => f.write_str("spotify"),
                        Self::Skype => f.write_str("skype"),
                        Self::Steam => f.write_str("steam"),
                        Self::TikTok => f.write_str("tiktok"),
                        Self::Twitch => f.write_str("twitch"),
                        Self::Twitter => f.write_str("twitter"),
                        Self::Xbox => f.write_str("xbox"),
                        Self::YouTube => f.write_str("youtube"),
                        Self::Unknown(n) => n.fmt(f),
                    }
                }
            }
            impl<'de> serde::Deserialize<'de> for ConnectionService {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ConnectionService;
                        fn expecting(
                            &self,
                            f: &mut std::fmt::Formatter<'_>,
                        ) -> std::fmt::Result {
                            f.write_str("ConnectionService enum")
                        }
                        fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            ConnectionService::__internal_enum_string(value)
                                .ok_or_else(|| {
                                    serde::de::Error::custom({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "unknown ConnectionService variant: {0:?}", value
                                            ),
                                        );
                                        res
                                    })
                                })
                        }
                    }
                    deserializer.deserialize_str(Visitor)
                }
            }
            impl serde::Serialize for ConnectionService {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    serializer.collect_str(self)
                }
            }
        }
        mod visibility {
            use crate::internal::macros::enum_repr;
            #[non_exhaustive]
            pub enum ConnectionVisibility {
                None = 0,
                Everyone = 1,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ConnectionVisibility {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            ConnectionVisibility::None => "None",
                            ConnectionVisibility::Everyone => "Everyone",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ConnectionVisibility {
                #[inline]
                fn clone(&self) -> ConnectionVisibility {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ConnectionVisibility {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ConnectionVisibility {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ConnectionVisibility {
                #[inline]
                fn eq(&self, other: &ConnectionVisibility) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ConnectionVisibility {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ConnectionVisibility {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ConnectionVisibility {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            impl ConnectionVisibility {
                #[doc(hidden)]
                fn __internal_enum_repr(value: u64) -> Option<Self> {
                    match value {
                        _ if value == ConnectionVisibility::None.value() => {
                            Some(Self::None)
                        }
                        _ if value == ConnectionVisibility::Everyone.value() => {
                            Some(Self::Everyone)
                        }
                        _ => None,
                    }
                }
            }
            impl ConnectionVisibility {
                pub const fn value(&self) -> u64 {
                    *self as u64
                }
            }
            impl<'de> serde::Deserialize<'de> for ConnectionVisibility {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ConnectionVisibility;
                        fn expecting(
                            &self,
                            f: &mut std::fmt::Formatter<'_>,
                        ) -> std::fmt::Result {
                            f.write_str("ConnectionVisibility type (integer)")
                        }
                        fn visit_u64<E>(self, value: u64) -> Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            ConnectionVisibility::__internal_enum_repr(value)
                                .ok_or_else(|| {
                                    serde::de::Error::custom({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "unknown ConnectionVisibility variant: {0}", value
                                            ),
                                        );
                                        res
                                    })
                                })
                        }
                    }
                    deserializer.deserialize_u64(Visitor)
                }
            }
            impl serde::Serialize for ConnectionVisibility {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    serializer.serialize_u64(self.value())
                }
            }
        }
        pub use service::*;
        pub use visibility::*;
        pub struct Connection {
            pub id: String,
            pub name: String,
            #[serde(rename = "type")]
            pub service: ConnectionService,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub revoked: Option<bool>,
            pub verified: bool,
            pub friend_sync: bool,
            pub show_activity: bool,
            pub two_way_link: bool,
            pub visibility: ConnectionVisibility,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Connection {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "name",
                    "service",
                    "revoked",
                    "verified",
                    "friend_sync",
                    "show_activity",
                    "two_way_link",
                    "visibility",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.name,
                    &self.service,
                    &self.revoked,
                    &self.verified,
                    &self.friend_sync,
                    &self.show_activity,
                    &self.two_way_link,
                    &&self.visibility,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Connection",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Connection {
            #[inline]
            fn clone(&self) -> Connection {
                Connection {
                    id: ::core::clone::Clone::clone(&self.id),
                    name: ::core::clone::Clone::clone(&self.name),
                    service: ::core::clone::Clone::clone(&self.service),
                    revoked: ::core::clone::Clone::clone(&self.revoked),
                    verified: ::core::clone::Clone::clone(&self.verified),
                    friend_sync: ::core::clone::Clone::clone(&self.friend_sync),
                    show_activity: ::core::clone::Clone::clone(&self.show_activity),
                    two_way_link: ::core::clone::Clone::clone(&self.two_way_link),
                    visibility: ::core::clone::Clone::clone(&self.visibility),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Connection {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Connection {
            #[inline]
            fn eq(&self, other: &Connection) -> bool {
                self.id == other.id && self.name == other.name
                    && self.service == other.service && self.revoked == other.revoked
                    && self.verified == other.verified
                    && self.friend_sync == other.friend_sync
                    && self.show_activity == other.show_activity
                    && self.two_way_link == other.two_way_link
                    && self.visibility == other.visibility
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Connection {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Connection {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<ConnectionService>;
                let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<ConnectionVisibility>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Connection {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.id, state);
                ::core::hash::Hash::hash(&self.name, state);
                ::core::hash::Hash::hash(&self.service, state);
                ::core::hash::Hash::hash(&self.revoked, state);
                ::core::hash::Hash::hash(&self.verified, state);
                ::core::hash::Hash::hash(&self.friend_sync, state);
                ::core::hash::Hash::hash(&self.show_activity, state);
                ::core::hash::Hash::hash(&self.two_way_link, state);
                ::core::hash::Hash::hash(&self.visibility, state)
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Connection {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "name" => _serde::__private::Ok(__Field::__field1),
                                "type" => _serde::__private::Ok(__Field::__field2),
                                "revoked" => _serde::__private::Ok(__Field::__field3),
                                "verified" => _serde::__private::Ok(__Field::__field4),
                                "friend_sync" => _serde::__private::Ok(__Field::__field5),
                                "show_activity" => _serde::__private::Ok(__Field::__field6),
                                "two_way_link" => _serde::__private::Ok(__Field::__field7),
                                "visibility" => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"name" => _serde::__private::Ok(__Field::__field1),
                                b"type" => _serde::__private::Ok(__Field::__field2),
                                b"revoked" => _serde::__private::Ok(__Field::__field3),
                                b"verified" => _serde::__private::Ok(__Field::__field4),
                                b"friend_sync" => _serde::__private::Ok(__Field::__field5),
                                b"show_activity" => _serde::__private::Ok(__Field::__field6),
                                b"two_way_link" => _serde::__private::Ok(__Field::__field7),
                                b"visibility" => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Connection>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Connection;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Connection",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Connection with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Connection with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                ConnectionService,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Connection with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Option<bool>,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Connection with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct Connection with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct Connection with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct Connection with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct Connection with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match match _serde::de::SeqAccess::next_element::<
                                ConnectionVisibility,
                            >(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct Connection with 9 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Connection {
                                id: __field0,
                                name: __field1,
                                service: __field2,
                                revoked: __field3,
                                verified: __field4,
                                friend_sync: __field5,
                                show_activity: __field6,
                                two_way_link: __field7,
                                visibility: __field8,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                ConnectionService,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<
                                ConnectionVisibility,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = match _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                String,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                String,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("type"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ConnectionService,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "revoked",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<bool>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "verified",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                bool,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "friend_sync",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                bool,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "show_activity",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                bool,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "two_way_link",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                bool,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "visibility",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ConnectionVisibility,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("id") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("name") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("type") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("revoked") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("verified") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("friend_sync") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "show_activity",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("two_way_link") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("visibility") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Connection {
                                id: __field0,
                                name: __field1,
                                service: __field2,
                                revoked: __field3,
                                verified: __field4,
                                friend_sync: __field5,
                                show_activity: __field6,
                                two_way_link: __field7,
                                visibility: __field8,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "name",
                        "type",
                        "revoked",
                        "verified",
                        "friend_sync",
                        "show_activity",
                        "two_way_link",
                        "visibility",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Connection",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Connection>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Connection {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Connection",
                        false as usize + 1 + 1 + 1
                            + if Option::is_none(&self.revoked) { 0 } else { 1 } + 1 + 1
                            + 1 + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "type",
                        &self.service,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.revoked) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "revoked",
                            &self.revoked,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "revoked",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "verified",
                        &self.verified,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "friend_sync",
                        &self.friend_sync,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "show_activity",
                        &self.show_activity,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "two_way_link",
                        &self.two_way_link,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "visibility",
                        &self.visibility,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    }
    mod discriminator {
        use serde::{Deserialize, Serialize};
        #[must_use]
        pub struct Discriminator(u16);
        #[automatically_derived]
        impl ::core::fmt::Debug for Discriminator {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Discriminator",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Discriminator {
            #[inline]
            fn clone(&self) -> Discriminator {
                let _: ::core::clone::AssertParamIsClone<u16>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Discriminator {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Discriminator {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Discriminator {
            #[inline]
            fn eq(&self, other: &Discriminator) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Discriminator {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Discriminator {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u16>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Discriminator {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Discriminator,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Discriminator {
            #[inline]
            fn cmp(&self, other: &Discriminator) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Discriminator {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        const MAX_DIGITS: u32 = 4;
        const MAX_MASK: u16 = 10_u16.pow(MAX_DIGITS) - 1;
        impl Discriminator {
            pub const fn new(value: u16) -> Self {
                if !Self::is_valid(value) {
                    ::core::panicking::panic_fmt(
                        format_args!("number must be less than 4 digits"),
                    )
                }
                Self(value)
            }
            pub const fn new_checked(value: u16) -> Option<Self> {
                if Self::is_valid(value) { Some(Self(value)) } else { None }
            }
            pub const fn is_valid(value: u16) -> bool {
                value <= MAX_MASK
            }
            pub const fn value(self) -> u16 {
                self.0
            }
        }
        impl std::fmt::Display for Discriminator {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(format_args!("{0:04}", self.0))
            }
        }
        impl<'de> Deserialize<'de> for Discriminator {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                use serde::de::Error as DeError;
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Discriminator;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("user discriminator (integer or string)")
                    }
                    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        self.visit_u16(v.parse::<u16>().map_err(DeError::custom)?)
                    }
                    fn visit_u16<E>(self, v: u16) -> Result<Self::Value, E>
                    where
                        E: DeError,
                    {
                        Discriminator::new_checked(v)
                            .ok_or_else(|| {
                                DeError::custom({
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0:?} is too big for user discriminator", v),
                                    );
                                    res
                                })
                            })
                    }
                    fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        if v.is_negative() {
                            Err(
                                DeError::custom("user discriminators must not be negative"),
                            )
                        } else {
                            self.visit_u64(v as u64)
                        }
                    }
                    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        if v >= u16::MAX as u64 {
                            Err(
                                DeError::custom({
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0:?} is too big for user discriminator", v),
                                    );
                                    res
                                }),
                            )
                        } else {
                            self.visit_u16(v as u16)
                        }
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }
        impl Serialize for Discriminator {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                self.0.serialize(serializer)
            }
        }
        impl std::ops::Deref for Discriminator {
            type Target = u16;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
    }
    mod flags {
        use crate::internal::macros::bitflags;
        pub struct UserFlags(
            <UserFlags as ::bitflags::__private::PublicFlags>::Internal,
        );
        #[automatically_derived]
        impl ::core::fmt::Debug for UserFlags {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UserFlags",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UserFlags {
            #[inline]
            fn clone(&self) -> UserFlags {
                let _: ::core::clone::AssertParamIsClone<
                    <UserFlags as ::bitflags::__private::PublicFlags>::Internal,
                >;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for UserFlags {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for UserFlags {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for UserFlags {
            #[inline]
            fn eq(&self, other: &UserFlags) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for UserFlags {}
        #[automatically_derived]
        impl ::core::cmp::Eq for UserFlags {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<
                    <UserFlags as ::bitflags::__private::PublicFlags>::Internal,
                >;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for UserFlags {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl UserFlags {
            #[allow(deprecated, non_upper_case_globals)]
            pub const DISCORD_EMPLOYEE: Self = Self::from_bits_retain(1 << 0);
            #[allow(deprecated, non_upper_case_globals)]
            pub const PARTNERED_SERVER_OWNER: Self = Self::from_bits_retain(1 << 1);
            #[allow(deprecated, non_upper_case_globals)]
            pub const HYPESQUAD_EVENTS: Self = Self::from_bits_retain(1 << 2);
            #[allow(deprecated, non_upper_case_globals)]
            pub const BUG_HUNTER_LEVEL_1: Self = Self::from_bits_retain(1 << 3);
            #[allow(deprecated, non_upper_case_globals)]
            pub const HYPESQUAD_BRAVERY: Self = Self::from_bits_retain(1 << 6);
            #[allow(deprecated, non_upper_case_globals)]
            pub const HYPESQUAD_BRILLIANCE: Self = Self::from_bits_retain(1 << 7);
            #[allow(deprecated, non_upper_case_globals)]
            pub const HYPESQUAD_BALANCE: Self = Self::from_bits_retain(1 << 8);
            #[allow(deprecated, non_upper_case_globals)]
            pub const EARLY_PREMIUM_SUPPORTER: Self = Self::from_bits_retain(1 << 9);
            #[allow(deprecated, non_upper_case_globals)]
            pub const TEAM_PSEUDO_USER: Self = Self::from_bits_retain(1 << 10);
            #[allow(deprecated, non_upper_case_globals)]
            pub const BUG_HUNTER_LEVEL_2: Self = Self::from_bits_retain(1 << 14);
            #[allow(deprecated, non_upper_case_globals)]
            pub const VERIFIED_BOT: Self = Self::from_bits_retain(1 << 16);
            #[allow(deprecated, non_upper_case_globals)]
            pub const EARLY_VERIFIED_BOT_DEVELOPER: Self = Self::from_bits_retain(
                1 << 17,
            );
            #[allow(deprecated, non_upper_case_globals)]
            pub const CERTIFIED_MODERATOR: Self = Self::from_bits_retain(1 << 18);
            #[allow(deprecated, non_upper_case_globals)]
            pub const BOT_USE_ONLY_HTTP_INTERACTIONS: Self = Self::from_bits_retain(
                1 << 19,
            );
            #[allow(deprecated, non_upper_case_globals)]
            pub const ACTIVE_DEVELOPER: Self = Self::from_bits_retain(1 << 22);
        }
        impl ::bitflags::Flags for UserFlags {
            const FLAGS: &'static [::bitflags::Flag<UserFlags>] = &[
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "DISCORD_EMPLOYEE",
                        UserFlags::DISCORD_EMPLOYEE,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "PARTNERED_SERVER_OWNER",
                        UserFlags::PARTNERED_SERVER_OWNER,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "HYPESQUAD_EVENTS",
                        UserFlags::HYPESQUAD_EVENTS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "BUG_HUNTER_LEVEL_1",
                        UserFlags::BUG_HUNTER_LEVEL_1,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "HYPESQUAD_BRAVERY",
                        UserFlags::HYPESQUAD_BRAVERY,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "HYPESQUAD_BRILLIANCE",
                        UserFlags::HYPESQUAD_BRILLIANCE,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "HYPESQUAD_BALANCE",
                        UserFlags::HYPESQUAD_BALANCE,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "EARLY_PREMIUM_SUPPORTER",
                        UserFlags::EARLY_PREMIUM_SUPPORTER,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "TEAM_PSEUDO_USER",
                        UserFlags::TEAM_PSEUDO_USER,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "BUG_HUNTER_LEVEL_2",
                        UserFlags::BUG_HUNTER_LEVEL_2,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("VERIFIED_BOT", UserFlags::VERIFIED_BOT)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "EARLY_VERIFIED_BOT_DEVELOPER",
                        UserFlags::EARLY_VERIFIED_BOT_DEVELOPER,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "CERTIFIED_MODERATOR",
                        UserFlags::CERTIFIED_MODERATOR,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "BOT_USE_ONLY_HTTP_INTERACTIONS",
                        UserFlags::BOT_USE_ONLY_HTTP_INTERACTIONS,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "ACTIVE_DEVELOPER",
                        UserFlags::ACTIVE_DEVELOPER,
                    )
                },
            ];
            type Bits = u32;
            fn bits(&self) -> u32 {
                UserFlags::bits(self)
            }
            fn from_bits_retain(bits: u32) -> UserFlags {
                UserFlags::from_bits_retain(bits)
            }
        }
        #[allow(
            dead_code,
            deprecated,
            unused_doc_comments,
            unused_attributes,
            unused_mut,
            unused_imports,
            non_upper_case_globals,
            clippy::assign_op_pattern
        )]
        const _: () = {
            #[repr(transparent)]
            pub struct InternalBitFlags(u32);
            #[automatically_derived]
            impl ::core::clone::Clone for InternalBitFlags {
                #[inline]
                fn clone(&self) -> InternalBitFlags {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for InternalBitFlags {
                #[inline]
                fn eq(&self, other: &InternalBitFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for InternalBitFlags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for InternalBitFlags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &InternalBitFlags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for InternalBitFlags {
                #[inline]
                fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for InternalBitFlags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            impl ::bitflags::__private::PublicFlags for UserFlags {
                type Primitive = u32;
                type Internal = InternalBitFlags;
            }
            impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                #[inline]
                fn default() -> Self {
                    InternalBitFlags::empty()
                }
            }
            impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    if self.is_empty() {
                        f.write_fmt(
                            format_args!("{0:#x}", < u32 as ::bitflags::Bits >::EMPTY),
                        )
                    } else {
                        ::bitflags::__private::core::fmt::Display::fmt(self, f)
                    }
                }
            }
            impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::parser::to_writer(&UserFlags(*self), f)
                }
            }
            impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                type Err = ::bitflags::parser::ParseError;
                fn from_str(
                    s: &str,
                ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                    ::bitflags::parser::from_str::<UserFlags>(s).map(|flags| flags.0)
                }
            }
            impl ::bitflags::__private::core::convert::AsRef<u32> for InternalBitFlags {
                fn as_ref(&self) -> &u32 {
                    &self.0
                }
            }
            impl ::bitflags::__private::core::convert::From<u32> for InternalBitFlags {
                fn from(bits: u32) -> Self {
                    Self::from_bits_retain(bits)
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl InternalBitFlags {
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(<u32 as ::bitflags::Bits>::EMPTY) }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    { Self::from_bits_truncate(<u32 as ::bitflags::Bits>::ALL) }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u32 {
                    let f = self;
                    { f.0 }
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u32,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        let truncated = Self::from_bits_truncate(bits).0;
                        if truncated == bits {
                            ::bitflags::__private::core::option::Option::Some(Self(bits))
                        } else {
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u32) -> Self {
                    let bits = bits;
                    {
                        if bits == <u32 as ::bitflags::Bits>::EMPTY {
                            return Self(bits);
                        }
                        let mut truncated = <u32 as ::bitflags::Bits>::EMPTY;
                        {
                            if bits & UserFlags::DISCORD_EMPLOYEE.bits()
                                == UserFlags::DISCORD_EMPLOYEE.bits()
                            {
                                truncated = truncated | UserFlags::DISCORD_EMPLOYEE.bits();
                            }
                        };
                        {
                            if bits & UserFlags::PARTNERED_SERVER_OWNER.bits()
                                == UserFlags::PARTNERED_SERVER_OWNER.bits()
                            {
                                truncated = truncated
                                    | UserFlags::PARTNERED_SERVER_OWNER.bits();
                            }
                        };
                        {
                            if bits & UserFlags::HYPESQUAD_EVENTS.bits()
                                == UserFlags::HYPESQUAD_EVENTS.bits()
                            {
                                truncated = truncated | UserFlags::HYPESQUAD_EVENTS.bits();
                            }
                        };
                        {
                            if bits & UserFlags::BUG_HUNTER_LEVEL_1.bits()
                                == UserFlags::BUG_HUNTER_LEVEL_1.bits()
                            {
                                truncated = truncated
                                    | UserFlags::BUG_HUNTER_LEVEL_1.bits();
                            }
                        };
                        {
                            if bits & UserFlags::HYPESQUAD_BRAVERY.bits()
                                == UserFlags::HYPESQUAD_BRAVERY.bits()
                            {
                                truncated = truncated | UserFlags::HYPESQUAD_BRAVERY.bits();
                            }
                        };
                        {
                            if bits & UserFlags::HYPESQUAD_BRILLIANCE.bits()
                                == UserFlags::HYPESQUAD_BRILLIANCE.bits()
                            {
                                truncated = truncated
                                    | UserFlags::HYPESQUAD_BRILLIANCE.bits();
                            }
                        };
                        {
                            if bits & UserFlags::HYPESQUAD_BALANCE.bits()
                                == UserFlags::HYPESQUAD_BALANCE.bits()
                            {
                                truncated = truncated | UserFlags::HYPESQUAD_BALANCE.bits();
                            }
                        };
                        {
                            if bits & UserFlags::EARLY_PREMIUM_SUPPORTER.bits()
                                == UserFlags::EARLY_PREMIUM_SUPPORTER.bits()
                            {
                                truncated = truncated
                                    | UserFlags::EARLY_PREMIUM_SUPPORTER.bits();
                            }
                        };
                        {
                            if bits & UserFlags::TEAM_PSEUDO_USER.bits()
                                == UserFlags::TEAM_PSEUDO_USER.bits()
                            {
                                truncated = truncated | UserFlags::TEAM_PSEUDO_USER.bits();
                            }
                        };
                        {
                            if bits & UserFlags::BUG_HUNTER_LEVEL_2.bits()
                                == UserFlags::BUG_HUNTER_LEVEL_2.bits()
                            {
                                truncated = truncated
                                    | UserFlags::BUG_HUNTER_LEVEL_2.bits();
                            }
                        };
                        {
                            if bits & UserFlags::VERIFIED_BOT.bits()
                                == UserFlags::VERIFIED_BOT.bits()
                            {
                                truncated = truncated | UserFlags::VERIFIED_BOT.bits();
                            }
                        };
                        {
                            if bits & UserFlags::EARLY_VERIFIED_BOT_DEVELOPER.bits()
                                == UserFlags::EARLY_VERIFIED_BOT_DEVELOPER.bits()
                            {
                                truncated = truncated
                                    | UserFlags::EARLY_VERIFIED_BOT_DEVELOPER.bits();
                            }
                        };
                        {
                            if bits & UserFlags::CERTIFIED_MODERATOR.bits()
                                == UserFlags::CERTIFIED_MODERATOR.bits()
                            {
                                truncated = truncated
                                    | UserFlags::CERTIFIED_MODERATOR.bits();
                            }
                        };
                        {
                            if bits & UserFlags::BOT_USE_ONLY_HTTP_INTERACTIONS.bits()
                                == UserFlags::BOT_USE_ONLY_HTTP_INTERACTIONS.bits()
                            {
                                truncated = truncated
                                    | UserFlags::BOT_USE_ONLY_HTTP_INTERACTIONS.bits();
                            }
                        };
                        {
                            if bits & UserFlags::ACTIVE_DEVELOPER.bits()
                                == UserFlags::ACTIVE_DEVELOPER.bits()
                            {
                                truncated = truncated | UserFlags::ACTIVE_DEVELOPER.bits();
                            }
                        };
                        Self(truncated)
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                #[inline]
                pub const fn from_bits_retain(bits: u32) -> Self {
                    let bits = bits;
                    { Self(bits) }
                }
                /// Get the value for a flag from its stringified name.
                ///
                /// Names are _case-sensitive_, so must correspond exactly to
                /// the identifier given to the flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        {
                            if name == "DISCORD_EMPLOYEE" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::DISCORD_EMPLOYEE.bits()),
                                );
                            }
                        };
                        {
                            if name == "PARTNERED_SERVER_OWNER" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::PARTNERED_SERVER_OWNER.bits()),
                                );
                            }
                        };
                        {
                            if name == "HYPESQUAD_EVENTS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::HYPESQUAD_EVENTS.bits()),
                                );
                            }
                        };
                        {
                            if name == "BUG_HUNTER_LEVEL_1" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::BUG_HUNTER_LEVEL_1.bits()),
                                );
                            }
                        };
                        {
                            if name == "HYPESQUAD_BRAVERY" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::HYPESQUAD_BRAVERY.bits()),
                                );
                            }
                        };
                        {
                            if name == "HYPESQUAD_BRILLIANCE" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::HYPESQUAD_BRILLIANCE.bits()),
                                );
                            }
                        };
                        {
                            if name == "HYPESQUAD_BALANCE" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::HYPESQUAD_BALANCE.bits()),
                                );
                            }
                        };
                        {
                            if name == "EARLY_PREMIUM_SUPPORTER" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::EARLY_PREMIUM_SUPPORTER.bits()),
                                );
                            }
                        };
                        {
                            if name == "TEAM_PSEUDO_USER" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::TEAM_PSEUDO_USER.bits()),
                                );
                            }
                        };
                        {
                            if name == "BUG_HUNTER_LEVEL_2" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::BUG_HUNTER_LEVEL_2.bits()),
                                );
                            }
                        };
                        {
                            if name == "VERIFIED_BOT" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::VERIFIED_BOT.bits()),
                                );
                            }
                        };
                        {
                            if name == "EARLY_VERIFIED_BOT_DEVELOPER" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::EARLY_VERIFIED_BOT_DEVELOPER.bits()),
                                );
                            }
                        };
                        {
                            if name == "CERTIFIED_MODERATOR" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::CERTIFIED_MODERATOR.bits()),
                                );
                            }
                        };
                        {
                            if name == "BOT_USE_ONLY_HTTP_INTERACTIONS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::BOT_USE_ONLY_HTTP_INTERACTIONS.bits()),
                                );
                            }
                        };
                        {
                            if name == "ACTIVE_DEVELOPER" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(UserFlags::ACTIVE_DEVELOPER.bits()),
                                );
                            }
                        };
                        let _ = name;
                        ::bitflags::__private::core::option::Option::None
                    }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.0 == Self::empty().0 }
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { Self::all().0 | f.0 == f.0 }
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { !(Self(f.0 & other.0)).is_empty() }
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { (f.0 & other.0) == other.0 }
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        f.0 = f.0 | other.0;
                    }
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        f.0 = f.0 & !other.0;
                    }
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        f.0 = f.0 ^ other.0;
                    }
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    {
                        if value {
                            f.insert(other);
                        } else {
                            f.remove(other);
                        }
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 & other.0) }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 | other.0) }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 & !other.0) }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0 ^ other.0) }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self::from_bits_truncate(!f.0) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Binary::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Octal::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: InternalBitFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.0 = self.0 | other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for InternalBitFlags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.0 = self.0 ^ other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for InternalBitFlags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.0 = self.0 & other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.0 = self.0 & !other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
            for InternalBitFlags {
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
            for InternalBitFlags {
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl InternalBitFlags {
                /// Iterate over enabled flag values.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<UserFlags> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <UserFlags as ::bitflags::Flags>::FLAGS,
                        UserFlags::from_bits_retain(self.bits()),
                        UserFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Iterate over enabled flag values with their stringified names.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<UserFlags> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <UserFlags as ::bitflags::Flags>::FLAGS,
                        UserFlags::from_bits_retain(self.bits()),
                        UserFlags::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for InternalBitFlags {
                type Item = UserFlags;
                type IntoIter = ::bitflags::iter::Iter<UserFlags>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
            impl InternalBitFlags {
                /// Returns a mutable reference to the raw value of the flags currently stored.
                #[inline]
                pub fn bits_mut(&mut self) -> &mut u32 {
                    &mut self.0
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl UserFlags {
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(InternalBitFlags::empty()) }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    { Self(InternalBitFlags::all()) }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u32 {
                    let f = self;
                    { f.0.bits() }
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u32,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        match InternalBitFlags::from_bits(bits) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u32) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_truncate(bits)) }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                #[inline]
                pub const fn from_bits_retain(bits: u32) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_retain(bits)) }
                }
                /// Get the value for a flag from its stringified name.
                ///
                /// Names are _case-sensitive_, so must correspond exactly to
                /// the identifier given to the flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        match InternalBitFlags::from_name(name) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.0.is_empty() }
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { f.0.is_all() }
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.intersects(other.0) }
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.contains(other.0) }
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.insert(other.0) }
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.remove(other.0) }
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.toggle(other.0) }
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    { f.0.set(other.0, value) }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.intersection(other.0)) }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.union(other.0)) }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.difference(other.0)) }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.symmetric_difference(other.0)) }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self(f.0.complement()) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for UserFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Binary::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for UserFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::Octal::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for UserFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for UserFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&self.0, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for UserFlags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: UserFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for UserFlags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.0 = self.0 | other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for UserFlags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for UserFlags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.0 = self.0 ^ other.0;
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for UserFlags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for UserFlags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.0 = self.0 & other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Sub for UserFlags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for UserFlags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.0 = self.0 & !other.0;
                }
            }
            impl ::bitflags::__private::core::ops::Not for UserFlags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<UserFlags> for UserFlags {
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<UserFlags>
            for UserFlags {
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl UserFlags {
                /// Iterate over enabled flag values.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<UserFlags> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <UserFlags as ::bitflags::Flags>::FLAGS,
                        UserFlags::from_bits_retain(self.bits()),
                        UserFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Iterate over enabled flag values with their stringified names.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<UserFlags> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <UserFlags as ::bitflags::Flags>::FLAGS,
                        UserFlags::from_bits_retain(self.bits()),
                        UserFlags::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for UserFlags {
                type Item = UserFlags;
                type IntoIter = ::bitflags::iter::Iter<UserFlags>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
        };
        impl<'de> ::serde::Deserialize<'de> for UserFlags {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                <u32>::deserialize(deserializer).map(Self::from_bits_truncate)
            }
        }
        impl ::serde::Serialize for UserFlags {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                self.bits().serialize(serializer)
            }
        }
        impl UserFlags {
            pub const fn is_discord_partner(&self) -> bool {
                self.intersects(Self::PARTNERED_SERVER_OWNER)
            }
            pub const fn is_verified_bot(&self) -> bool {
                self.intersects(Self::VERIFIED_BOT)
            }
            pub const fn is_discord_employee(&self) -> bool {
                self.intersects(Self::DISCORD_EMPLOYEE)
            }
        }
        impl UserFlags {
            pub const BUG_HUNTER: Self = Self::from_bits_truncate(
                Self::BUG_HUNTER_LEVEL_1.bits() | Self::BUG_HUNTER_LEVEL_2.bits(),
            );
            pub const fn is_bug_hunter(&self) -> bool {
                self.intersects(Self::BUG_HUNTER)
            }
        }
        impl UserFlags {
            pub const HYPESQUAD_MEMBER: Self = Self::from_bits_truncate(
                Self::HYPESQUAD_EVENTS.bits() | Self::HYPESQUAD_BRAVERY.bits()
                    | Self::HYPESQUAD_BRILLIANCE.bits() | Self::HYPESQUAD_BALANCE.bits(),
            );
            pub const fn is_hypesquad_member(&self) -> bool {
                self.intersects(Self::HYPESQUAD_MEMBER)
            }
        }
    }
    mod premium_type {
        use crate::internal::macros::enum_repr;
        #[non_exhaustive]
        pub enum UserPremiumType {
            None = 0,
            Classic,
            Nitro,
            Basic,
            Unknown = !0,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UserPremiumType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        UserPremiumType::None => "None",
                        UserPremiumType::Classic => "Classic",
                        UserPremiumType::Nitro => "Nitro",
                        UserPremiumType::Basic => "Basic",
                        UserPremiumType::Unknown => "Unknown",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UserPremiumType {
            #[inline]
            fn clone(&self) -> UserPremiumType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for UserPremiumType {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for UserPremiumType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for UserPremiumType {
            #[inline]
            fn eq(&self, other: &UserPremiumType) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for UserPremiumType {}
        #[automatically_derived]
        impl ::core::cmp::Eq for UserPremiumType {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for UserPremiumType {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl UserPremiumType {
            #[doc(hidden)]
            fn __internal_enum_repr(value: u64) -> Option<Self> {
                match value {
                    _ if value == UserPremiumType::None.value() => Some(Self::None),
                    _ if value == UserPremiumType::Classic.value() => Some(Self::Classic),
                    _ if value == UserPremiumType::Nitro.value() => Some(Self::Nitro),
                    _ if value == UserPremiumType::Basic.value() => Some(Self::Basic),
                    _ => Some(Self::Unknown),
                }
            }
        }
        impl UserPremiumType {
            pub const fn value(&self) -> u64 {
                *self as u64
            }
        }
        impl<'de> serde::Deserialize<'de> for UserPremiumType {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = UserPremiumType;
                    fn expecting(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        f.write_str("UserPremiumType type (integer)")
                    }
                    fn visit_u64<E>(self, value: u64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        UserPremiumType::__internal_enum_repr(value)
                            .ok_or_else(|| {
                                serde::de::Error::custom({
                                    let res = ::alloc::fmt::format(
                                        format_args!("unknown UserPremiumType variant: {0}", value),
                                    );
                                    res
                                })
                            })
                    }
                }
                deserializer.deserialize_u64(Visitor)
            }
        }
        impl serde::Serialize for UserPremiumType {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                serializer.serialize_u64(self.value())
            }
        }
    }
    pub use connection::*;
    pub use discriminator::*;
    pub use flags::*;
    pub use premium_type::*;
    pub struct User {
        pub id: UserId,
        #[serde(rename = "username")]
        pub name: String,
        pub discriminator: Discriminator,
        pub avatar: Option<ImageHash>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub bot: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub system: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub mfa_enabled: Option<bool>,
        pub banner: Option<ImageHash>,
        pub accent_color: Option<Color>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub locale: Option<Locale>,
        pub verified: Option<bool>,
        pub email: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub flags: Option<UserFlags>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub premium_type: Option<UserPremiumType>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub public_flags: Option<UserFlags>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for User {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "name",
                "discriminator",
                "avatar",
                "bot",
                "system",
                "mfa_enabled",
                "banner",
                "accent_color",
                "locale",
                "verified",
                "email",
                "flags",
                "premium_type",
                "public_flags",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.name,
                &self.discriminator,
                &self.avatar,
                &self.bot,
                &self.system,
                &self.mfa_enabled,
                &self.banner,
                &self.accent_color,
                &self.locale,
                &self.verified,
                &self.email,
                &self.flags,
                &self.premium_type,
                &&self.public_flags,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "User", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for User {
        #[inline]
        fn clone(&self) -> User {
            User {
                id: ::core::clone::Clone::clone(&self.id),
                name: ::core::clone::Clone::clone(&self.name),
                discriminator: ::core::clone::Clone::clone(&self.discriminator),
                avatar: ::core::clone::Clone::clone(&self.avatar),
                bot: ::core::clone::Clone::clone(&self.bot),
                system: ::core::clone::Clone::clone(&self.system),
                mfa_enabled: ::core::clone::Clone::clone(&self.mfa_enabled),
                banner: ::core::clone::Clone::clone(&self.banner),
                accent_color: ::core::clone::Clone::clone(&self.accent_color),
                locale: ::core::clone::Clone::clone(&self.locale),
                verified: ::core::clone::Clone::clone(&self.verified),
                email: ::core::clone::Clone::clone(&self.email),
                flags: ::core::clone::Clone::clone(&self.flags),
                premium_type: ::core::clone::Clone::clone(&self.premium_type),
                public_flags: ::core::clone::Clone::clone(&self.public_flags),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for User {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for User {
        #[inline]
        fn eq(&self, other: &User) -> bool {
            self.id == other.id && self.name == other.name
                && self.discriminator == other.discriminator
                && self.avatar == other.avatar && self.bot == other.bot
                && self.system == other.system && self.mfa_enabled == other.mfa_enabled
                && self.banner == other.banner && self.accent_color == other.accent_color
                && self.locale == other.locale && self.verified == other.verified
                && self.email == other.email && self.flags == other.flags
                && self.premium_type == other.premium_type
                && self.public_flags == other.public_flags
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for User {}
    #[automatically_derived]
    impl ::core::cmp::Eq for User {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<UserId>;
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<Discriminator>;
            let _: ::core::cmp::AssertParamIsEq<Option<ImageHash>>;
            let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
            let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
            let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
            let _: ::core::cmp::AssertParamIsEq<Option<ImageHash>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Color>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Locale>>;
            let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            let _: ::core::cmp::AssertParamIsEq<Option<UserFlags>>;
            let _: ::core::cmp::AssertParamIsEq<Option<UserPremiumType>>;
            let _: ::core::cmp::AssertParamIsEq<Option<UserFlags>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for User {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.id, state);
            ::core::hash::Hash::hash(&self.name, state);
            ::core::hash::Hash::hash(&self.discriminator, state);
            ::core::hash::Hash::hash(&self.avatar, state);
            ::core::hash::Hash::hash(&self.bot, state);
            ::core::hash::Hash::hash(&self.system, state);
            ::core::hash::Hash::hash(&self.mfa_enabled, state);
            ::core::hash::Hash::hash(&self.banner, state);
            ::core::hash::Hash::hash(&self.accent_color, state);
            ::core::hash::Hash::hash(&self.locale, state);
            ::core::hash::Hash::hash(&self.verified, state);
            ::core::hash::Hash::hash(&self.email, state);
            ::core::hash::Hash::hash(&self.flags, state);
            ::core::hash::Hash::hash(&self.premium_type, state);
            ::core::hash::Hash::hash(&self.public_flags, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for User {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "username" => _serde::__private::Ok(__Field::__field1),
                            "discriminator" => _serde::__private::Ok(__Field::__field2),
                            "avatar" => _serde::__private::Ok(__Field::__field3),
                            "bot" => _serde::__private::Ok(__Field::__field4),
                            "system" => _serde::__private::Ok(__Field::__field5),
                            "mfa_enabled" => _serde::__private::Ok(__Field::__field6),
                            "banner" => _serde::__private::Ok(__Field::__field7),
                            "accent_color" => _serde::__private::Ok(__Field::__field8),
                            "locale" => _serde::__private::Ok(__Field::__field9),
                            "verified" => _serde::__private::Ok(__Field::__field10),
                            "email" => _serde::__private::Ok(__Field::__field11),
                            "flags" => _serde::__private::Ok(__Field::__field12),
                            "premium_type" => _serde::__private::Ok(__Field::__field13),
                            "public_flags" => _serde::__private::Ok(__Field::__field14),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"username" => _serde::__private::Ok(__Field::__field1),
                            b"discriminator" => _serde::__private::Ok(__Field::__field2),
                            b"avatar" => _serde::__private::Ok(__Field::__field3),
                            b"bot" => _serde::__private::Ok(__Field::__field4),
                            b"system" => _serde::__private::Ok(__Field::__field5),
                            b"mfa_enabled" => _serde::__private::Ok(__Field::__field6),
                            b"banner" => _serde::__private::Ok(__Field::__field7),
                            b"accent_color" => _serde::__private::Ok(__Field::__field8),
                            b"locale" => _serde::__private::Ok(__Field::__field9),
                            b"verified" => _serde::__private::Ok(__Field::__field10),
                            b"email" => _serde::__private::Ok(__Field::__field11),
                            b"flags" => _serde::__private::Ok(__Field::__field12),
                            b"premium_type" => _serde::__private::Ok(__Field::__field13),
                            b"public_flags" => _serde::__private::Ok(__Field::__field14),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<User>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = User;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct User",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            UserId,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Discriminator,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            Option<ImageHash>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            Option<bool>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match match _serde::de::SeqAccess::next_element::<
                            Option<bool>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match match _serde::de::SeqAccess::next_element::<
                            Option<bool>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match match _serde::de::SeqAccess::next_element::<
                            Option<ImageHash>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match match _serde::de::SeqAccess::next_element::<
                            Option<Color>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match match _serde::de::SeqAccess::next_element::<
                            Option<Locale>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match match _serde::de::SeqAccess::next_element::<
                            Option<bool>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match match _serde::de::SeqAccess::next_element::<
                            Option<UserFlags>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field13 = match match _serde::de::SeqAccess::next_element::<
                            Option<UserPremiumType>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field14 = match match _serde::de::SeqAccess::next_element::<
                            Option<UserFlags>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        14usize,
                                        &"struct User with 15 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(User {
                            id: __field0,
                            name: __field1,
                            discriminator: __field2,
                            avatar: __field3,
                            bot: __field4,
                            system: __field5,
                            mfa_enabled: __field6,
                            banner: __field7,
                            accent_color: __field8,
                            locale: __field9,
                            verified: __field10,
                            email: __field11,
                            flags: __field12,
                            premium_type: __field13,
                            public_flags: __field14,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<UserId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Discriminator> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<ImageHash>> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Option<ImageHash>> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Option<Color>> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<Option<Locale>> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<
                            Option<UserFlags>,
                        > = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<
                            Option<UserPremiumType>,
                        > = _serde::__private::None;
                        let mut __field14: _serde::__private::Option<
                            Option<UserFlags>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key)
                            = match _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            UserId,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "username",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "discriminator",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Discriminator,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("avatar"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<ImageHash>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("bot"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<bool>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("system"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<bool>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "mfa_enabled",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<bool>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("banner"),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<ImageHash>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "accent_color",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<Color>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("locale"),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<Locale>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "verified",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<bool>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("email"),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("flags"),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<UserFlags>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "premium_type",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<UserPremiumType>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "public_flags",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<UserFlags>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("username") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "discriminator",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("avatar") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("bot") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("system") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("mfa_enabled") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("banner") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("accent_color") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("locale") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("verified") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("email") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("flags") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("premium_type") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("public_flags") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(User {
                            id: __field0,
                            name: __field1,
                            discriminator: __field2,
                            avatar: __field3,
                            bot: __field4,
                            system: __field5,
                            mfa_enabled: __field6,
                            banner: __field7,
                            accent_color: __field8,
                            locale: __field9,
                            verified: __field10,
                            email: __field11,
                            flags: __field12,
                            premium_type: __field13,
                            public_flags: __field14,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "username",
                    "discriminator",
                    "avatar",
                    "bot",
                    "system",
                    "mfa_enabled",
                    "banner",
                    "accent_color",
                    "locale",
                    "verified",
                    "email",
                    "flags",
                    "premium_type",
                    "public_flags",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "User",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<User>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for User {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "User",
                    false as usize + 1 + 1 + 1 + 1
                        + if Option::is_none(&self.bot) { 0 } else { 1 }
                        + if Option::is_none(&self.system) { 0 } else { 1 }
                        + if Option::is_none(&self.mfa_enabled) { 0 } else { 1 } + 1 + 1
                        + if Option::is_none(&self.locale) { 0 } else { 1 } + 1 + 1
                        + if Option::is_none(&self.flags) { 0 } else { 1 }
                        + if Option::is_none(&self.premium_type) { 0 } else { 1 }
                        + if Option::is_none(&self.public_flags) { 0 } else { 1 },
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "username",
                    &self.name,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "discriminator",
                    &self.discriminator,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "avatar",
                    &self.avatar,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                if !Option::is_none(&self.bot) {
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "bot",
                        &self.bot,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                } else {
                    match _serde::ser::SerializeStruct::skip_field(
                        &mut __serde_state,
                        "bot",
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                }
                if !Option::is_none(&self.system) {
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "system",
                        &self.system,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                } else {
                    match _serde::ser::SerializeStruct::skip_field(
                        &mut __serde_state,
                        "system",
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                }
                if !Option::is_none(&self.mfa_enabled) {
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "mfa_enabled",
                        &self.mfa_enabled,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                } else {
                    match _serde::ser::SerializeStruct::skip_field(
                        &mut __serde_state,
                        "mfa_enabled",
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                }
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "banner",
                    &self.banner,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "accent_color",
                    &self.accent_color,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                if !Option::is_none(&self.locale) {
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "locale",
                        &self.locale,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                } else {
                    match _serde::ser::SerializeStruct::skip_field(
                        &mut __serde_state,
                        "locale",
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                }
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "verified",
                    &self.verified,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "email",
                    &self.email,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                if !Option::is_none(&self.flags) {
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "flags",
                        &self.flags,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                } else {
                    match _serde::ser::SerializeStruct::skip_field(
                        &mut __serde_state,
                        "flags",
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                }
                if !Option::is_none(&self.premium_type) {
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "premium_type",
                        &self.premium_type,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                } else {
                    match _serde::ser::SerializeStruct::skip_field(
                        &mut __serde_state,
                        "premium_type",
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                }
                if !Option::is_none(&self.public_flags) {
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "public_flags",
                        &self.public_flags,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                } else {
                    match _serde::ser::SerializeStruct::skip_field(
                        &mut __serde_state,
                        "public_flags",
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                }
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
}
